{"formal_statement": "theorem to_real_add {a b : ennreal} (ha : a \u2260 \u22a4) (hb : b \u2260 \u22a4) :\n\t(a + b).to_real = a.to_real + b.to_real", "decl_tp": "\u2200 {a b : ennreal}, a \u2260 \u22a4 \u2192 b \u2260 \u22a4 \u2192 (a + b).to_real = a.to_real + b.to_real", "decl_nm": "ennreal.to_real_add"}
{"formal_statement": "theorem comap_eq_lift' {\u03b1 \u03b2 : Type*} {f : filter \u03b2} {m : \u03b1 \u2192 \u03b2} :\n\tfilter.comap m f = f.lift' (set.preimage m)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {f : filter \u03b2} {m : \u03b1 \u2192 \u03b2}, filter.comap m f = f.lift' (set.preimage m)", "decl_nm": "filter.comap_eq_lift'"}
{"formal_statement": "theorem compl_mem_cocompact {\u03b1 : Type u} [topological_space \u03b1] {s : set \u03b1}\n\t(hs : is_compact s) :\n\ts\u1d9c \u2208 filter.cocompact \u03b1", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : topological_space \u03b1] {s : set \u03b1}, is_compact s \u2192 s\u1d9c \u2208 filter.cocompact \u03b1", "decl_nm": "is_compact.compl_mem_cocompact"}
{"formal_statement": "theorem filter_sum {\u03b1 \u03b9 M : Type*} [add_comm_monoid M] {p : \u03b1 \u2192 Prop} (s : finset \u03b9)\n\t(f : \u03b9 \u2192 \u03b1 \u2192\u2080 M) :\n\tfinsupp.filter p (s.sum (\u03bb (a : \u03b9), f a)) = s.sum (\u03bb (a : \u03b9), finsupp.filter p (f a))", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b9 : Type u_4} {M : Type u_5} [_inst_1 : add_comm_monoid M] {p : \u03b1 \u2192 Prop} (s : finset \u03b9) (f : \u03b9 \u2192 \u03b1 \u2192\u2080 M), finsupp.filter p (s.sum (\u03bb (a : \u03b9), f a)) = s.sum (\u03bb (a : \u03b9), finsupp.filter p (f a))", "decl_nm": "finsupp.filter_sum"}
{"formal_statement": "theorem preimage_of_closed_map {\u03b1 : Type u} {\u03b2 : Type v} [topological_space \u03b1]\n\t[topological_space \u03b2] {s : set \u03b2} (hs : is_connected s) (hinj : function.injective f)\n\t(hf : is_closed_map f) (hsf : s \u2286 set.range f) :\n\t\u2200 {f : \u03b1 \u2192 \u03b2},    is_connected (f \u207b\u00b9' s)", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : topological_space \u03b1] [_inst_2 : topological_space \u03b2] {s : set \u03b2}, is_connected s \u2192 \u2200 {f : \u03b1 \u2192 \u03b2}, function.injective f \u2192 is_closed_map f \u2192 s \u2286 set.range f \u2192 is_connected (f \u207b\u00b9' s)", "decl_nm": "is_connected.preimage_of_closed_map"}
{"formal_statement": "theorem smul_pi_subset {K \u03b9 : Type*} {R : \u03b9 \u2192 Type*} [\u03a0 (i : \u03b9), has_scalar K (R i)]\n\t(r : K) (s : set \u03b9) (t : \u03a0 (i : \u03b9), set (R i)) :\n\tr \u2022 s.pi t \u2286 s.pi (r \u2022 t)", "decl_tp": "\u2200 {K : Type u_1} {\u03b9 : Type u_2} {R : \u03b9 \u2192 Type u_3} [_inst_1 : \u03a0 (i : \u03b9), has_scalar K (R i)] (r : K) (s : set \u03b9) (t : \u03a0 (i : \u03b9), set (R i)), r \u2022 s.pi t \u2286 s.pi (r \u2022 t)", "decl_nm": "smul_pi_subset"}
{"formal_statement": "theorem is_subterminal_of_terminal {C : Type u\u2081} [category_theory.category C]\n\t[category_theory.limits.has_terminal C] :\n\tcategory_theory.is_subterminal (\u22a4_ C)", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] [_inst_2 : category_theory.limits.has_terminal C], category_theory.is_subterminal (\u22a4_ C)", "decl_nm": "category_theory.is_subterminal_of_terminal"}
{"formal_statement": "theorem add_lt_of_add_lt_right {\u03b1 : Type*} {a b c d : \u03b1} [preorder \u03b1] [has_add \u03b1]\n\t[covariant_class \u03b1 \u03b1 (function.swap has_add.add) has_le.le] (h : a + b < c)\n\t(hle : d \u2264 a) :\n\td + b < c", "decl_tp": "\u2200 {\u03b1 : Type u_1} {a b c d : \u03b1} [_inst_1 : preorder \u03b1] [_inst_2 : has_add \u03b1] [_inst_3 : covariant_class \u03b1 \u03b1 (function.swap has_add.add) has_le.le], a + b < c \u2192 d \u2264 a \u2192 d + b < c", "decl_nm": "add_lt_of_add_lt_right"}
{"formal_statement": "theorem infinite_pigeonhole_card_lt {\u03b2 \u03b1 : Type u} (f : \u03b2 \u2192 \u03b1) (w : cardinal.mk \u03b1 < cardinal.mk \u03b2)\n\t(w' : cardinal.omega \u2264 cardinal.mk \u03b1) :\n\t(\u2203 (a : \u03b1), cardinal.mk \u03b1 < cardinal.mk \u21a5(f \u207b\u00b9' {a}))", "decl_tp": "\u2200 {\u03b2 \u03b1 : Type u} (f : \u03b2 \u2192 \u03b1), cardinal.mk \u03b1 < cardinal.mk \u03b2 \u2192 cardinal.omega \u2264 cardinal.mk \u03b1 \u2192 (\u2203 (a : \u03b1), cardinal.mk \u03b1 < cardinal.mk \u21a5(f \u207b\u00b9' {a}))", "decl_nm": "cardinal.infinite_pigeonhole_card_lt"}
{"formal_statement": "theorem le_eq_subset {\u03b1 : Type*} :\n\thas_le.le = has_subset.subset", "decl_tp": "\u2200 {\u03b1 : Type u_1}, has_le.le = has_subset.subset", "decl_nm": "set.le_eq_subset"}
{"formal_statement": "theorem supports_run {K : Type*} [decidable_eq K] {\u0393 : K \u2192 Type*} {\u039b : Type*}\n\t[inhabited \u039b] {\u03c3 : Type*} [inhabited \u03c3] (S : finset \u039b) {k : K} (s : turing.TM2to1.st_act k)\n\t(q : turing.TM2.stmt \u0393 \u039b \u03c3) :\n\tturing.TM2.supports_stmt S (turing.TM2to1.st_run s q) \u2194 turing.TM2.supports_stmt S q", "decl_tp": "\u2200 {K : Type u_1} [_inst_1 : decidable_eq K] {\u0393 : K \u2192 Type u_2} {\u039b : Type u_3} [_inst_2 : inhabited \u039b] {\u03c3 : Type u_4} [_inst_3 : inhabited \u03c3] (S : finset \u039b) {k : K} (s : turing.TM2to1.st_act k) (q : turing.TM2.stmt \u0393 \u039b \u03c3), turing.TM2.supports_stmt S (turing.TM2to1.st_run s q) \u2194 turing.TM2.supports_stmt S q", "decl_nm": "turing.TM2to1.supports_run"}
{"formal_statement": "theorem mem_inter {\u03b1 : Type*} [decidable_eq \u03b1] {a : \u03b1} {s\u2081 s\u2082 : finset \u03b1} :\n\ta \u2208 s\u2081 \u2229 s\u2082 \u2194 a \u2208 s\u2081 \u2227 a \u2208 s\u2082", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : decidable_eq \u03b1] {a : \u03b1} {s\u2081 s\u2082 : finset \u03b1}, a \u2208 s\u2081 \u2229 s\u2082 \u2194 a \u2208 s\u2081 \u2227 a \u2208 s\u2082", "decl_nm": "finset.mem_inter"}
{"formal_statement": "theorem is_O_with_congr {\u03b1 E F : Type*} [has_norm E] [has_norm F] {c\u2081 c\u2082 : \u211d}\n\t{f\u2081 f\u2082 : \u03b1 \u2192 E} {g\u2081 g\u2082 : \u03b1 \u2192 F} {l : filter \u03b1} (hc : c\u2081 = c\u2082) (hf : f\u2081 =\u1da0[l] f\u2082)\n\t(hg : g\u2081 =\u1da0[l] g\u2082) :\n\t(asymptotics.is_O_with c\u2081 f\u2081 g\u2081 l \u2194 asymptotics.is_O_with c\u2082 f\u2082 g\u2082 l)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {E : Type u_3} {F : Type u_4} [_inst_1 : has_norm E] [_inst_2 : has_norm F] {c\u2081 c\u2082 : \u211d} {f\u2081 f\u2082 : \u03b1 \u2192 E} {g\u2081 g\u2082 : \u03b1 \u2192 F} {l : filter \u03b1}, c\u2081 = c\u2082 \u2192 f\u2081 =\u1da0[l] f\u2082 \u2192 g\u2081 =\u1da0[l] g\u2082 \u2192 (asymptotics.is_O_with c\u2081 f\u2081 g\u2081 l \u2194 asymptotics.is_O_with c\u2082 f\u2082 g\u2082 l)", "decl_nm": "asymptotics.is_O_with_congr"}
{"formal_statement": "theorem coe_unop_op_equiv {R : Type*} [monoid R] (u : units R\u1d50\u1d52\u1d56) :\n\t\u2191(mul_opposite.unop (\u21d1units.op_equiv u)) = mul_opposite.unop \u2191u", "decl_tp": "\u2200 {R : Type u_1} [_inst_1 : monoid R] (u : units R\u1d50\u1d52\u1d56), \u2191(mul_opposite.unop (\u21d1units.op_equiv u)) = mul_opposite.unop \u2191u", "decl_nm": "units.coe_unop_op_equiv"}
{"formal_statement": "theorem const_cpow {\u03b1 : Type*} [topological_space \u03b1] {f : \u03b1 \u2192 \u2102} {b : \u2102}\n\t(hf : continuous f) :\n\t(b \u2260 0 \u2228 \u2200 (a : \u03b1), f a \u2260 0) \u2192 continuous (\u03bb (x : \u03b1), b ^ f x)", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : topological_space \u03b1] {f : \u03b1 \u2192 \u2102} {b : \u2102}, continuous f \u2192 (b \u2260 0 \u2228 \u2200 (a : \u03b1), f a \u2260 0) \u2192 continuous (\u03bb (x : \u03b1), b ^ f x)", "decl_nm": "continuous.const_cpow"}
{"formal_statement": "theorem chain_iff {\u03b1 : Type*} (R : \u03b1 \u2192 \u03b1 \u2192 Prop) (\u1fb0 : \u03b1) (\u1fb0_1 : list \u03b1) :\n\tlist.chain R \u1fb0 \u1fb0_1 \u2194 \u1fb0_1 = list.nil \u2228 \u2203 {b : \u03b1} {l : list \u03b1}, R \u1fb0 b \u2227 list.chain R b l \u2227 \u1fb0_1 = b :: l", "decl_tp": "\u2200 {\u03b1 : Type u_1} (R : \u03b1 \u2192 \u03b1 \u2192 Prop) (\u1fb0 : \u03b1) (\u1fb0_1 : list \u03b1), list.chain R \u1fb0 \u1fb0_1 \u2194 \u1fb0_1 = list.nil \u2228 \u2203 {b : \u03b1} {l : list \u03b1}, R \u1fb0 b \u2227 list.chain R b l \u2227 \u1fb0_1 = b :: l", "decl_nm": "list.chain_iff"}
{"formal_statement": "theorem ghost_component_apply {p : \u2115} {R : Type*} [hp : fact (nat.prime p)]\n\t[comm_ring R] (n : \u2115) (x : witt_vector p R) :\n\t\u21d1(witt_vector.ghost_component n) x = \u21d1(mv_polynomial.aeval x.coeff) (witt_polynomial p \u2124 n)", "decl_tp": "\u2200 {p : \u2115} {R : Type u_1} [hp : fact (nat.prime p)] [_inst_1 : comm_ring R] (n : \u2115) (x : witt_vector p R), \u21d1(witt_vector.ghost_component n) x = \u21d1(mv_polynomial.aeval x.coeff) (witt_polynomial p \u2124 n)", "decl_nm": "witt_vector.ghost_component_apply"}
{"formal_statement": "theorem tendsto_nhds_iff {\u03b1 : Type u} {\u03b2 : Type v} [pseudo_emetric_space \u03b1]\n\t[pseudo_emetric_space \u03b2] {\u03b9 : Type*} {f : \u03b1 \u2192 \u03b2} {g : \u03b9 \u2192 \u03b1} {a : filter \u03b9}\n\t{b : \u03b1} (hf : isometry f) :\n\t(filter.tendsto g a (nhds b) \u2194 filter.tendsto (f \u2218 g) a (nhds (f b)))", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : pseudo_emetric_space \u03b1] [_inst_2 : pseudo_emetric_space \u03b2] {\u03b9 : Type u_1} {f : \u03b1 \u2192 \u03b2} {g : \u03b9 \u2192 \u03b1} {a : filter \u03b9} {b : \u03b1}, isometry f \u2192 (filter.tendsto g a (nhds b) \u2194 filter.tendsto (f \u2218 g) a (nhds (f b)))", "decl_nm": "isometry.tendsto_nhds_iff"}
{"formal_statement": "theorem coeff_update_same {R : Type u} [semiring R] (p : polynomial R)\n\t(n : \u2115) (a : R) :\n\t(p.update n a).coeff n = a", "decl_tp": "\u2200 {R : Type u} [_inst_1 : semiring R] (p : polynomial R) (n : \u2115) (a : R), (p.update n a).coeff n = a", "decl_nm": "polynomial.coeff_update_same"}
{"formal_statement": "theorem rec_bot {\u03b1 : Type*} [preorder \u03b1] [order_bot \u03b1] [succ_order \u03b1] [is_succ_archimedean \u03b1]\n\t(p : \u03b1 \u2192 Prop) (hbot : p \u22a5) :\n\t(\u2200 (a : \u03b1), p a \u2192 p (succ_order.succ a)) \u2192 \u2200 (a : \u03b1), p a", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : preorder \u03b1] [_inst_2 : order_bot \u03b1] [_inst_3 : succ_order \u03b1] [_inst_4 : is_succ_archimedean \u03b1] (p : \u03b1 \u2192 Prop), p \u22a5 \u2192 (\u2200 (a : \u03b1), p a \u2192 p (succ_order.succ a)) \u2192 \u2200 (a : \u03b1), p a", "decl_nm": "succ.rec_bot"}
{"formal_statement": "theorem preserves_colimit_nat_iso_inv_app {C : Type u\u2081} [category_theory.category C]\n\t{D : Type u\u2082} [category_theory.category D] (G : C \u2964 D) {J : Type v} [category_theory.small_category J]\n\t[category_theory.limits.preserves_colimits_of_shape J G] [category_theory.limits.has_colimits_of_shape J D]\n\t[category_theory.limits.has_colimits_of_shape J C] (X : J \u2964 C) :\n\t(category_theory.preserves_colimit_nat_iso G).inv.app X = (category_theory.preserves_colimit_iso G X).inv", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {D : Type u\u2082} [_inst_2 : category_theory.category D] (G : C \u2964 D) {J : Type v} [_inst_3 : category_theory.small_category J] [_inst_7 : category_theory.limits.preserves_colimits_of_shape J G] [_inst_8 : category_theory.limits.has_colimits_of_shape J D] [_inst_9 : category_theory.limits.has_colimits_of_shape J C] (X : J \u2964 C), (category_theory.preserves_colimit_nat_iso G).inv.app X = (category_theory.preserves_colimit_iso G X).inv", "decl_nm": "category_theory.preserves_colimit_nat_iso_inv_app"}
{"formal_statement": "theorem coe_to_hom {L : first_order.language} {M N : Type*} [L.Structure M]\n\t[L.Structure N] {f : L.embedding M N} :\n\t\u21d1(f.to_hom) = \u21d1f", "decl_tp": "\u2200 {L : first_order.language} {M : Type u_3} {N : Type u_4} [_inst_1 : L.Structure M] [_inst_2 : L.Structure N] {f : L.embedding M N}, \u21d1(f.to_hom) = \u21d1f", "decl_nm": "first_order.language.embedding.coe_to_hom"}
{"formal_statement": "theorem congr_left {\u03b1 : Type u} {\u03b2 : Type v} {s : set \u03b1} {f : \u03b1 \u2192 \u03b2} {f\u2081' f\u2082' : \u03b2 \u2192 \u03b1}\n\t(h\u2081 : set.left_inv_on f\u2081' f s) (h\u2081' : set.maps_to f s t) (heq : set.eq_on f\u2081' f\u2082' t) :\n\t\u2200 {t : set \u03b2},   set.left_inv_on f\u2082' f s", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {s : set \u03b1} {f : \u03b1 \u2192 \u03b2} {f\u2081' f\u2082' : \u03b2 \u2192 \u03b1}, set.left_inv_on f\u2081' f s \u2192 \u2200 {t : set \u03b2}, set.maps_to f s t \u2192 set.eq_on f\u2081' f\u2082' t \u2192 set.left_inv_on f\u2082' f s", "decl_nm": "set.left_inv_on.congr_left"}
{"formal_statement": "theorem continuous_within_at_Ioo_iff_Ioi {\u03b1 : Type u} {\u03b2 : Type v} [topological_space \u03b1]\n\t[linear_order \u03b1] [order_closed_topology \u03b1] [topological_space \u03b2] {a b : \u03b1}\n\t{f : \u03b1 \u2192 \u03b2} (h : a < b) :\n\t(continuous_within_at f (set.Ioo a b) a \u2194 continuous_within_at f (set.Ioi a) a)", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : topological_space \u03b1] [_inst_2 : linear_order \u03b1] [_inst_3 : order_closed_topology \u03b1] [_inst_5 : topological_space \u03b2] {a b : \u03b1} {f : \u03b1 \u2192 \u03b2}, a < b \u2192 (continuous_within_at f (set.Ioo a b) a \u2194 continuous_within_at f (set.Ioi a) a)", "decl_nm": "continuous_within_at_Ioo_iff_Ioi"}
{"formal_statement": "theorem punit_prod_apply (\u03b1 : Type*) (\u1fb0 : punit \u00d7 \u03b1) :\n\t\u21d1(equiv.punit_prod \u03b1) \u1fb0 = \u1fb0.snd", "decl_tp": "\u2200 (\u03b1 : Type u_1) (\u1fb0 : punit \u00d7 \u03b1), \u21d1(equiv.punit_prod \u03b1) \u1fb0 = \u1fb0.snd", "decl_nm": "equiv.punit_prod_apply"}
{"formal_statement": "theorem ae_tendsto_lim_ratio_meas {\u03b1 : Type*} [metric_space \u03b1] {m0 : measurable_space \u03b1}\n\t{\u03bc : measure_theory.measure \u03b1} (v : vitali_family \u03bc) [sigma_compact_space \u03b1]\n\t[borel_space \u03b1] [measure_theory.is_locally_finite_measure \u03bc] {\u03c1 : measure_theory.measure \u03b1}\n\t[measure_theory.is_locally_finite_measure \u03c1] (h\u03c1 : \u03c1.absolutely_continuous \u03bc) :\n\t\u2200\u1d50 (x : \u03b1) \u2202\u03bc, filter.tendsto (\u03bb (a : set \u03b1), \u21d1\u03c1 a / \u21d1\u03bc a) (v.filter_at x)\n\t(nhds (v.lim_ratio_meas h\u03c1 x))", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : metric_space \u03b1] {m0 : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} (v : vitali_family \u03bc) [_inst_2 : sigma_compact_space \u03b1] [_inst_3 : borel_space \u03b1] [_inst_4 : measure_theory.is_locally_finite_measure \u03bc] {\u03c1 : measure_theory.measure \u03b1} [_inst_5 : measure_theory.is_locally_finite_measure \u03c1] (h\u03c1 : \u03c1.absolutely_continuous \u03bc), \u2200\u1d50 (x : \u03b1) \u2202\u03bc, filter.tendsto (\u03bb (a : set \u03b1), \u21d1\u03c1 a / \u21d1\u03bc a) (v.filter_at x) (nhds (v.lim_ratio_meas h\u03c1 x))", "decl_nm": "vitali_family.ae_tendsto_lim_ratio_meas"}
{"formal_statement": "theorem lcm_comm (i j : \u2124) :\n\ti.lcm j = j.lcm i", "decl_tp": "\u2200 (i j : \u2124), i.lcm j = j.lcm i", "decl_nm": "int.lcm_comm"}
{"formal_statement": "theorem cons_val_zero {\u03b1 : Type u} {m : \u2115} (x : \u03b1) (u : fin m \u2192 \u03b1) :\n\tmatrix.vec_cons x u 0 = x", "decl_tp": "\u2200 {\u03b1 : Type u} {m : \u2115} (x : \u03b1) (u : fin m \u2192 \u03b1), matrix.vec_cons x u 0 = x", "decl_nm": "matrix.cons_val_zero"}
{"formal_statement": "theorem noncomm_sum_empty {\u03b1 : Type*} [add_monoid \u03b1] (h : \u2200 (x : \u03b1), x \u2208 0 \u2192 \u2200 (y : \u03b1), y \u2208 0 \u2192 add_commute x y) :\n\t0.noncomm_sum h = 0", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : add_monoid \u03b1] (h : \u2200 (x : \u03b1), x \u2208 0 \u2192 \u2200 (y : \u03b1), y \u2208 0 \u2192 add_commute x y), 0.noncomm_sum h = 0", "decl_nm": "multiset.noncomm_sum_empty"}
{"formal_statement": "theorem map_le_sub {R \u0393\u2080 : Type*} [linear_ordered_add_comm_group_with_top \u0393\u2080]\n\t[ring R] (v : add_valuation R \u0393\u2080) {x y : R} {g : \u0393\u2080} (hx : g \u2264 \u21d1v x) (hy : g \u2264 \u21d1v y) :\n\tg \u2264 \u21d1v (x - y)", "decl_tp": "\u2200 {R : Type u_1} {\u0393\u2080 : Type u_2} [_inst_1 : linear_ordered_add_comm_group_with_top \u0393\u2080] [_inst_2 : ring R] (v : add_valuation R \u0393\u2080) {x y : R} {g : \u0393\u2080}, g \u2264 \u21d1v x \u2192 g \u2264 \u21d1v y \u2192 g \u2264 \u21d1v (x - y)", "decl_nm": "add_valuation.map_le_sub"}
{"formal_statement": "theorem minimal_period_eq_prime_pow {\u03b1 : Type*} {f : \u03b1 \u2192 \u03b1} {x : \u03b1} {p k : \u2115}\n\t[hp : fact (nat.prime p)] (hk : \u00acfunction.is_periodic_pt f (p ^ k) x)\n\t(hk1 : function.is_periodic_pt f (p ^ (k + 1)) x) :\n\tfunction.minimal_period f x = p ^ (k + 1)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {f : \u03b1 \u2192 \u03b1} {x : \u03b1} {p k : \u2115} [hp : fact (nat.prime p)], \u00acfunction.is_periodic_pt f (p ^ k) x \u2192 function.is_periodic_pt f (p ^ (k + 1)) x \u2192 function.minimal_period f x = p ^ (k + 1)", "decl_nm": "function.minimal_period_eq_prime_pow"}
{"formal_statement": "theorem coe_fn_monoid_hom_apply {X Y : Type*} [topological_space X] [mul_one_class Y]\n\t(x : locally_constant X Y) (\u1fb0 : X) :\n\t\u21d1locally_constant.coe_fn_monoid_hom x \u1fb0 = \u21d1x \u1fb0", "decl_tp": "\u2200 {X : Type u_1} {Y : Type u_2} [_inst_1 : topological_space X] [_inst_2 : mul_one_class Y] (x : locally_constant X Y) (\u1fb0 : X), \u21d1locally_constant.coe_fn_monoid_hom x \u1fb0 = \u21d1x \u1fb0", "decl_nm": "locally_constant.coe_fn_monoid_hom_apply"}
{"formal_statement": "theorem mul_indicator_eq_self_of_superset {\u03b1 M : Type*} [has_one M] {s t : set \u03b1}\n\t{f : \u03b1 \u2192 M} (h1 : s.mul_indicator f = f) (h2 : s \u2286 t) :\n\tt.mul_indicator f = f", "decl_tp": "\u2200 {\u03b1 : Type u_1} {M : Type u_4} [_inst_1 : has_one M] {s t : set \u03b1} {f : \u03b1 \u2192 M}, s.mul_indicator f = f \u2192 s \u2286 t \u2192 t.mul_indicator f = f", "decl_nm": "set.mul_indicator_eq_self_of_superset"}
{"formal_statement": "theorem dual_node3_r {\u03b1 : Type*} (l : ordnode \u03b1) (x : \u03b1) (m : ordnode \u03b1)\n\t(y : \u03b1) (r : ordnode \u03b1) :\n\t(l.node3_r x m y r).dual = r.dual.node3_l y m.dual x l.dual", "decl_tp": "\u2200 {\u03b1 : Type u_1} (l : ordnode \u03b1) (x : \u03b1) (m : ordnode \u03b1) (y : \u03b1) (r : ordnode \u03b1), (l.node3_r x m y r).dual = r.dual.node3_l y m.dual x l.dual", "decl_nm": "ordnode.dual_node3_r"}
{"formal_statement": "theorem has_finite_coproducts_of_has_coproducts (C : Type u) [category_theory.category C]\n\t[category_theory.limits.has_coproducts C] :\n\tcategory_theory.limits.has_finite_coproducts C", "decl_tp": "\u2200 (C : Type u) [_inst_1 : category_theory.category C] [_inst_2 : category_theory.limits.has_coproducts C], category_theory.limits.has_finite_coproducts C", "decl_nm": "category_theory.limits.has_finite_coproducts_of_has_coproducts"}
{"formal_statement": "theorem mk_of_lt {M : Type*} [comm_monoid M] {k : \u2115} (\u03b6 : M) (hk : 0 < k)\n\t(h1 : \u03b6 ^ k = 1) :\n\t(\u2200 (l : \u2115), 0 < l \u2192 l < k \u2192 \u03b6 ^ l \u2260 1) \u2192 is_primitive_root \u03b6 k", "decl_tp": "\u2200 {M : Type u_1} [_inst_1 : comm_monoid M] {k : \u2115} (\u03b6 : M), 0 < k \u2192 \u03b6 ^ k = 1 \u2192 (\u2200 (l : \u2115), 0 < l \u2192 l < k \u2192 \u03b6 ^ l \u2260 1) \u2192 is_primitive_root \u03b6 k", "decl_nm": "is_primitive_root.mk_of_lt"}
{"formal_statement": "theorem flip_obj_X_d {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V]\n\t{\u03b9 : Type*} {c : complex_shape \u03b9} {\u03b9' : Type*} {c' : complex_shape \u03b9'}\n\t(C : homological_complex (homological_complex V c) c') (i : \u03b9) (j j' : \u03b9') :\n\t(C.flip_obj.X i).d j j' = (C.d j j').f i", "decl_tp": "\u2200 {V : Type u} [_inst_1 : category_theory.category V] [_inst_2 : category_theory.limits.has_zero_morphisms V] {\u03b9 : Type u_1} {c : complex_shape \u03b9} {\u03b9' : Type u_2} {c' : complex_shape \u03b9'} (C : homological_complex (homological_complex V c) c') (i : \u03b9) (j j' : \u03b9'), (C.flip_obj.X i).d j j' = (C.d j j').f i", "decl_nm": "homological_complex.flip_obj_X_d"}
{"formal_statement": "theorem seq_mem_seq {\u03b1 : Type u} {\u03b2 : Type v} {f : filter (\u03b1 \u2192 \u03b2)} {g : filter \u03b1}\n\t{s : set (\u03b1 \u2192 \u03b2)} {t : set \u03b1} (hs : s \u2208 f) (ht : t \u2208 g) :\n\ts.seq t \u2208 f.seq g", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {f : filter (\u03b1 \u2192 \u03b2)} {g : filter \u03b1} {s : set (\u03b1 \u2192 \u03b2)} {t : set \u03b1}, s \u2208 f \u2192 t \u2208 g \u2192 s.seq t \u2208 f.seq g", "decl_nm": "filter.seq_mem_seq"}
{"formal_statement": "theorem ite {\u03b1 \u03c3 : Type*} [primcodable \u03b1] [primcodable \u03c3] {c : \u03b1 \u2192 Prop}\n\t[decidable_pred c] {f g : \u03b1 \u2192 \u03c3} (hc : primrec_pred c) (hf : primrec f)\n\t(hg : primrec g) :\n\tprimrec (\u03bb (a : \u03b1), ite (c a) (f a) (g a))", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03c3 : Type u_5} [_inst_1 : primcodable \u03b1] [_inst_5 : primcodable \u03c3] {c : \u03b1 \u2192 Prop} [_inst_6 : decidable_pred c] {f g : \u03b1 \u2192 \u03c3}, primrec_pred c \u2192 primrec f \u2192 primrec g \u2192 primrec (\u03bb (a : \u03b1), ite (c a) (f a) (g a))", "decl_nm": "primrec.ite"}
{"formal_statement": "theorem of_measurable_inverse_on_range {\u03b1 \u03b2 : Type*} [measurable_space \u03b1]\n\t[measurable_space \u03b2] {f : \u03b1 \u2192 \u03b2} {g : \u21a5(set.range f) \u2192 \u03b1} (hf\u2081 : measurable f)\n\t(hf\u2082 : measurable_set (set.range f)) (hg : measurable g) (H : function.left_inverse g (set.range_factorization f)) :\n\tmeasurable_embedding f", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : measurable_space \u03b1] [_inst_2 : measurable_space \u03b2] {f : \u03b1 \u2192 \u03b2} {g : \u21a5(set.range f) \u2192 \u03b1}, measurable f \u2192 measurable_set (set.range f) \u2192 measurable g \u2192 function.left_inverse g (set.range_factorization f) \u2192 measurable_embedding f", "decl_nm": "measurable_embedding.of_measurable_inverse_on_range"}
{"formal_statement": "theorem ceil_lt_add_one {\u03b1 : Type*} [linear_ordered_ring \u03b1] [floor_semiring \u03b1]\n\t{a : \u03b1} (ha : 0 \u2264 a) :\n\t\u2191\u2308a\u2309\u208a < a + 1", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : linear_ordered_ring \u03b1] [_inst_2 : floor_semiring \u03b1] {a : \u03b1}, 0 \u2264 a \u2192 \u2191\u2308a\u2309\u208a < a + 1", "decl_nm": "nat.ceil_lt_add_one"}
{"formal_statement": "theorem inner_products_summable {\ud835\udd5c E : Type*} [is_R_or_C \ud835\udd5c] [inner_product_space \ud835\udd5c E]\n\t{\u03b9 : Type*} (x : E) {v : \u03b9 \u2192 E} (hv : orthonormal \ud835\udd5c v) :\n\tsummable (\u03bb (i : \u03b9), \u2225has_inner.inner (v i) x\u2225 ^ 2)", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} {E : Type u_2} [_inst_1 : is_R_or_C \ud835\udd5c] [_inst_2 : inner_product_space \ud835\udd5c E] {\u03b9 : Type u_4} (x : E) {v : \u03b9 \u2192 E}, orthonormal \ud835\udd5c v \u2192 summable (\u03bb (i : \u03b9), \u2225has_inner.inner (v i) x\u2225 ^ 2)", "decl_nm": "orthonormal.inner_products_summable"}
{"formal_statement": "theorem inf_bot_eq {\u03b1 : Type u} [semilattice_inf \u03b1] [order_bot \u03b1] {a : \u03b1} :\n\ta \u2293 \u22a5 = \u22a5", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : semilattice_inf \u03b1] [_inst_2 : order_bot \u03b1] {a : \u03b1}, a \u2293 \u22a5 = \u22a5", "decl_nm": "inf_bot_eq"}
{"formal_statement": "theorem div_mul_cancel_of_imp {G\u2080 : Type*} [group_with_zero G\u2080] {a b : G\u2080}\n\t(hb : b = 0) :\n\t( a = 0) \u2192 a / b * b = a", "decl_tp": "\u2200 {G\u2080 : Type u_2} [_inst_1 : group_with_zero G\u2080] {a b : G\u2080}, (b = 0 \u2192 a = 0) \u2192 a / b * b = a", "decl_nm": "div_mul_cancel_of_imp"}
{"formal_statement": "theorem sub_coeff {p : \u2115} {R : Type*} [hp : fact (nat.prime p)] [comm_ring R]\n\t(x y : witt_vector p R) (n : \u2115) :\n\t(x - y).coeff n = witt_vector.peval (witt_vector.witt_sub p n) ![x.coeff, y.coeff]", "decl_tp": "\u2200 {p : \u2115} {R : Type u_1} [hp : fact (nat.prime p)] [_inst_1 : comm_ring R] (x y : witt_vector p R) (n : \u2115), (x - y).coeff n = witt_vector.peval (witt_vector.witt_sub p n) ![x.coeff, y.coeff]", "decl_nm": "witt_vector.sub_coeff"}
{"formal_statement": "theorem zero_vadd (M : Type*) {\u03b1 : Type*} [add_monoid M] [add_action M \u03b1]\n\t(b : \u03b1) :\n\t0 +\u1d65 b = b", "decl_tp": "\u2200 (M : Type u_1) {\u03b1 : Type u_6} [_inst_1 : add_monoid M] [_inst_2 : add_action M \u03b1] (b : \u03b1), 0 +\u1d65 b = b", "decl_nm": "zero_vadd"}
{"formal_statement": "theorem card_eq_card_quotient_mul_card_subgroup {\u03b1 : Type*} [group \u03b1] [fintype \u03b1]\n\t(s : subgroup \u03b1) [fintype \u21a5s] [decidable_pred (\u03bb (a : \u03b1), a \u2208 s)] :\n\tfintype.card \u03b1 = fintype.card (\u03b1 \u29f8 s) * fintype.card \u21a5s", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : group \u03b1] [_inst_2 : fintype \u03b1] (s : subgroup \u03b1) [_inst_3 : fintype \u21a5s] [_inst_4 : decidable_pred (\u03bb (a : \u03b1), a \u2208 s)], fintype.card \u03b1 = fintype.card (\u03b1 \u29f8 s) * fintype.card \u21a5s", "decl_nm": "subgroup.card_eq_card_quotient_mul_card_subgroup"}
{"formal_statement": "theorem iff_symm_preimage_eq {\u03b1 \u03b2 : Type*} {e : local_equiv \u03b1 \u03b2} {s : set \u03b1}\n\t{t : set \u03b2} :\n\te.is_image s t \u2194 e.target \u2229 \u21d1(e.symm) \u207b\u00b9' s = e.target \u2229 t", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {e : local_equiv \u03b1 \u03b2} {s : set \u03b1} {t : set \u03b2}, e.is_image s t \u2194 e.target \u2229 \u21d1(e.symm) \u207b\u00b9' s = e.target \u2229 t", "decl_nm": "local_equiv.is_image.iff_symm_preimage_eq"}
{"formal_statement": "theorem admissible_A' (q r : \u2115+) :\n\tADE_inequality.admissible (ADE_inequality.A' q r)", "decl_tp": "\u2200 (q r : \u2115+), ADE_inequality.admissible (ADE_inequality.A' q r)", "decl_nm": "ADE_inequality.admissible_A'"}
{"formal_statement": "theorem comap_inf {M N : Type*} [add_zero_class M] [add_zero_class N] (S T : add_submonoid N)\n\t(f : M \u2192+ N) :\n\tadd_submonoid.comap f (S \u2293 T) = add_submonoid.comap f S \u2293 add_submonoid.comap f T", "decl_tp": "\u2200 {M : Type u_1} {N : Type u_2} [_inst_1 : add_zero_class M] [_inst_2 : add_zero_class N] (S T : add_submonoid N) (f : M \u2192+ N), add_submonoid.comap f (S \u2293 T) = add_submonoid.comap f S \u2293 add_submonoid.comap f T", "decl_nm": "add_submonoid.comap_inf"}
{"formal_statement": "theorem lift_comp {M : Type*} [comm_monoid M] {N : Type*} [comm_monoid N]\n\t{P : Type*} [comm_monoid P] {g : M \u2192* P} (x : M) (F : submonoid.localization_map.away_map x N)\n\t(hg : is_unit (\u21d1g x)) :\n\t(submonoid.localization_map.away_map.lift x F hg).comp (submonoid.localization_map.to_map F) = g", "decl_tp": "\u2200 {M : Type u_1} [_inst_1 : comm_monoid M] {N : Type u_2} [_inst_2 : comm_monoid N] {P : Type u_3} [_inst_3 : comm_monoid P] {g : M \u2192* P} (x : M) (F : submonoid.localization_map.away_map x N) (hg : is_unit (\u21d1g x)), (submonoid.localization_map.away_map.lift x F hg).comp (submonoid.localization_map.to_map F) = g", "decl_nm": "submonoid.localization_map.away_map.lift_comp"}
{"formal_statement": "theorem reflexive_many_one_reducible {\u03b1 : Type*} [primcodable \u03b1] :\n\treflexive many_one_reducible", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : primcodable \u03b1], reflexive many_one_reducible", "decl_nm": "reflexive_many_one_reducible"}
{"formal_statement": "theorem coe_add {M : Type*} [has_add M] {c : add_con M} (x y : M) :\n\t\u2191(x + y) = \u2191x + \u2191y", "decl_tp": "\u2200 {M : Type u_1} [_inst_1 : has_add M] {c : add_con M} (x y : M), \u2191(x + y) = \u2191x + \u2191y", "decl_nm": "add_con.coe_add"}
{"formal_statement": "theorem div_def {R : Type u} [field R] {p q : polynomial R} :\n\tp / q = \u21d1polynomial.C (q.leading_coeff)\u207b\u00b9 * (p /\u2098 (q * \u21d1polynomial.C (q.leading_coeff)\u207b\u00b9))", "decl_tp": "\u2200 {R : Type u} [_inst_1 : field R] {p q : polynomial R}, p / q = \u21d1polynomial.C (q.leading_coeff)\u207b\u00b9 * (p /\u2098 (q * \u21d1polynomial.C (q.leading_coeff)\u207b\u00b9))", "decl_nm": "polynomial.div_def"}
{"formal_statement": "theorem one_divp {\u03b1 : Type u} [monoid \u03b1] (u : units \u03b1) :\n\t1 /\u209a u = \u2191u\u207b\u00b9", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : monoid \u03b1] (u : units \u03b1), 1 /\u209a u = \u2191u\u207b\u00b9", "decl_nm": "one_divp"}
{"formal_statement": "theorem sup_left_idem {\u03b1 : Type u} [semilattice_sup \u03b1] {a b : \u03b1} :\n\ta \u2294 (a \u2294 b) = a \u2294 b", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : semilattice_sup \u03b1] {a b : \u03b1}, a \u2294 (a \u2294 b) = a \u2294 b", "decl_nm": "sup_left_idem"}
{"formal_statement": "theorem encode {n : \u2115} :\n\tnat.primrec' encodable.encode", "decl_tp": "\u2200 {n : \u2115}, nat.primrec' encodable.encode", "decl_nm": "nat.primrec'.encode"}
{"formal_statement": "theorem exists' {\u03b1 : Sort u_1} {p : \u03b1 \u2192 Prop} {q : \u03a0 (x : \u03b1), p x \u2192 Prop} :\n\t(\u2203 (x : \u03b1) (h : p x), q x h) \u2194 \u2203 (x : {a // p a}), q \u2191x _", "decl_tp": "\u2200 {\u03b1 : Sort u_1} {p : \u03b1 \u2192 Prop} {q : \u03a0 (x : \u03b1), p x \u2192 Prop}, (\u2203 (x : \u03b1) (h : p x), q x h) \u2194 \u2203 (x : {a // p a}), q \u2191x _", "decl_nm": "subtype.exists'"}
{"formal_statement": "theorem subgroup_topological_closure {G : Type w} [topological_space G]\n\t[group G] [topological_group G] (s : subgroup G) :\n\ts \u2264 s.topological_closure", "decl_tp": "\u2200 {G : Type w} [_inst_1 : topological_space G] [_inst_2 : group G] [_inst_3 : topological_group G] (s : subgroup G), s \u2264 s.topological_closure", "decl_nm": "subgroup.subgroup_topological_closure"}
{"formal_statement": "theorem pow_card {p : \u2115} [fact (nat.prime p)] (x : zmod p) :\n\tx ^ p = x", "decl_tp": "\u2200 {p : \u2115} [_inst_1 : fact (nat.prime p)] (x : zmod p), x ^ p = x", "decl_nm": "zmod.pow_card"}
{"formal_statement": "theorem mem_closure {G : Type*} [add_group G] {k : set G} {x : G} :\n\tx \u2208 add_subgroup.closure k \u2194 \u2200 (K : add_subgroup G), k \u2286 \u2191K \u2192 x \u2208 K", "decl_tp": "\u2200 {G : Type u_1} [_inst_1 : add_group G] {k : set G} {x : G}, x \u2208 add_subgroup.closure k \u2194 \u2200 (K : add_subgroup G), k \u2286 \u2191K \u2192 x \u2208 K", "decl_nm": "add_subgroup.mem_closure"}
{"formal_statement": "theorem index_mul_card {G : Type*} [add_group G] (H : add_subgroup G) [fintype G]\n\t[hH : fintype \u21a5H] :\n\tH.index * fintype.card \u21a5H = fintype.card G", "decl_tp": "\u2200 {G : Type u_1} [_inst_1 : add_group G] (H : add_subgroup G) [_inst_2 : fintype G] [hH : fintype \u21a5H], H.index * fintype.card \u21a5H = fintype.card G", "decl_nm": "add_subgroup.index_mul_card"}
{"formal_statement": "theorem val_eq_coe {\u03b1 : Sort u_1} {p : \u03b1 \u2192 Prop} {x : subtype p} :\n\tx.val = \u2191x", "decl_tp": "\u2200 {\u03b1 : Sort u_1} {p : \u03b1 \u2192 Prop} {x : subtype p}, x.val = \u2191x", "decl_nm": "subtype.val_eq_coe"}
{"formal_statement": "theorem strict_convex_on_univ_of_deriv2_pos {f : \u211d \u2192 \u211d} (hf' : differentiable \u211d f) :\n\t(\u2200 (x : \u211d), 0 < deriv^[2] f x) \u2192 strict_convex_on \u211d set.univ f", "decl_tp": "\u2200 {f : \u211d \u2192 \u211d}, differentiable \u211d f \u2192 (\u2200 (x : \u211d), 0 < deriv^[2] f x) \u2192 strict_convex_on \u211d set.univ f", "decl_nm": "strict_convex_on_univ_of_deriv2_pos"}
{"formal_statement": "theorem coe_mk {R : Type*} [comm_ring R] {S : submonoid R} {P : Type*}\n\t[comm_ring P] [algebra R P] (I : submodule R P) (hI : is_fractional S I) :\n\t\u2191\u27e8I, hI\u27e9 = I", "decl_tp": "\u2200 {R : Type u_1} [_inst_1 : comm_ring R] {S : submonoid R} {P : Type u_2} [_inst_2 : comm_ring P] [_inst_3 : algebra R P] (I : submodule R P) (hI : is_fractional S I), \u2191\u27e8I, hI\u27e9 = I", "decl_nm": "fractional_ideal.coe_mk"}
{"formal_statement": "theorem rotate_one_eq_self_iff_eq_repeat {\u03b1 : Type*} [nonempty \u03b1] {l : list \u03b1} :\n\tl.rotate 1 = l \u2194 \u2203 (a : \u03b1), l = list.repeat a l.length", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : nonempty \u03b1] {l : list \u03b1}, l.rotate 1 = l \u2194 \u2203 (a : \u03b1), l = list.repeat a l.length", "decl_nm": "list.rotate_one_eq_self_iff_eq_repeat"}
{"formal_statement": "theorem finite_colimit_eq_finset_univ_sup {\u03b1 J : Type u} [category_theory.small_category J]\n\t[category_theory.fin_category J] [semilattice_sup \u03b1] [order_bot \u03b1] (F : J \u2964 \u03b1) :\n\tcategory_theory.limits.colimit F = finset.univ.sup F.obj", "decl_tp": "\u2200 {\u03b1 J : Type u} [_inst_1 : category_theory.small_category J] [_inst_2 : category_theory.fin_category J] [_inst_3 : semilattice_sup \u03b1] [_inst_4 : order_bot \u03b1] (F : J \u2964 \u03b1), category_theory.limits.colimit F = finset.univ.sup F.obj", "decl_nm": "category_theory.limits.complete_lattice.finite_colimit_eq_finset_univ_sup"}
{"formal_statement": "theorem exists_pempty {P : pempty \u2192 Prop} :\n\t(\u2203 (x : pempty), P x) \u2194 false", "decl_tp": "\u2200 {P : pempty \u2192 Prop}, (\u2203 (x : pempty), P x) \u2194 false", "decl_nm": "exists_pempty"}
{"formal_statement": "theorem zneg_to_znum_neg (n : num) :\n\t-n.to_znum_neg = n.to_znum", "decl_tp": "\u2200 (n : num), -n.to_znum_neg = n.to_znum", "decl_nm": "num.zneg_to_znum_neg"}
{"formal_statement": "theorem le_of_sub_nonpos {\u03b1 : Type u} [add_group \u03b1] [has_le \u03b1] [covariant_class \u03b1 \u03b1 (function.swap has_add.add) has_le.le]\n\t{a b : \u03b1} :\n\ta - b \u2264 0 \u2192 a \u2264 b", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : add_group \u03b1] [_inst_2 : has_le \u03b1] [_inst_3 : covariant_class \u03b1 \u03b1 (function.swap has_add.add) has_le.le] {a b : \u03b1}, a - b \u2264 0 \u2192 a \u2264 b", "decl_nm": "le_of_sub_nonpos"}
{"formal_statement": "theorem Ico_cons_right {\u03b1 : Type*} [partial_order \u03b1] [locally_finite_order \u03b1]\n\t{a b : \u03b1} (h : a \u2264 b) :\n\tb ::\u2098 multiset.Ico a b = multiset.Icc a b", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : partial_order \u03b1] [_inst_2 : locally_finite_order \u03b1] {a b : \u03b1}, a \u2264 b \u2192 b ::\u2098 multiset.Ico a b = multiset.Icc a b", "decl_nm": "multiset.Ico_cons_right"}
{"formal_statement": "theorem generate_from_sUnion {\u03b1 : Type u} {S : set (set (set \u03b1))} :\n\ttopological_space.generate_from (\u22c3\u2080 S) = \u2a05 (s : set (set \u03b1)) (H : s \u2208 S), topological_space.generate_from s", "decl_tp": "\u2200 {\u03b1 : Type u} {S : set (set (set \u03b1))}, topological_space.generate_from (\u22c3\u2080 S) = \u2a05 (s : set (set \u03b1)) (H : s \u2208 S), topological_space.generate_from s", "decl_nm": "generate_from_sUnion"}
{"formal_statement": "theorem times_cont_diff_within_at {E : Type*} [inner_product_space \u211d E]\n\t{c : E} (f : times_cont_diff_bump_of_inner c) {x : E} {s : set E} {n : with_top \u2115} :\n\ttimes_cont_diff_within_at \u211d n \u21d1f s x", "decl_tp": "\u2200 {E : Type u_1} [_inst_1 : inner_product_space \u211d E] {c : E} (f : times_cont_diff_bump_of_inner c) {x : E} {s : set E} {n : with_top \u2115}, times_cont_diff_within_at \u211d n \u21d1f s x", "decl_nm": "times_cont_diff_bump_of_inner.times_cont_diff_within_at"}
{"formal_statement": "theorem length_le_length_insert_nth {\u03b1 : Type u} (l : list \u03b1) (x : \u03b1) (n : \u2115) :\n\tl.length \u2264 (list.insert_nth n x l).length", "decl_tp": "\u2200 {\u03b1 : Type u} (l : list \u03b1) (x : \u03b1) (n : \u2115), l.length \u2264 (list.insert_nth n x l).length", "decl_nm": "list.length_le_length_insert_nth"}
{"formal_statement": "theorem lift_prop_at_chart {H M : Type*} [topological_space H] [topological_space M]\n\t[charted_space H M] {G : structure_groupoid H} {x : M} {Q : (H \u2192 H) \u2192 set H \u2192 H \u2192 Prop}\n\t[has_groupoid M G] (hG : G.local_invariant_prop G Q) :\n\t(\u2200 (y : H), Q id set.univ y) \u2192 charted_space.lift_prop_at Q \u21d1(charted_space.chart_at H x) x", "decl_tp": "\u2200 {H : Type u_1} {M : Type u_2} [_inst_1 : topological_space H] [_inst_2 : topological_space M] [_inst_3 : charted_space H M] {G : structure_groupoid H} {x : M} {Q : (H \u2192 H) \u2192 set H \u2192 H \u2192 Prop} [_inst_7 : has_groupoid M G], G.local_invariant_prop G Q \u2192 (\u2200 (y : H), Q id set.univ y) \u2192 charted_space.lift_prop_at Q \u21d1(charted_space.chart_at H x) x", "decl_nm": "structure_groupoid.local_invariant_prop.lift_prop_at_chart"}
{"formal_statement": "theorem odd_eq {\u03b1 : Type u} (s : stream \u03b1) :\n\ts.odd = s.tail.even", "decl_tp": "\u2200 {\u03b1 : Type u} (s : stream \u03b1), s.odd = s.tail.even", "decl_nm": "stream.odd_eq"}
{"formal_statement": "theorem tr_stmts\u2081_self (q : turing.partrec_to_TM2.\u039b') :\n\tq \u2208 turing.partrec_to_TM2.tr_stmts\u2081 q", "decl_tp": "\u2200 (q : turing.partrec_to_TM2.\u039b'), q \u2208 turing.partrec_to_TM2.tr_stmts\u2081 q", "decl_nm": "turing.partrec_to_TM2.tr_stmts\u2081_self"}
{"formal_statement": "theorem closed_ball_pi {\u03b2 : Type v} {\u03c0 : \u03b2 \u2192 Type*} [fintype \u03b2] [\u03a0 (b : \u03b2), pseudo_metric_space (\u03c0 b)]\n\t(x : \u03a0 (b : \u03b2), \u03c0 b) {r : \u211d} (hr : 0 \u2264 r) :\n\tmetric.closed_ball x r = set.univ.pi (\u03bb (b : \u03b2), metric.closed_ball (x b) r)", "decl_tp": "\u2200 {\u03b2 : Type v} {\u03c0 : \u03b2 \u2192 Type u_1} [_inst_2 : fintype \u03b2] [_inst_3 : \u03a0 (b : \u03b2), pseudo_metric_space (\u03c0 b)] (x : \u03a0 (b : \u03b2), \u03c0 b) {r : \u211d}, 0 \u2264 r \u2192 metric.closed_ball x r = set.univ.pi (\u03bb (b : \u03b2), metric.closed_ball (x b) r)", "decl_nm": "closed_ball_pi"}
{"formal_statement": "theorem comp_f {\u03b9 : Type*} {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V]\n\t{c : complex_shape \u03b9} {C\u2081 C\u2082 C\u2083 : homological_complex V c} (f : C\u2081 \u27f6 C\u2082)\n\t(g : C\u2082 \u27f6 C\u2083) (i : \u03b9) :\n\t(f \u226b g).f i = f.f i \u226b g.f i", "decl_tp": "\u2200 {\u03b9 : Type u_1} {V : Type u} [_inst_1 : category_theory.category V] [_inst_2 : category_theory.limits.has_zero_morphisms V] {c : complex_shape \u03b9} {C\u2081 C\u2082 C\u2083 : homological_complex V c} (f : C\u2081 \u27f6 C\u2082) (g : C\u2082 \u27f6 C\u2083) (i : \u03b9), (f \u226b g).f i = f.f i \u226b g.f i", "decl_nm": "homological_complex.comp_f"}
{"formal_statement": "theorem closure_subset_preimage_closure_image {\u03b1 \u03b2 : Type*} [topological_space \u03b1]\n\t[topological_space \u03b2] {f : \u03b1 \u2192 \u03b2} {s : set \u03b1} (h : continuous f) :\n\tclosure s \u2286 f \u207b\u00b9' closure (f '' s)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : topological_space \u03b1] [_inst_2 : topological_space \u03b2] {f : \u03b1 \u2192 \u03b2} {s : set \u03b1}, continuous f \u2192 closure s \u2286 f \u207b\u00b9' closure (f '' s)", "decl_nm": "closure_subset_preimage_closure_image"}
{"formal_statement": "theorem coe_nat_bit0 (n : \u2115) :\n\t\u2191(bit0 n) = bit0 \u2191n", "decl_tp": "\u2200 (n : \u2115), \u2191(bit0 n) = bit0 \u2191n", "decl_nm": "linarith.int.coe_nat_bit0"}
{"formal_statement": "theorem coe_one (A : Type*) [add_zero_class A] :\n\t\u21d11 = id", "decl_tp": "\u2200 (A : Type u_7) [_inst_1 : add_zero_class A], \u21d11 = id", "decl_nm": "add_monoid.coe_one"}
{"formal_statement": "theorem closed_sieves_map_coe {C : Type u} [category_theory.category C]\n\t(J\u2081 : category_theory.grothendieck_topology C) (X Y : C\u1d52\u1d56) (f : X \u27f6 Y)\n\t(S : {S // J\u2081.is_closed S}) :\n\t\u2191((category_theory.functor.closed_sieves J\u2081).map f S) = category_theory.sieve.pullback f.unop S.val", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] (J\u2081 : category_theory.grothendieck_topology C) (X Y : C\u1d52\u1d56) (f : X \u27f6 Y) (S : {S // J\u2081.is_closed S}), \u2191((category_theory.functor.closed_sieves J\u2081).map f S) = category_theory.sieve.pullback f.unop S.val", "decl_nm": "category_theory.functor.closed_sieves_map_coe"}
{"formal_statement": "theorem is_equivalence {\u03b1 : Type*} :\n\tequivalence (sym2.rel \u03b1)", "decl_tp": "\u2200 {\u03b1 : Type u_1}, equivalence (sym2.rel \u03b1)", "decl_nm": "sym2.rel.is_equivalence"}
{"formal_statement": "theorem mem_sup_left {R : Type u} [semiring R] {S T : ideal R} {x : R} :\n\tx \u2208 S \u2192 x \u2208 S \u2294 T", "decl_tp": "\u2200 {R : Type u} [_inst_2 : semiring R] {S T : ideal R} {x : R}, x \u2208 S \u2192 x \u2208 S \u2294 T", "decl_nm": "ideal.mem_sup_left"}
{"formal_statement": "theorem pi_fin_two_apply (\u03b1 : fin 2 \u2192 Type*) [\u03a0 (i : fin 2), measurable_space (\u03b1 i)] :\n\t\u21d1(measurable_equiv.pi_fin_two \u03b1) = \u03bb (f : \u03a0 (i : fin 2), \u03b1 i), (f 0, f 1)", "decl_tp": "\u2200 (\u03b1 : fin 2 \u2192 Type u_1) [_inst_7 : \u03a0 (i : fin 2), measurable_space (\u03b1 i)], \u21d1(measurable_equiv.pi_fin_two \u03b1) = \u03bb (f : \u03a0 (i : fin 2), \u03b1 i), (f 0, f 1)", "decl_nm": "measurable_equiv.pi_fin_two_apply"}
{"formal_statement": "theorem dist_le_zero {\u03b3 : Type w} [metric_space \u03b3] {x y : \u03b3} :\n\thas_dist.dist x y \u2264 0 \u2194 x = y", "decl_tp": "\u2200 {\u03b3 : Type w} [_inst_2 : metric_space \u03b3] {x y : \u03b3}, has_dist.dist x y \u2264 0 \u2194 x = y", "decl_nm": "dist_le_zero"}
{"formal_statement": "theorem map_zero {R : Type*} [comm_ring R] {S : submonoid R} {P : Type*}\n\t[comm_ring P] [algebra R P] {P' : Type*} [comm_ring P'] [algebra R P']\n\t(g : P \u2192\u2090[R] P') :\n\tfractional_ideal.map g 0 = 0", "decl_tp": "\u2200 {R : Type u_1} [_inst_1 : comm_ring R] {S : submonoid R} {P : Type u_2} [_inst_2 : comm_ring P] [_inst_3 : algebra R P] {P' : Type u_3} [_inst_4 : comm_ring P'] [_inst_5 : algebra R P'] (g : P \u2192\u2090[R] P'), fractional_ideal.map g 0 = 0", "decl_nm": "fractional_ideal.map_zero"}
{"formal_statement": "theorem nonempty_inter_iff_exists_left {\u03b1 : Type u} {s t : set \u03b1} :\n\t(s \u2229 t).nonempty \u2194 \u2203 (x : \u21a5s), \u2191x \u2208 t", "decl_tp": "\u2200 {\u03b1 : Type u} {s t : set \u03b1}, (s \u2229 t).nonempty \u2194 \u2203 (x : \u21a5s), \u2191x \u2208 t", "decl_nm": "set.nonempty_inter_iff_exists_left"}
{"formal_statement": "theorem mem_image {\u03b1 : Type u} {\u03b2 : Type v} (f : \u03b1 \u2192 \u03b2) (s : set \u03b1) (y : \u03b2) :\n\ty \u2208 f '' s \u2194 \u2203 (x : \u03b1), x \u2208 s \u2227 f x = y", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} (f : \u03b1 \u2192 \u03b2) (s : set \u03b1) (y : \u03b2), y \u2208 f '' s \u2194 \u2203 (x : \u03b1), x \u2208 s \u2227 f x = y", "decl_nm": "set.mem_image"}
{"formal_statement": "theorem add_is_normal (a : ordinal) :\n\tordinal.is_normal (has_add.add a)", "decl_tp": "\u2200 (a : ordinal), ordinal.is_normal (has_add.add a)", "decl_nm": "ordinal.add_is_normal"}
{"formal_statement": "theorem sqrt_lt_sqrt {x y : \u211d} (hx : 0 \u2264 x) (h : x < y) :\n\treal.sqrt x < real.sqrt y", "decl_tp": "\u2200 {x y : \u211d}, 0 \u2264 x \u2192 x < y \u2192 real.sqrt x < real.sqrt y", "decl_nm": "real.sqrt_lt_sqrt"}
{"formal_statement": "theorem bdd_above_smul_iff_of_pos {k M : Type*} [linear_ordered_field k]\n\t[ordered_add_comm_group M] [mul_action_with_zero k M] [ordered_smul k M]\n\t{s : set M} {c : k} (hc : 0 < c) :\n\t(bdd_above (c \u2022 s) \u2194 bdd_above s)", "decl_tp": "\u2200 {k : Type u_1} {M : Type u_2} [_inst_1 : linear_ordered_field k] [_inst_2 : ordered_add_comm_group M] [_inst_3 : mul_action_with_zero k M] [_inst_4 : ordered_smul k M] {s : set M} {c : k}, 0 < c \u2192 (bdd_above (c \u2022 s) \u2194 bdd_above s)", "decl_nm": "bdd_above_smul_iff_of_pos"}
{"formal_statement": "theorem exists_measurable_superset {\u03b1 : Type*} [measurable_space \u03b1] (\u03bc : measure_theory.measure \u03b1)\n\t(s : set \u03b1) :\n\t\u2203 (t : set \u03b1), s \u2286 t \u2227 measurable_set t \u2227 \u21d1\u03bc t = \u21d1\u03bc s", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : measurable_space \u03b1] (\u03bc : measure_theory.measure \u03b1) (s : set \u03b1), \u2203 (t : set \u03b1), s \u2286 t \u2227 measurable_set t \u2227 \u21d1\u03bc t = \u21d1\u03bc s", "decl_nm": "measure_theory.exists_measurable_superset"}
{"formal_statement": "theorem translate_inv_apply (x y : \u211d) :\n\t\u21d1(\u21d1circle_deg1_lift.translate (\u21d1multiplicative.of_add x))\u207b\u00b9 y = -x + y", "decl_tp": "\u2200 (x y : \u211d), \u21d1(\u21d1circle_deg1_lift.translate (\u21d1multiplicative.of_add x))\u207b\u00b9 y = -x + y", "decl_nm": "circle_deg1_lift.translate_inv_apply"}
{"formal_statement": "theorem lintegral_mul_eq_zero_of_lintegral_rpow_eq_zero {\u03b1 : Type*} [measurable_space \u03b1]\n\t{\u03bc : measure_theory.measure \u03b1} {p : \u211d} (hp0_lt : 0 < p) (hf : ae_measurable f \u03bc)\n\t(hf_zero : \u222b\u207b (a : \u03b1), f a ^ p \u2202\u03bc = 0) :\n\t\u2200 {f g : \u03b1 \u2192 ennreal},   \u222b\u207b (a : \u03b1), (f * g) a \u2202\u03bc = 0", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : measurable_space \u03b1] {\u03bc : measure_theory.measure \u03b1} {p : \u211d}, 0 < p \u2192 \u2200 {f g : \u03b1 \u2192 ennreal}, ae_measurable f \u03bc \u2192 \u222b\u207b (a : \u03b1), f a ^ p \u2202\u03bc = 0 \u2192 \u222b\u207b (a : \u03b1), (f * g) a \u2202\u03bc = 0", "decl_nm": "ennreal.lintegral_mul_eq_zero_of_lintegral_rpow_eq_zero"}
{"formal_statement": "theorem rel_eq {\u03b1 : Type*} {s t : multiset \u03b1} :\n\tmultiset.rel eq s t \u2194 s = t", "decl_tp": "\u2200 {\u03b1 : Type u_1} {s t : multiset \u03b1}, multiset.rel eq s t \u2194 s = t", "decl_nm": "multiset.rel_eq"}
{"formal_statement": "theorem pow_right {m k : \u2115} (n : \u2115) (H1 : k.coprime m) :\n\tk.coprime (m ^ n)", "decl_tp": "\u2200 {m k : \u2115} (n : \u2115), k.coprime m \u2192 k.coprime (m ^ n)", "decl_nm": "nat.coprime.pow_right"}
{"formal_statement": "theorem line_map_same {k V1 P1 : Type*} [ring k] [add_comm_group V1] [module k V1]\n\t[add_torsor V1 P1] (p : P1) :\n\taffine_map.line_map p p = affine_map.const k k p", "decl_tp": "\u2200 {k : Type u_1} {V1 : Type u_2} {P1 : Type u_3} [_inst_1 : ring k] [_inst_2 : add_comm_group V1] [_inst_3 : module k V1] [_inst_4 : add_torsor V1 P1] (p : P1), affine_map.line_map p p = affine_map.const k k p", "decl_nm": "affine_map.line_map_same"}
{"formal_statement": "theorem inv\u2080 {\u03b1 G\u2080 : Type*} [has_zero G\u2080] [has_inv G\u2080] [topological_space G\u2080]\n\t[has_continuous_inv\u2080 G\u2080] {l : filter \u03b1} {f : \u03b1 \u2192 G\u2080} {a : G\u2080} (hf : filter.tendsto f l (nhds a))\n\t(ha : a \u2260 0) :\n\tfilter.tendsto (\u03bb (x : \u03b1), (f x)\u207b\u00b9) l (nhds a\u207b\u00b9)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {G\u2080 : Type u_3} [_inst_1 : has_zero G\u2080] [_inst_2 : has_inv G\u2080] [_inst_3 : topological_space G\u2080] [_inst_4 : has_continuous_inv\u2080 G\u2080] {l : filter \u03b1} {f : \u03b1 \u2192 G\u2080} {a : G\u2080}, filter.tendsto f l (nhds a) \u2192 a \u2260 0 \u2192 filter.tendsto (\u03bb (x : \u03b1), (f x)\u207b\u00b9) l (nhds a\u207b\u00b9)", "decl_nm": "filter.tendsto.inv\u2080"}
{"formal_statement": "theorem tail' {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1} (hab : relation.refl_trans_gen r a b)\n\t(hbc : r b c) :\n\trelation.trans_gen r a c", "decl_tp": "\u2200 {\u03b1 : Type u_1} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}, relation.refl_trans_gen r a b \u2192 r b c \u2192 relation.trans_gen r a c", "decl_nm": "relation.trans_gen.tail'"}
{"formal_statement": "theorem zero_completion {G : Type*} [semi_normed_group G] {H : Type*} [semi_normed_group H] :\n\t0.completion = 0", "decl_tp": "\u2200 {G : Type u_1} [_inst_1 : semi_normed_group G] {H : Type u_2} [_inst_2 : semi_normed_group H], 0.completion = 0", "decl_nm": "normed_group_hom.zero_completion"}
{"formal_statement": "theorem unop_hom {C : Type u\u2081} [category_theory.category C] {D : Type u\u2082}\n\t[category_theory.category D] {F G : C\u1d52\u1d56 \u2964 D\u1d52\u1d56} (\u03b1 : F \u2245 G) :\n\t(category_theory.nat_iso.unop \u03b1).hom = category_theory.nat_trans.unop \u03b1.hom", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {D : Type u\u2082} [_inst_2 : category_theory.category D] {F G : C\u1d52\u1d56 \u2964 D\u1d52\u1d56} (\u03b1 : F \u2245 G), (category_theory.nat_iso.unop \u03b1).hom = category_theory.nat_trans.unop \u03b1.hom", "decl_nm": "category_theory.nat_iso.unop_hom"}
{"formal_statement": "theorem op_injective {\u03b1 : Type u} :\n\tfunction.injective mul_opposite.op", "decl_tp": "\u2200 {\u03b1 : Type u}, function.injective mul_opposite.op", "decl_nm": "mul_opposite.op_injective"}
{"formal_statement": "theorem norm_one (\ud835\udd5c : Type*) [normed_field \ud835\udd5c] (\ud835\udd5c' : Type*) [semi_normed_ring \ud835\udd5c']\n\t[semi_normed_algebra \ud835\udd5c \ud835\udd5c'] :\n\t\u22251\u2225 = 1", "decl_tp": "\u2200 (\ud835\udd5c : Type u_5) [_inst_1 : normed_field \ud835\udd5c] (\ud835\udd5c' : Type u_6) [_inst_2 : semi_normed_ring \ud835\udd5c'] [_inst_3 : semi_normed_algebra \ud835\udd5c \ud835\udd5c'], \u22251\u2225 = 1", "decl_nm": "normed_algebra.norm_one"}
{"formal_statement": "theorem exists_done {\u03b1 : Type} (p : parser \u03b1) [p.unfailing] (cb : char_buffer)\n\t(n : \u2115) :\n\t\u2203 (n' : \u2115) (a : \u03b1), p cb n = parse_result.done n' a", "decl_tp": "\u2200 {\u03b1 : Type} (p : parser \u03b1) [_inst_1 : p.unfailing] (cb : char_buffer) (n : \u2115), \u2203 (n' : \u2115) (a : \u03b1), p cb n = parse_result.done n' a", "decl_nm": "parser.exists_done"}
{"formal_statement": "theorem add_equiv_symm {\u03b9 : Type u} {\u03b2\u2081 : \u03b9 \u2192 Type v\u2081} {\u03b2\u2082 : \u03b9 \u2192 Type v\u2082}\n\t[\u03a0 (i : \u03b9), add_zero_class (\u03b2\u2081 i)] [\u03a0 (i : \u03b9), add_zero_class (\u03b2\u2082 i)]\n\t(e : \u03a0 (i : \u03b9), \u03b2\u2081 i \u2243+ \u03b2\u2082 i) :\n\t(dfinsupp.map_range.add_equiv e).symm = dfinsupp.map_range.add_equiv (\u03bb (i : \u03b9), (e i).symm)", "decl_tp": "\u2200 {\u03b9 : Type u} {\u03b2\u2081 : \u03b9 \u2192 Type v\u2081} {\u03b2\u2082 : \u03b9 \u2192 Type v\u2082} [_inst_2 : \u03a0 (i : \u03b9), add_zero_class (\u03b2\u2081 i)] [_inst_3 : \u03a0 (i : \u03b9), add_zero_class (\u03b2\u2082 i)] (e : \u03a0 (i : \u03b9), \u03b2\u2081 i \u2243+ \u03b2\u2082 i), (dfinsupp.map_range.add_equiv e).symm = dfinsupp.map_range.add_equiv (\u03bb (i : \u03b9), (e i).symm)", "decl_nm": "dfinsupp.map_range.add_equiv_symm"}
{"formal_statement": "theorem prop {\u03b1 : Sort u_1} {p : \u03b1 \u2192 Prop} (x : subtype p) :\n\tp \u2191x", "decl_tp": "\u2200 {\u03b1 : Sort u_1} {p : \u03b1 \u2192 Prop} (x : subtype p), p \u2191x", "decl_nm": "subtype.prop"}
{"formal_statement": "theorem nth_mk {\u0393 : Type*} [inhabited \u0393] (l : list \u0393) (n : \u2115) :\n\t(turing.list_blank.mk l).nth n = l.inth n", "decl_tp": "\u2200 {\u0393 : Type u_1} [_inst_1 : inhabited \u0393] (l : list \u0393) (n : \u2115), (turing.list_blank.mk l).nth n = l.inth n", "decl_nm": "turing.list_blank.nth_mk"}
{"formal_statement": "theorem is_st_st {x : \u211d*} (hx : x.st \u2260 0) :\n\tx.is_st x.st", "decl_tp": "\u2200 {x : \u211d*}, x.st \u2260 0 \u2192 x.is_st x.st", "decl_nm": "hyperreal.is_st_st"}
{"formal_statement": "theorem btw_refl_right {\u03b1 : Type*} [circular_order \u03b1] (a b : \u03b1) :\n\thas_btw.btw a b b", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : circular_order \u03b1] (a b : \u03b1), has_btw.btw a b b", "decl_nm": "btw_refl_right"}
{"formal_statement": "theorem cmp_to_nat (m n : num) :\n\t(m.cmp n).cases_on (\u2191m < \u2191n) (m = n) (\u2191n < \u2191m)", "decl_tp": "\u2200 (m n : num), (m.cmp n).cases_on (\u2191m < \u2191n) (m = n) (\u2191n < \u2191m)", "decl_nm": "num.cmp_to_nat"}
{"formal_statement": "theorem exists_ge {\u03b1 : Type u} [topological_space \u03b1] [linear_order \u03b1] [order_closed_topology \u03b1]\n\t[no_top_order \u03b1] {s : set \u03b1} (hs : dense s) :\n\t\u2200 (x : \u03b1), \u2203 (y : \u03b1) (H : y \u2208 s), x \u2264 y", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : topological_space \u03b1] [_inst_2 : linear_order \u03b1] [_inst_3 : order_closed_topology \u03b1] [_inst_4 : no_top_order \u03b1] {s : set \u03b1}, dense s \u2192 \u2200 (x : \u03b1), \u2203 (y : \u03b1) (H : y \u2208 s), x \u2264 y", "decl_nm": "dense.exists_ge"}
{"formal_statement": "theorem closure_operator_apply {\u03b1 \u03b2 : Type*} [partial_order \u03b1] [preorder \u03b2]\n\t{l : \u03b1 \u2192 \u03b2} {u : \u03b2 \u2192 \u03b1} (gc : galois_connection l u) (x : \u03b1) :\n\t\u21d1(gc.closure_operator) x = u (\u21d1(gc.lower_adjoint) x)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : partial_order \u03b1] [_inst_2 : preorder \u03b2] {l : \u03b1 \u2192 \u03b2} {u : \u03b2 \u2192 \u03b1} (gc : galois_connection l u) (x : \u03b1), \u21d1(gc.closure_operator) x = u (\u21d1(gc.lower_adjoint) x)", "decl_nm": "galois_connection.closure_operator_apply"}
{"formal_statement": "theorem self_comp_symm {M N : Type*} [has_add M] [has_add N] (e : M \u2243+ N) :\n\t\u21d1e \u2218 \u21d1(e.symm) = id", "decl_tp": "\u2200 {M : Type u_3} {N : Type u_4} [_inst_1 : has_add M] [_inst_2 : has_add N] (e : M \u2243+ N), \u21d1e \u2218 \u21d1(e.symm) = id", "decl_nm": "add_equiv.self_comp_symm"}
{"formal_statement": "theorem left_cancel_inv {R : Type*} [rack R] (x : R) {y y' : R} :\n\track.inv_act x y = rack.inv_act x y' \u2194 y = y'", "decl_tp": "\u2200 {R : Type u_1} [_inst_1 : rack R] (x : R) {y y' : R}, rack.inv_act x y = rack.inv_act x y' \u2194 y = y'", "decl_nm": "rack.left_cancel_inv"}
{"formal_statement": "theorem concat_append {\u03b1 : Type u} (a : \u03b1) (l\u2081 l\u2082 : list \u03b1) :\n\tl\u2081.concat a ++ l\u2082 = l\u2081 ++ a :: l\u2082", "decl_tp": "\u2200 {\u03b1 : Type u} (a : \u03b1) (l\u2081 l\u2082 : list \u03b1), l\u2081.concat a ++ l\u2082 = l\u2081 ++ a :: l\u2082", "decl_nm": "list.concat_append"}
{"formal_statement": "theorem Icc_eq {\u03b1 : Type*} [partial_order \u03b1] {a b : \u03b1} (h : a \u22d6 b) :\n\tset.Icc a b = {a, b}", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : partial_order \u03b1] {a b : \u03b1}, a \u22d6 b \u2192 set.Icc a b = {a, b}", "decl_nm": "covers.Icc_eq"}
{"formal_statement": "theorem card_range {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [decidable_pred p] [fintype \u21a5((equiv.perm.subtype_congr_hom p).range)]\n\t[fintype (equiv.perm {a // p a} \u00d7 equiv.perm {a // \u00acp a})] :\n\tfintype.card \u21a5((equiv.perm.subtype_congr_hom p).range) = fintype.card (equiv.perm {a // p a} \u00d7 equiv.perm {a // \u00acp a})", "decl_tp": "\u2200 {\u03b1 : Type u_1} (p : \u03b1 \u2192 Prop) [_inst_1 : decidable_pred p] [_inst_2 : fintype \u21a5((equiv.perm.subtype_congr_hom p).range)] [_inst_3 : fintype (equiv.perm {a // p a} \u00d7 equiv.perm {a // \u00acp a})], fintype.card \u21a5((equiv.perm.subtype_congr_hom p).range) = fintype.card (equiv.perm {a // p a} \u00d7 equiv.perm {a // \u00acp a})", "decl_nm": "equiv.perm.subtype_congr_hom.card_range"}
{"formal_statement": "theorem option_orelse {\u03b1 : Type*} [primcodable \u03b1] :\n\tprimrec\u2082 has_orelse.orelse", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : primcodable \u03b1], primrec\u2082 has_orelse.orelse", "decl_nm": "primrec.option_orelse"}
{"formal_statement": "theorem out {l : list Prop} (h : l.tfae) (h\u2081 : auto_param (l.nth n\u2081 = option.some a)\n\t(name.mk_string \"refl\" (name.mk_string \"interactive\" (name.mk_string \"tactic\" name.anonymous))))\n\t(h\u2082 : auto_param (l.nth n\u2082 = option.some b) (name.mk_string \"refl\" (name.mk_string \"interactive\" (name.mk_string \"tactic\" name.anonymous)))) :\n\t\u2200 (n\u2081 n\u2082 : \u2115) {a b : Prop},   (a \u2194 b)", "decl_tp": "\u2200 {l : list Prop}, l.tfae \u2192 \u2200 (n\u2081 n\u2082 : \u2115) {a b : Prop}, auto_param (l.nth n\u2081 = option.some a) (name.mk_string \"refl\" (name.mk_string \"interactive\" (name.mk_string \"tactic\" name.anonymous))) \u2192 auto_param (l.nth n\u2082 = option.some b) (name.mk_string \"refl\" (name.mk_string \"interactive\" (name.mk_string \"tactic\" name.anonymous))) \u2192 (a \u2194 b)", "decl_nm": "list.tfae.out"}
{"formal_statement": "theorem sign_mul_pos_of_ne_zero (r : \u211d) (hr : r \u2260 0) :\n\t0 < r.sign * r", "decl_tp": "\u2200 (r : \u211d), r \u2260 0 \u2192 0 < r.sign * r", "decl_nm": "real.sign_mul_pos_of_ne_zero"}
{"formal_statement": "theorem sum_map {\u03b1 : Type u} {\u03b1' : Type w} {\u03b2 : Type v} {\u03b2' : Type x} {f : \u03b1 \u2192 \u03b2}\n\t{g : \u03b1' \u2192 \u03b2'} (hf : function.surjective f) (hg : function.surjective g) :\n\tfunction.surjective (sum.map f g)", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b1' : Type w} {\u03b2 : Type v} {\u03b2' : Type x} {f : \u03b1 \u2192 \u03b2} {g : \u03b1' \u2192 \u03b2'}, function.surjective f \u2192 function.surjective g \u2192 function.surjective (sum.map f g)", "decl_nm": "function.surjective.sum_map"}
{"formal_statement": "theorem slice_zero {\u03b1 : Type} {d : \u2115} {ds : list \u2115} [has_zero \u03b1] (i : \u2115)\n\t(hid : i < d) :\n\t0.slice i hid = 0", "decl_tp": "\u2200 {\u03b1 : Type} {d : \u2115} {ds : list \u2115} [_inst_1 : has_zero \u03b1] (i : \u2115) (hid : i < d), 0.slice i hid = 0", "decl_nm": "holor.slice_zero"}
{"formal_statement": "theorem lower_raise' (l : list \u2115) (n : \u2115) :\n\tdenumerable.lower' (denumerable.raise' l n) n = l", "decl_tp": "\u2200 (l : list \u2115) (n : \u2115), denumerable.lower' (denumerable.raise' l n) n = l", "decl_nm": "denumerable.lower_raise'"}
{"formal_statement": "theorem coe_pos {\u03b1 : Type u} {\u03b2 : Type v} {\u03c6 : ultrafilter \u03b1} [preorder \u03b2]\n\t[has_zero \u03b2] {f : \u03b1 \u2192 \u03b2} :\n\t0 < \u2191f \u2194 \u2200\u1da0 (x : \u03b1) in \u2191\u03c6, 0 < f x", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {\u03c6 : ultrafilter \u03b1} [_inst_1 : preorder \u03b2] [_inst_2 : has_zero \u03b2] {f : \u03b1 \u2192 \u03b2}, 0 < \u2191f \u2194 \u2200\u1da0 (x : \u03b1) in \u2191\u03c6, 0 < f x", "decl_nm": "filter.germ.coe_pos"}
{"formal_statement": "theorem comap_eval_iso_eval_hom_app {I : Type w\u2080} (C : I \u2192 Type u\u2081) [\u03a0 (i : I), category_theory.category (C i)]\n\t{J : Type w\u2081} (h : J \u2192 I) (j : J) (X : \u03a0 (i : I), C i) :\n\t(category_theory.pi.comap_eval_iso_eval C h j).hom.app X = \ud835\udfd9 (X (h j))", "decl_tp": "\u2200 {I : Type w\u2080} (C : I \u2192 Type u\u2081) [_inst_1 : \u03a0 (i : I), category_theory.category (C i)] {J : Type w\u2081} (h : J \u2192 I) (j : J) (X : \u03a0 (i : I), C i), (category_theory.pi.comap_eval_iso_eval C h j).hom.app X = \ud835\udfd9 (X (h j))", "decl_nm": "category_theory.pi.comap_eval_iso_eval_hom_app"}
{"formal_statement": "theorem hall_hard_inductive {\u03b9 : Type u} {\u03b1 : Type v} [fintype \u03b9] {t : \u03b9 \u2192 finset \u03b1}\n\t[decidable_eq \u03b1] {n : \u2115} (hn : fintype.card \u03b9 = n) :\n\t(\u2200 (s : finset \u03b9), s.card \u2264 (s.bUnion t).card) \u2192 (\u2203 (f : \u03b9 \u2192 \u03b1), function.injective f \u2227 \u2200 (x : \u03b9), f x \u2208 t x)", "decl_tp": "\u2200 {\u03b9 : Type u} {\u03b1 : Type v} [_inst_1 : fintype \u03b9] {t : \u03b9 \u2192 finset \u03b1} [_inst_2 : decidable_eq \u03b1] {n : \u2115}, fintype.card \u03b9 = n \u2192 (\u2200 (s : finset \u03b9), s.card \u2264 (s.bUnion t).card) \u2192 (\u2203 (f : \u03b9 \u2192 \u03b1), function.injective f \u2227 \u2200 (x : \u03b9), f x \u2208 t x)", "decl_nm": "hall_marriage_theorem.hall_hard_inductive"}
{"formal_statement": "theorem measurable_of_measurable_nnreal_nnreal {\u03b2 : Type*} [measurable_space \u03b2]\n\t{f : ennreal \u00d7 ennreal \u2192 \u03b2} (h\u2081 : measurable (\u03bb (p : nnreal \u00d7 nnreal), f (\u2191(p.fst), \u2191(p.snd))))\n\t(h\u2082 : measurable (\u03bb (r : nnreal), f (\u22a4, \u2191r))) (h\u2083 : measurable (\u03bb (r : nnreal), f (\u2191r, \u22a4))) :\n\tmeasurable f", "decl_tp": "\u2200 {\u03b2 : Type u_2} [_inst_2 : measurable_space \u03b2] {f : ennreal \u00d7 ennreal \u2192 \u03b2}, measurable (\u03bb (p : nnreal \u00d7 nnreal), f (\u2191(p.fst), \u2191(p.snd))) \u2192 measurable (\u03bb (r : nnreal), f (\u22a4, \u2191r)) \u2192 measurable (\u03bb (r : nnreal), f (\u2191r, \u22a4)) \u2192 measurable f", "decl_nm": "ennreal.measurable_of_measurable_nnreal_nnreal"}
{"formal_statement": "theorem inf_coe {k V P : Type*} [ring k] [add_comm_group V] [module k V]\n\t[S : add_torsor V P] (s1 s2 : affine_subspace k P) :\n\t\u2191s1 \u2293 \u2191s2 = \u2191s1 \u2229 \u2191s2", "decl_tp": "\u2200 {k : Type u_1} {V : Type u_2} {P : Type u_3} [_inst_1 : ring k] [_inst_2 : add_comm_group V] [_inst_3 : module k V] [S : add_torsor V P] (s1 s2 : affine_subspace k P), \u2191s1 \u2293 \u2191s2 = \u2191s1 \u2229 \u2191s2", "decl_nm": "affine_subspace.inf_coe"}
{"formal_statement": "theorem supr_comp_eq {\u03b1 \u03b2 : Type*} {\u03b9 : Sort u_4} [complete_lattice \u03b1]\n\t[preorder \u03b2] {f : \u03b2 \u2192 \u03b1} (hf : monotone f) :\n\t\u2200 {s : \u03b9 \u2192 \u03b2}, (\u2200 (x : \u03b2), \u2203 (i : \u03b9), x \u2264 s i) \u2192 ((\u2a06 (x : \u03b9), f (s x)) = \u2a06 (y : \u03b2), f y)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {\u03b9 : Sort u_4} [_inst_1 : complete_lattice \u03b1] [_inst_2 : preorder \u03b2] {f : \u03b2 \u2192 \u03b1}, monotone f \u2192 \u2200 {s : \u03b9 \u2192 \u03b2}, (\u2200 (x : \u03b2), \u2203 (i : \u03b9), x \u2264 s i) \u2192 ((\u2a06 (x : \u03b9), f (s x)) = \u2a06 (y : \u03b2), f y)", "decl_nm": "monotone.supr_comp_eq"}
{"formal_statement": "theorem le_add_right (d\u2081 d\u2082 : many_one_degree) :\n\td\u2082 \u2264 d\u2081 + d\u2082", "decl_tp": "\u2200 (d\u2081 d\u2082 : many_one_degree), d\u2082 \u2264 d\u2081 + d\u2082", "decl_nm": "many_one_degree.le_add_right"}
{"formal_statement": "theorem supported_univ {\u03b1 M R : Type*} [semiring R] [add_comm_monoid M]\n\t[module R M] :\n\tfinsupp.supported M R set.univ = \u22a4", "decl_tp": "\u2200 {\u03b1 : Type u_1} {M : Type u_2} {R : Type u_5} [_inst_1 : semiring R] [_inst_3 : add_comm_monoid M] [_inst_4 : module R M], finsupp.supported M R set.univ = \u22a4", "decl_nm": "finsupp.supported_univ"}
{"formal_statement": "theorem gcd_image {\u03b1 \u03b2 \u03b3 : Type*} [cancel_comm_monoid_with_zero \u03b1] [normalized_gcd_monoid \u03b1]\n\t{f : \u03b2 \u2192 \u03b1} {g : \u03b3 \u2192 \u03b2} (s : finset \u03b3) [decidable_eq \u03b2] [is_idempotent \u03b1 gcd_monoid.gcd] :\n\t(finset.image g s).gcd f = s.gcd (f \u2218 g)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {\u03b3 : Type u_3} [_inst_1 : cancel_comm_monoid_with_zero \u03b1] [_inst_2 : normalized_gcd_monoid \u03b1] {f : \u03b2 \u2192 \u03b1} {g : \u03b3 \u2192 \u03b2} (s : finset \u03b3) [_inst_3 : decidable_eq \u03b2] [_inst_4 : is_idempotent \u03b1 gcd_monoid.gcd], (finset.image g s).gcd f = s.gcd (f \u2218 g)", "decl_nm": "finset.gcd_image"}
{"formal_statement": "theorem subset_compl_comm {\u03b1 : Type u} {s t : set \u03b1} :\n\ts \u2286 t\u1d9c \u2194 t \u2286 s\u1d9c", "decl_tp": "\u2200 {\u03b1 : Type u} {s t : set \u03b1}, s \u2286 t\u1d9c \u2194 t \u2286 s\u1d9c", "decl_nm": "set.subset_compl_comm"}
{"formal_statement": "theorem ne_zero {R : Type*} [semiring R] [nontrivial R] {p : polynomial R}\n\t(hp : p.monic) :\n\tp \u2260 0", "decl_tp": "\u2200 {R : Type u_1} [_inst_2 : semiring R] [_inst_3 : nontrivial R] {p : polynomial R}, p.monic \u2192 p \u2260 0", "decl_nm": "polynomial.monic.ne_zero"}
{"formal_statement": "theorem augment_X_succ {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V]\n\t(C : cochain_complex V \u2115) {X : V} (f : X \u27f6 C.X 0) (w : f \u226b C.d 0 1 = 0)\n\t(i : \u2115) :\n\t(C.augment f w).X (i + 1) = C.X i", "decl_tp": "\u2200 {V : Type u} [_inst_1 : category_theory.category V] [_inst_2 : category_theory.limits.has_zero_morphisms V] (C : cochain_complex V \u2115) {X : V} (f : X \u27f6 C.X 0) (w : f \u226b C.d 0 1 = 0) (i : \u2115), (C.augment f w).X (i + 1) = C.X i", "decl_nm": "cochain_complex.augment_X_succ"}
{"formal_statement": "theorem comp_assoc {\u03b1 \u03b2 \u03b3 \u03b4 : Type*} (r : rel \u03b1 \u03b2) (s : rel \u03b2 \u03b3) (t : rel \u03b3 \u03b4) :\n\t(r.comp s).comp t = r.comp (s.comp t)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {\u03b3 : Type u_3} {\u03b4 : Type u_4} (r : rel \u03b1 \u03b2) (s : rel \u03b2 \u03b3) (t : rel \u03b3 \u03b4), (r.comp s).comp t = r.comp (s.comp t)", "decl_nm": "rel.comp_assoc"}
{"formal_statement": "theorem to_finsupp_support {\u03b1 : Type*} [decidable_eq \u03b1] (s : multiset \u03b1) :\n\t(\u21d1multiset.to_finsupp s).support = s.to_finset", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : decidable_eq \u03b1] (s : multiset \u03b1), (\u21d1multiset.to_finsupp s).support = s.to_finset", "decl_nm": "multiset.to_finsupp_support"}
{"formal_statement": "theorem comp_coe {\u03b1 \u03b2 \u03b3 : Type*} [topological_space \u03b1] [topological_space \u03b2]\n\t[topological_space \u03b3] (f : C(\u03b2, \u03b3)) (g : C(\u03b1, \u03b2)) :\n\t\u21d1(f.comp g) = \u21d1f \u2218 \u21d1g", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {\u03b3 : Type u_3} [_inst_1 : topological_space \u03b1] [_inst_2 : topological_space \u03b2] [_inst_3 : topological_space \u03b3] (f : C(\u03b2, \u03b3)) (g : C(\u03b1, \u03b2)), \u21d1(f.comp g) = \u21d1f \u2218 \u21d1g", "decl_nm": "continuous_map.comp_coe"}
{"formal_statement": "theorem eq' {\u03b1 : Type*} [add_group \u03b1] {s : add_subgroup \u03b1} {a b : \u03b1} :\n\tquotient_add_group.mk a = quotient_add_group.mk b \u2194 -a + b \u2208 s", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : add_group \u03b1] {s : add_subgroup \u03b1} {a b : \u03b1}, quotient_add_group.mk a = quotient_add_group.mk b \u2194 -a + b \u2208 s", "decl_nm": "quotient_add_group.eq'"}
{"formal_statement": "theorem neg {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c] {E : Type*} [normed_group E]\n\t[normed_space \ud835\udd5c E] {F : Type*} [normed_group F] [normed_space \ud835\udd5c F] {n : with_top \u2115}\n\t{s : set E} {f : E \u2192 F} (hf : times_cont_diff_on \ud835\udd5c n f s) :\n\ttimes_cont_diff_on \ud835\udd5c n (\u03bb (x : E), -f x) s", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {F : Type u_3} [_inst_4 : normed_group F] [_inst_5 : normed_space \ud835\udd5c F] {n : with_top \u2115} {s : set E} {f : E \u2192 F}, times_cont_diff_on \ud835\udd5c n f s \u2192 times_cont_diff_on \ud835\udd5c n (\u03bb (x : E), -f x) s", "decl_nm": "times_cont_diff_on.neg"}
{"formal_statement": "theorem powerset_univ {\u03b1 : Type u} :\n\t\ud835\udcab set.univ = set.univ", "decl_tp": "\u2200 {\u03b1 : Type u}, \ud835\udcab set.univ = set.univ", "decl_nm": "set.powerset_univ"}
{"formal_statement": "theorem cod_restrict_top {\u03b1 \u03b2 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop}\n\t(p : set \u03b2) (f : principal_seg r s) (H : \u2200 (a : \u03b1), \u21d1f a \u2208 p) (H\u2082 : f.top \u2208 p) :\n\t(principal_seg.cod_restrict p f H H\u2082).top = \u27e8f.top, H\u2082\u27e9", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} (p : set \u03b2) (f : principal_seg r s) (H : \u2200 (a : \u03b1), \u21d1f a \u2208 p) (H\u2082 : f.top \u2208 p), (principal_seg.cod_restrict p f H H\u2082).top = \u27e8f.top, H\u2082\u27e9", "decl_nm": "principal_seg.cod_restrict_top"}
{"formal_statement": "theorem continuous_def {\u03b1 \u03b2 : Type*} [topological_space \u03b1] [topological_space \u03b2]\n\t{f : \u03b1 \u2192 \u03b2} :\n\tcontinuous f \u2194 \u2200 (s : set \u03b2), is_open s \u2192 is_open (f \u207b\u00b9' s)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : topological_space \u03b1] [_inst_2 : topological_space \u03b2] {f : \u03b1 \u2192 \u03b2}, continuous f \u2194 \u2200 (s : set \u03b2), is_open s \u2192 is_open (f \u207b\u00b9' s)", "decl_nm": "continuous_def"}
{"formal_statement": "theorem induction_on_multiset_quot {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {p : multiset (quot r) \u2192 Prop}\n\t(s : multiset (quot r)) :\n\t(\u2200 (s : multiset \u03b1), p (multiset.map (quot.mk r) s)) \u2192 p s", "decl_tp": "\u2200 {\u03b1 : Type u_1} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {p : multiset (quot r) \u2192 Prop} (s : multiset (quot r)), (\u2200 (s : multiset \u03b1), p (multiset.map (quot.mk r) s)) \u2192 p s", "decl_nm": "multiset.induction_on_multiset_quot"}
{"formal_statement": "theorem trans_assoc {\u03b1 \u03b2 \u03b3 \u03b4 : Type*} [topological_space \u03b1] [topological_space \u03b2]\n\t[topological_space \u03b3] [topological_space \u03b4] (e : local_homeomorph \u03b1 \u03b2)\n\t(e' : local_homeomorph \u03b2 \u03b3) (e'' : local_homeomorph \u03b3 \u03b4) :\n\t(e.trans e').trans e'' = e.trans (e'.trans e'')", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {\u03b3 : Type u_3} {\u03b4 : Type u_4} [_inst_1 : topological_space \u03b1] [_inst_2 : topological_space \u03b2] [_inst_3 : topological_space \u03b3] [_inst_4 : topological_space \u03b4] (e : local_homeomorph \u03b1 \u03b2) (e' : local_homeomorph \u03b2 \u03b3) (e'' : local_homeomorph \u03b3 \u03b4), (e.trans e').trans e'' = e.trans (e'.trans e'')", "decl_nm": "local_homeomorph.trans_assoc"}
{"formal_statement": "theorem nonempty_of_nonempty_subtype {\u03b1 : Type u} {s : set \u03b1} [nonempty \u21a5s] :\n\ts.nonempty", "decl_tp": "\u2200 {\u03b1 : Type u} {s : set \u03b1} [_inst_1 : nonempty \u21a5s], s.nonempty", "decl_nm": "set.nonempty_of_nonempty_subtype"}
{"formal_statement": "theorem fork_\u03c0_app_walking_parallel_pair_zero {C : Type u} [category_theory.category C]\n\t[category_theory.limits.has_products C] {X : Top} (F : Top.presheaf C X)\n\t{\u03b9 : Type v} (U : \u03b9 \u2192 topological_space.opens \u21a5X) :\n\t(Top.presheaf.sheaf_condition_equalizer_products.fork F U).\u03c0.app category_theory.limits.walking_parallel_pair.zero = Top.presheaf.sheaf_condition_equalizer_products.res F U", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] [_inst_2 : category_theory.limits.has_products C] {X : Top} (F : Top.presheaf C X) {\u03b9 : Type v} (U : \u03b9 \u2192 topological_space.opens \u21a5X), (Top.presheaf.sheaf_condition_equalizer_products.fork F U).\u03c0.app category_theory.limits.walking_parallel_pair.zero = Top.presheaf.sheaf_condition_equalizer_products.res F U", "decl_nm": "Top.presheaf.sheaf_condition_equalizer_products.fork_\u03c0_app_walking_parallel_pair_zero"}
{"formal_statement": "theorem card_union_eq {\u03b1 : Type*} {s t : finset \u03b1} [decidable_eq \u03b1] (h : disjoint s t) :\n\t(s \u222a t).card = s.card + t.card", "decl_tp": "\u2200 {\u03b1 : Type u_1} {s t : finset \u03b1} [_inst_1 : decidable_eq \u03b1], disjoint s t \u2192 (s \u222a t).card = s.card + t.card", "decl_nm": "finset.card_union_eq"}
{"formal_statement": "theorem prod {\u03b1 : Type u} {\u03b2 : Type v} [topological_space \u03b1] [topological_space \u03b2]\n\t{s : set \u03b1} {t : set \u03b2} (hs : is_open s) (ht : is_open t) :\n\tis_open (s.prod t)", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : topological_space \u03b1] [_inst_2 : topological_space \u03b2] {s : set \u03b1} {t : set \u03b2}, is_open s \u2192 is_open t \u2192 is_open (s.prod t)", "decl_nm": "is_open.prod"}
{"formal_statement": "theorem discrete_topology_of_open_singleton_zero {G : Type w} [topological_space G]\n\t[add_group G] [has_continuous_add G] (h : is_open {0}) :\n\tdiscrete_topology G", "decl_tp": "\u2200 {G : Type w} [_inst_1 : topological_space G] [_inst_2 : add_group G] [_inst_3 : has_continuous_add G], is_open {0} \u2192 discrete_topology G", "decl_nm": "discrete_topology_of_open_singleton_zero"}
{"formal_statement": "theorem cast_int_left {R : Type u\u2081} [ring R] (a : R) (m : \u2124) :\n\tcommute \u2191m a", "decl_tp": "\u2200 {R : Type u\u2081} [_inst_3 : ring R] (a : R) (m : \u2124), commute \u2191m a", "decl_nm": "commute.cast_int_left"}
{"formal_statement": "theorem bit1_le_bit1 (n m : \u2115+) :\n\tbit1 n \u2264 bit1 m \u2194 bit1 \u2191n \u2264 bit1 \u2191m", "decl_tp": "\u2200 (n m : \u2115+), bit1 n \u2264 bit1 m \u2194 bit1 \u2191n \u2264 bit1 \u2191m", "decl_nm": "pnat.bit1_le_bit1"}
{"formal_statement": "theorem eval_one {R : Type u} [semiring R] {x : R} :\n\tpolynomial.eval x 1 = 1", "decl_tp": "\u2200 {R : Type u} [_inst_1 : semiring R] {x : R}, polynomial.eval x 1 = 1", "decl_nm": "polynomial.eval_one"}
{"formal_statement": "theorem mul_right_inj' {M\u2080 : Type*} [cancel_monoid_with_zero M\u2080] {a b c : M\u2080}\n\t(ha : a \u2260 0) :\n\t(a * b = a * c \u2194 b = c)", "decl_tp": "\u2200 {M\u2080 : Type u_1} [_inst_1 : cancel_monoid_with_zero M\u2080] {a b c : M\u2080}, a \u2260 0 \u2192 (a * b = a * c \u2194 b = c)", "decl_nm": "mul_right_inj'"}
{"formal_statement": "theorem lcm_one_right {\u03b1 : Type*} [cancel_comm_monoid_with_zero \u03b1] [normalized_gcd_monoid \u03b1]\n\t(a : \u03b1) :\n\tgcd_monoid.lcm a 1 = \u21d1normalize a", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : cancel_comm_monoid_with_zero \u03b1] [_inst_2 : normalized_gcd_monoid \u03b1] (a : \u03b1), gcd_monoid.lcm a 1 = \u21d1normalize a", "decl_nm": "lcm_one_right"}
{"formal_statement": "theorem mdifferentiable_at {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c] {E : Type*}\n\t[normed_group E] [normed_space \ud835\udd5c E] {H : Type*} [topological_space H]\n\t{I : model_with_corners \ud835\udd5c E H} {M : Type*} [topological_space M] [charted_space H M]\n\t{E' : Type*} [normed_group E'] [normed_space \ud835\udd5c E'] {H' : Type*} [topological_space H']\n\t{I' : model_with_corners \ud835\udd5c E' H'} {M' : Type*} [topological_space M']\n\t[charted_space H' M'] {e : local_homeomorph M M'} (he : local_homeomorph.mdifferentiable I I' e)\n\t(hx : x \u2208 e.to_local_equiv.source) :\n\t\u2200 {x : M},  mdifferentiable_at I I' \u21d1e x", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {H : Type u_3} [_inst_4 : topological_space H] {I : model_with_corners \ud835\udd5c E H} {M : Type u_4} [_inst_5 : topological_space M] [_inst_6 : charted_space H M] {E' : Type u_5} [_inst_7 : normed_group E'] [_inst_8 : normed_space \ud835\udd5c E'] {H' : Type u_6} [_inst_9 : topological_space H'] {I' : model_with_corners \ud835\udd5c E' H'} {M' : Type u_7} [_inst_10 : topological_space M'] [_inst_11 : charted_space H' M'] {e : local_homeomorph M M'}, local_homeomorph.mdifferentiable I I' e \u2192 \u2200 {x : M}, x \u2208 e.to_local_equiv.source \u2192 mdifferentiable_at I I' \u21d1e x", "decl_nm": "local_homeomorph.mdifferentiable.mdifferentiable_at"}
{"formal_statement": "theorem strongly_measurable {\u03b1 \u03b2 : Type*} [measurable_space \u03b1] [measurable_space \u03b2]\n\t{f : \u03b1 \u2192 \u03b2} [emetric_space \u03b2] [opens_measurable_space \u03b2] [topological_space.second_countable_topology \u03b2]\n\t(hf : measurable f) :\n\tmeasure_theory.strongly_measurable f", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : measurable_space \u03b1] [_inst_2 : measurable_space \u03b2] {f : \u03b1 \u2192 \u03b2} [_inst_3 : emetric_space \u03b2] [_inst_4 : opens_measurable_space \u03b2] [_inst_5 : topological_space.second_countable_topology \u03b2], measurable f \u2192 measure_theory.strongly_measurable f", "decl_nm": "measurable.strongly_measurable"}
{"formal_statement": "theorem set_lintegral_const {\u03b1 : Type*} {m : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1}\n\t(s : set \u03b1) (c : ennreal) :\n\t\u222b\u207b (a : \u03b1) in s, c \u2202\u03bc = c * \u21d1\u03bc s", "decl_tp": "\u2200 {\u03b1 : Type u_1} {m : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} (s : set \u03b1) (c : ennreal), \u222b\u207b (a : \u03b1) in s, c \u2202\u03bc = c * \u21d1\u03bc s", "decl_nm": "measure_theory.set_lintegral_const"}
{"formal_statement": "theorem coe_copy {M : Type*} [add_zero_class M] {S : add_submonoid M} {s : set M}\n\t(hs : s = \u2191S) :\n\t\u2191(S.copy s hs) = s", "decl_tp": "\u2200 {M : Type u_1} [_inst_1 : add_zero_class M] {S : add_submonoid M} {s : set M} (hs : s = \u2191S), \u2191(S.copy s hs) = s", "decl_nm": "add_submonoid.coe_copy"}
{"formal_statement": "theorem forall_of_pairwise {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (H : symmetric r)\n\t(hs : multiset.pairwise r s) :\n\t\u2200 {s : multiset \u03b1},  \u2200 (a : \u03b1), a \u2208 s \u2192 \u2200 (b : \u03b1), b \u2208 s \u2192 a \u2260 b \u2192 r a b", "decl_tp": "\u2200 {\u03b1 : Type u_1} {r : \u03b1 \u2192 \u03b1 \u2192 Prop}, symmetric r \u2192 \u2200 {s : multiset \u03b1}, multiset.pairwise r s \u2192 \u2200 (a : \u03b1), a \u2208 s \u2192 \u2200 (b : \u03b1), b \u2208 s \u2192 a \u2260 b \u2192 r a b", "decl_nm": "multiset.forall_of_pairwise"}
{"formal_statement": "theorem mem_pointwise_smul_iff_inv_smul_mem\u2080 {\u03b1 M : Type*} [monoid M] [group_with_zero \u03b1]\n\t[mul_distrib_mul_action \u03b1 M] {a : \u03b1} (ha : a \u2260 0) :\n\t\u2200 (S : submonoid M) (x : M), x \u2208 a \u2022 S \u2194 a\u207b\u00b9 \u2022 x \u2208 S", "decl_tp": "\u2200 {\u03b1 : Type u_1} {M : Type u_2} [_inst_1 : monoid M] [_inst_3 : group_with_zero \u03b1] [_inst_4 : mul_distrib_mul_action \u03b1 M] {a : \u03b1}, a \u2260 0 \u2192 \u2200 (S : submonoid M) (x : M), x \u2208 a \u2022 S \u2194 a\u207b\u00b9 \u2022 x \u2208 S", "decl_nm": "submonoid.mem_pointwise_smul_iff_inv_smul_mem\u2080"}
{"formal_statement": "theorem lift_aux_unique {\u03b1 : Type u} {\u03b2 : Type v} [has_add \u03b2] (F : add_hom (free_add_magma \u03b1) \u03b2) :\n\t\u21d1F = free_add_magma.lift_aux (\u21d1F \u2218 free_add_magma.of)", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : has_add \u03b2] (F : add_hom (free_add_magma \u03b1) \u03b2), \u21d1F = free_add_magma.lift_aux (\u21d1F \u2218 free_add_magma.of)", "decl_nm": "free_add_magma.lift_aux_unique"}
{"formal_statement": "theorem le_add_one {a b : \u2124} (h : a \u2264 b) :\n\ta \u2264 b + 1", "decl_tp": "\u2200 {a b : \u2124}, a \u2264 b \u2192 a \u2264 b + 1", "decl_nm": "int.le_add_one"}
{"formal_statement": "theorem closed_iff_closed {C : Type u} [category_theory.category C] (J\u2081 : category_theory.grothendieck_topology C)\n\t{X : C} (S : category_theory.sieve X) :\n\tS \u2208 (J\u2081.closure_operator X).closed \u2194 J\u2081.is_closed S", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] (J\u2081 : category_theory.grothendieck_topology C) {X : C} (S : category_theory.sieve X), S \u2208 (J\u2081.closure_operator X).closed \u2194 J\u2081.is_closed S", "decl_nm": "category_theory.grothendieck_topology.closed_iff_closed"}
{"formal_statement": "theorem map_of {\u03b1 : Type u} {\u03b2 : Type v} (f : \u03b1 \u2192 \u03b2) (x : \u03b1) :\n\tfree_magma.map f (free_magma.of x) = free_magma.of (f x)", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} (f : \u03b1 \u2192 \u03b2) (x : \u03b1), free_magma.map f (free_magma.of x) = free_magma.of (f x)", "decl_nm": "free_magma.map_of"}
{"formal_statement": "theorem eq_neg_one_of_two_right {R : Type*} {\u03b6 : R} [comm_ring R] [is_domain R]\n\t(h : is_primitive_root \u03b6 2) :\n\t\u03b6 = -1", "decl_tp": "\u2200 {R : Type u_5} {\u03b6 : R} [_inst_5 : comm_ring R] [_inst_6 : is_domain R], is_primitive_root \u03b6 2 \u2192 \u03b6 = -1", "decl_nm": "is_primitive_root.eq_neg_one_of_two_right"}
{"formal_statement": "theorem single_le_prod' {\u03b9 N : Type*} [ordered_comm_monoid N] {f : \u03b9 \u2192 N}\n\t{s : finset \u03b9} (h : a \u2208 s) :\n\t(\u2200 (i : \u03b9), i \u2208 s \u2192 1 \u2264 f i) \u2192 \u2200 {a : \u03b9},  f a \u2264 s.prod (\u03bb (x : \u03b9), f x)", "decl_tp": "\u2200 {\u03b9 : Type u_1} {N : Type u_5} [_inst_2 : ordered_comm_monoid N] {f : \u03b9 \u2192 N} {s : finset \u03b9}, (\u2200 (i : \u03b9), i \u2208 s \u2192 1 \u2264 f i) \u2192 \u2200 {a : \u03b9}, a \u2208 s \u2192 f a \u2264 s.prod (\u03bb (x : \u03b9), f x)", "decl_nm": "finset.single_le_prod'"}
{"formal_statement": "theorem to_topological_space_bot {\u03b1 : Type*} :\n\tuniform_space.to_topological_space = \u22a5", "decl_tp": "\u2200 {\u03b1 : Type u_1}, uniform_space.to_topological_space = \u22a5", "decl_nm": "to_topological_space_bot"}
{"formal_statement": "theorem has_coe_to_fun_coe {L : first_order.language} {M N : Type*} [L.Structure M]\n\t[L.Structure N] (f : L.embedding M N) (\u1fb0 : M) :\n\thas_coe_to_fun.coe f \u1fb0 = f.to_embedding.to_fun \u1fb0", "decl_tp": "\u2200 {L : first_order.language} {M : Type u_3} {N : Type u_4} [_inst_1 : L.Structure M] [_inst_2 : L.Structure N] (f : L.embedding M N) (\u1fb0 : M), has_coe_to_fun.coe f \u1fb0 = f.to_embedding.to_fun \u1fb0", "decl_nm": "first_order.language.embedding.has_coe_to_fun_coe"}
{"formal_statement": "theorem pair_eq_singleton {\u03b1 : Type u} (a : \u03b1) :\n\t{a, a} = {a}", "decl_tp": "\u2200 {\u03b1 : Type u} (a : \u03b1), {a, a} = {a}", "decl_nm": "set.pair_eq_singleton"}
{"formal_statement": "theorem suffix_insert {\u03b1 : Type*} [decidable_eq \u03b1] (a : \u03b1) (l : list \u03b1) :\n\tl <:+ has_insert.insert a l", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : decidable_eq \u03b1] (a : \u03b1) (l : list \u03b1), l <:+ has_insert.insert a l", "decl_nm": "list.suffix_insert"}
{"formal_statement": "theorem sUnion_insert {\u03b1 : Type*} (s : set \u03b1) (T : set (set \u03b1)) :\n\t\u22c3\u2080 has_insert.insert s T = s \u222a \u22c3\u2080 T", "decl_tp": "\u2200 {\u03b1 : Type u_1} (s : set \u03b1) (T : set (set \u03b1)), \u22c3\u2080 has_insert.insert s T = s \u222a \u22c3\u2080 T", "decl_nm": "set.sUnion_insert"}
{"formal_statement": "theorem rpow_neg_one (x : ennreal) :\n\tx ^ -1 = x\u207b\u00b9", "decl_tp": "\u2200 (x : ennreal), x ^ -1 = x\u207b\u00b9", "decl_nm": "ennreal.rpow_neg_one"}
{"formal_statement": "theorem card_eq_one_iff {\u03b1 : Type*} [fintype \u03b1] :\n\tfintype.card \u03b1 = 1 \u2194 \u2203 (x : \u03b1), \u2200 (y : \u03b1), y = x", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : fintype \u03b1], fintype.card \u03b1 = 1 \u2194 \u2203 (x : \u03b1), \u2200 (y : \u03b1), y = x", "decl_nm": "fintype.card_eq_one_iff"}
{"formal_statement": "theorem add_tsub_tsub_cancel {\u03b1 : Type*} [canonically_ordered_add_monoid \u03b1]\n\t[has_sub \u03b1] [has_ordered_sub \u03b1] {a b c : \u03b1} (hac : add_le_cancellable (a - c))\n\t(h : c \u2264 a) :\n\ta + b - (a - c) = b + c", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : canonically_ordered_add_monoid \u03b1] [_inst_2 : has_sub \u03b1] [_inst_3 : has_ordered_sub \u03b1] {a b c : \u03b1}, add_le_cancellable (a - c) \u2192 c \u2264 a \u2192 a + b - (a - c) = b + c", "decl_nm": "add_le_cancellable.add_tsub_tsub_cancel"}
{"formal_statement": "theorem finite_le_nat {\u03b1 : Type*} (n : \u03b1 \u2192\u2080 \u2115) :\n\t{m : \u03b1 \u2192\u2080 \u2115 | m \u2264 n}.finite", "decl_tp": "\u2200 {\u03b1 : Type u_1} (n : \u03b1 \u2192\u2080 \u2115), {m : \u03b1 \u2192\u2080 \u2115 | m \u2264 n}.finite", "decl_nm": "finsupp.finite_le_nat"}
{"formal_statement": "theorem smul_add_hom_apply {R : Type u} {M : Type w} [semiring R] [add_comm_monoid M]\n\t[module R M] (r : R) (x : M) :\n\t\u21d1(\u21d1(smul_add_hom R M) r) x = r \u2022 x", "decl_tp": "\u2200 {R : Type u} {M : Type w} [_inst_1 : semiring R] [_inst_2 : add_comm_monoid M] [_inst_3 : module R M] (r : R) (x : M), \u21d1(\u21d1(smul_add_hom R M) r) x = r \u2022 x", "decl_nm": "smul_add_hom_apply"}
{"formal_statement": "theorem mem_inv_pointwise_smul_iff\u2080 {M R : Type*} [group_with_zero M] [ring R]\n\t[mul_semiring_action M R] {a : M} (ha : a \u2260 0) :\n\t\u2200 (S : subring R) (x : R), x \u2208 a\u207b\u00b9 \u2022 S \u2194 a \u2022 x \u2208 S", "decl_tp": "\u2200 {M : Type u_1} {R : Type u_2} [_inst_1 : group_with_zero M] [_inst_2 : ring R] [_inst_3 : mul_semiring_action M R] {a : M}, a \u2260 0 \u2192 \u2200 (S : subring R) (x : R), x \u2208 a\u207b\u00b9 \u2022 S \u2194 a \u2022 x \u2208 S", "decl_nm": "subring.mem_inv_pointwise_smul_iff\u2080"}
{"formal_statement": "theorem zero {V\u2081 V\u2082 : Type*} [semi_normed_group V\u2081] [semi_normed_group V\u2082] :\n\t0.norm_noninc", "decl_tp": "\u2200 {V\u2081 : Type u_3} {V\u2082 : Type u_4} [_inst_3 : semi_normed_group V\u2081] [_inst_4 : semi_normed_group V\u2082], 0.norm_noninc", "decl_nm": "normed_group_hom.norm_noninc.zero"}
{"formal_statement": "theorem min'_lt_max'_of_card {\u03b1 : Type*} [linear_order \u03b1] (s : finset \u03b1)\n\t(h\u2082 : 1 < s.card) :\n\ts.min' _ < s.max' _", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : linear_order \u03b1] (s : finset \u03b1) (h\u2082 : 1 < s.card), s.min' _ < s.max' _", "decl_nm": "finset.min'_lt_max'_of_card"}
{"formal_statement": "theorem dist_pi_le_iff {\u03b2 : Type v} {\u03c0 : \u03b2 \u2192 Type*} [fintype \u03b2] [\u03a0 (b : \u03b2), pseudo_metric_space (\u03c0 b)]\n\t{f g : \u03a0 (b : \u03b2), \u03c0 b} {r : \u211d} (hr : 0 \u2264 r) :\n\t(has_dist.dist f g \u2264 r \u2194 \u2200 (b : \u03b2), has_dist.dist (f b) (g b) \u2264 r)", "decl_tp": "\u2200 {\u03b2 : Type v} {\u03c0 : \u03b2 \u2192 Type u_1} [_inst_2 : fintype \u03b2] [_inst_3 : \u03a0 (b : \u03b2), pseudo_metric_space (\u03c0 b)] {f g : \u03a0 (b : \u03b2), \u03c0 b} {r : \u211d}, 0 \u2264 r \u2192 (has_dist.dist f g \u2264 r \u2194 \u2200 (b : \u03b2), has_dist.dist (f b) (g b) \u2264 r)", "decl_nm": "dist_pi_le_iff"}
{"formal_statement": "theorem mul_salem_spencer_empty {\u03b1 : Type*} [monoid \u03b1] :\n\tmul_salem_spencer \u2205", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : monoid \u03b1], mul_salem_spencer \u2205", "decl_nm": "mul_salem_spencer_empty"}
{"formal_statement": "theorem exists_eq_right' {\u03b1 : Sort u_1} {p : \u03b1 \u2192 Prop} {a' : \u03b1} :\n\t(\u2203 (a : \u03b1), p a \u2227 a' = a) \u2194 p a'", "decl_tp": "\u2200 {\u03b1 : Sort u_1} {p : \u03b1 \u2192 Prop} {a' : \u03b1}, (\u2203 (a : \u03b1), p a \u2227 a' = a) \u2194 p a'", "decl_nm": "exists_eq_right'"}
{"formal_statement": "theorem count_union {\u03b1 : Type*} [decidable_eq \u03b1] (a : \u03b1) (s t : multiset \u03b1) :\n\tmultiset.count a (s \u222a t) = linear_order.max (multiset.count a s) (multiset.count a t)", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : decidable_eq \u03b1] (a : \u03b1) (s t : multiset \u03b1), multiset.count a (s \u222a t) = linear_order.max (multiset.count a s) (multiset.count a t)", "decl_nm": "multiset.count_union"}
{"formal_statement": "theorem uniformity_eq_symm {\u03b1 : Type*} [uniform_space \u03b1] :\n\tuniformity \u03b1 = prod.swap <$> uniformity \u03b1", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : uniform_space \u03b1], uniformity \u03b1 = prod.swap <$> uniformity \u03b1", "decl_nm": "uniformity_eq_symm"}
{"formal_statement": "theorem smul_re {R : Type*} [comm_ring R] {c\u2081 c\u2082 : R} (r : R) (a : quaternion_algebra R c\u2081 c\u2082) :\n\t(r \u2022 a).re = r \u2022 a.re", "decl_tp": "\u2200 {R : Type u_1} [_inst_1 : comm_ring R] {c\u2081 c\u2082 : R} (r : R) (a : quaternion_algebra R c\u2081 c\u2082), (r \u2022 a).re = r \u2022 a.re", "decl_nm": "quaternion_algebra.smul_re"}
{"formal_statement": "theorem mop_unmop {C : Type u\u2081} (X : C\u1d39\u1d52\u1d56) :\n\tcategory_theory.monoidal_opposite.mop (category_theory.monoidal_opposite.unmop X) = X", "decl_tp": "\u2200 {C : Type u\u2081} (X : C\u1d39\u1d52\u1d56), category_theory.monoidal_opposite.mop (category_theory.monoidal_opposite.unmop X) = X", "decl_nm": "category_theory.monoidal_opposite.mop_unmop"}
{"formal_statement": "theorem deriv_mul_const {\ud835\udd5c : Type u} [nondiscrete_normed_field \ud835\udd5c] {x : \ud835\udd5c}\n\t{\ud835\udd38 : Type*} [normed_ring \ud835\udd38] [normed_algebra \ud835\udd5c \ud835\udd38] {c : \ud835\udd5c \u2192 \ud835\udd38} (hc : differentiable_at \ud835\udd5c c x) :\n\t\u2200 (d : \ud835\udd38), deriv (\u03bb (y : \ud835\udd5c), c y * d) x = deriv c x * d", "decl_tp": "\u2200 {\ud835\udd5c : Type u} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {x : \ud835\udd5c} {\ud835\udd38 : Type u_2} [_inst_7 : normed_ring \ud835\udd38] [_inst_9 : normed_algebra \ud835\udd5c \ud835\udd38] {c : \ud835\udd5c \u2192 \ud835\udd38}, differentiable_at \ud835\udd5c c x \u2192 \u2200 (d : \ud835\udd38), deriv (\u03bb (y : \ud835\udd5c), c y * d) x = deriv c x * d", "decl_nm": "deriv_mul_const"}
{"formal_statement": "theorem nth_zero {n : \u2115} {\u03b1 : Type*} (v : vector \u03b1 n.succ) :\n\tv.nth 0 = v.head", "decl_tp": "\u2200 {n : \u2115} {\u03b1 : Type u_1} (v : vector \u03b1 n.succ), v.nth 0 = v.head", "decl_nm": "vector.nth_zero"}
{"formal_statement": "theorem mdifferentiable {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c] {E : Type*}\n\t[normed_group E] [normed_space \ud835\udd5c E] {E' : Type*} [normed_group E'] [normed_space \ud835\udd5c E']\n\t(f : E \u2192L[\ud835\udd5c] E') :\n\tmdifferentiable (model_with_corners_self \ud835\udd5c E) (model_with_corners_self \ud835\udd5c E') \u21d1f", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {E' : Type u_5} [_inst_8 : normed_group E'] [_inst_9 : normed_space \ud835\udd5c E'] (f : E \u2192L[\ud835\udd5c] E'), mdifferentiable (model_with_corners_self \ud835\udd5c E) (model_with_corners_self \ud835\udd5c E') \u21d1f", "decl_nm": "continuous_linear_map.mdifferentiable"}
{"formal_statement": "theorem leading_coeff_prod' {R : Type u} {\u03b9 : Type w} (s : finset \u03b9) [comm_semiring R]\n\t(f : \u03b9 \u2192 polynomial R) (h : s.prod (\u03bb (i : \u03b9), (f i).leading_coeff) \u2260 0) :\n\t(s.prod (\u03bb (i : \u03b9), f i)).leading_coeff = s.prod (\u03bb (i : \u03b9), (f i).leading_coeff)", "decl_tp": "\u2200 {R : Type u} {\u03b9 : Type w} (s : finset \u03b9) [_inst_1 : comm_semiring R] (f : \u03b9 \u2192 polynomial R), s.prod (\u03bb (i : \u03b9), (f i).leading_coeff) \u2260 0 \u2192 (s.prod (\u03bb (i : \u03b9), f i)).leading_coeff = s.prod (\u03bb (i : \u03b9), (f i).leading_coeff)", "decl_nm": "polynomial.leading_coeff_prod'"}
{"formal_statement": "theorem pos {p q : \u211d} (h : p.is_conjugate_exponent q) :\n\t0 < p", "decl_tp": "\u2200 {p q : \u211d}, p.is_conjugate_exponent q \u2192 0 < p", "decl_nm": "real.is_conjugate_exponent.pos"}
{"formal_statement": "theorem union_apply_left {\u03b1 : Type*} {s t : set \u03b1} [decidable_pred (\u03bb (x : \u03b1), x \u2208 s)]\n\t(H : s \u2229 t \u2286 \u2205) {a : \u21a5(s \u222a t)} (ha : \u2191a \u2208 s) :\n\t\u21d1(equiv.set.union H) a = sum.inl \u27e8\u2191a, ha\u27e9", "decl_tp": "\u2200 {\u03b1 : Type u_1} {s t : set \u03b1} [_inst_1 : decidable_pred (\u03bb (x : \u03b1), x \u2208 s)] (H : s \u2229 t \u2286 \u2205) {a : \u21a5(s \u222a t)} (ha : \u2191a \u2208 s), \u21d1(equiv.set.union H) a = sum.inl \u27e8\u2191a, ha\u27e9", "decl_nm": "equiv.set.union_apply_left"}
{"formal_statement": "theorem finite_Union_left {X : Type*} [emetric_space X] {\u03b9 : Type*} {I : set \u03b9}\n\t(hI : I.finite) :\n\t\u2200 {s : \u03b9 \u2192 set X} {t : set X}, (\u2200 (i : \u03b9), i \u2208 I \u2192 is_metric_separated (s i) t) \u2192 is_metric_separated (\u22c3 (i : \u03b9)\n\t(H : i \u2208 I), s i) t", "decl_tp": "\u2200 {X : Type u_1} [_inst_1 : emetric_space X] {\u03b9 : Type u_2} {I : set \u03b9}, I.finite \u2192 \u2200 {s : \u03b9 \u2192 set X} {t : set X}, (\u2200 (i : \u03b9), i \u2208 I \u2192 is_metric_separated (s i) t) \u2192 is_metric_separated (\u22c3 (i : \u03b9) (H : i \u2208 I), s i) t", "decl_nm": "is_metric_separated.finite_Union_left"}
{"formal_statement": "theorem constant_of_preserves_morphisms {J : Type u\u2081} [category_theory.category J]\n\t[category_theory.is_preconnected J] {\u03b1 : Type u\u2081} (F : J \u2192 \u03b1) :\n\t(\u2200 (j\u2081 j\u2082 : J), (j\u2081 \u27f6 j\u2082) \u2192 F j\u2081 = F j\u2082) \u2192 \u2200 (j j' : J), F j = F j'", "decl_tp": "\u2200 {J : Type u\u2081} [_inst_1 : category_theory.category J] [_inst_3 : category_theory.is_preconnected J] {\u03b1 : Type u\u2081} (F : J \u2192 \u03b1), (\u2200 (j\u2081 j\u2082 : J), (j\u2081 \u27f6 j\u2082) \u2192 F j\u2081 = F j\u2082) \u2192 \u2200 (j j' : J), F j = F j'", "decl_nm": "category_theory.constant_of_preserves_morphisms"}
{"formal_statement": "theorem discrete_sieve_apply (\u03b1 \u03b2 : Type u) (f : \u03b2 \u27f6 \u03b1) :\n\t\u21d1(category_theory.discrete_sieve \u03b1) f = \u2203 (x : \u03b1), \u2200 (y : \u03b2), f y = x", "decl_tp": "\u2200 (\u03b1 \u03b2 : Type u) (f : \u03b2 \u27f6 \u03b1), \u21d1(category_theory.discrete_sieve \u03b1) f = \u2203 (x : \u03b1), \u2200 (y : \u03b2), f y = x", "decl_nm": "category_theory.discrete_sieve_apply"}
{"formal_statement": "theorem is_normal_subgroup_ker {G H : Type*} [group G] [group H] {f : G \u2192 H}\n\t(hf : is_group_hom f) :\n\tis_normal_subgroup (is_group_hom.ker f)", "decl_tp": "\u2200 {G : Type u_1} {H : Type u_2} [_inst_1 : group G] [_inst_2 : group H] {f : G \u2192 H}, is_group_hom f \u2192 is_normal_subgroup (is_group_hom.ker f)", "decl_nm": "is_group_hom.is_normal_subgroup_ker"}
{"formal_statement": "theorem lift_\u03b9_assoc {C : Type u} [category_theory.category C] {X Y : C}\n\t{f g : X \u27f6 Y} [category_theory.limits.has_equalizer f g] {W : C} (k : W \u27f6 X)\n\t(h : k \u226b f = k \u226b g) {X' : C} (f' : X \u27f6 X') :\n\tcategory_theory.limits.equalizer.lift k h \u226b category_theory.limits.equalizer.\u03b9 f g \u226b f' = k \u226b f'", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] {X Y : C} {f g : X \u27f6 Y} [_inst_2 : category_theory.limits.has_equalizer f g] {W : C} (k : W \u27f6 X) (h : k \u226b f = k \u226b g) {X' : C} (f' : X \u27f6 X'), category_theory.limits.equalizer.lift k h \u226b category_theory.limits.equalizer.\u03b9 f g \u226b f' = k \u226b f'", "decl_nm": "category_theory.limits.equalizer.lift_\u03b9_assoc"}
{"formal_statement": "theorem lt_tsub_of_add_lt_left {\u03b1 : Type*} [canonically_ordered_add_monoid \u03b1]\n\t[has_sub \u03b1] [has_ordered_sub \u03b1] {a b c : \u03b1} (ha : add_le_cancellable a)\n\t(h : a + c < b) :\n\tc < b - a", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : canonically_ordered_add_monoid \u03b1] [_inst_2 : has_sub \u03b1] [_inst_3 : has_ordered_sub \u03b1] {a b c : \u03b1}, add_le_cancellable a \u2192 a + c < b \u2192 c < b - a", "decl_nm": "add_le_cancellable.lt_tsub_of_add_lt_left"}
{"formal_statement": "theorem preimage_equiv_eq_image_symm {\u03b1 \u03b2 : Type*} (S : set \u03b1) (f : \u03b2 \u2243 \u03b1) :\n\t\u21d1f \u207b\u00b9' S = \u21d1(f.symm) '' S", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} (S : set \u03b1) (f : \u03b2 \u2243 \u03b1), \u21d1f \u207b\u00b9' S = \u21d1(f.symm) '' S", "decl_nm": "set.preimage_equiv_eq_image_symm"}
{"formal_statement": "theorem localize {\u03b1 : Type u} {\u03b2 : Type v} [topological_space \u03b1] [preorder \u03b2]\n\t{f : \u03b1 \u2192 \u03b2} {s : set \u03b1} {a : \u03b1} (hf : is_max_on f s a) :\n\tis_local_max_on f s a", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : topological_space \u03b1] [_inst_2 : preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s : set \u03b1} {a : \u03b1}, is_max_on f s a \u2192 is_local_max_on f s a", "decl_nm": "is_max_on.localize"}
{"formal_statement": "theorem coe_snd {R S : Type*} [non_assoc_semiring R] [non_assoc_semiring S] :\n\t\u21d1(ring_hom.snd R S) = prod.snd", "decl_tp": "\u2200 {R : Type u_1} {S : Type u_3} [_inst_1 : non_assoc_semiring R] [_inst_2 : non_assoc_semiring S], \u21d1(ring_hom.snd R S) = prod.snd", "decl_nm": "ring_hom.coe_snd"}
{"formal_statement": "theorem diam_mono {\u03b1 : Type u} [pseudo_metric_space \u03b1] {s t : set \u03b1} (h : s \u2286 t)\n\t(ht : metric.bounded t) :\n\tmetric.diam s \u2264 metric.diam t", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : pseudo_metric_space \u03b1] {s t : set \u03b1}, s \u2286 t \u2192 metric.bounded t \u2192 metric.diam s \u2264 metric.diam t", "decl_nm": "metric.diam_mono"}
{"formal_statement": "theorem \u03b9_inj (R : Type*) [comm_semiring R] {M : Type*} [add_comm_monoid M]\n\t[module R M] (x y : M) :\n\t\u21d1(tensor_algebra.\u03b9 R) x = \u21d1(tensor_algebra.\u03b9 R) y \u2194 x = y", "decl_tp": "\u2200 (R : Type u_1) [_inst_1 : comm_semiring R] {M : Type u_2} [_inst_2 : add_comm_monoid M] [_inst_3 : module R M] (x y : M), \u21d1(tensor_algebra.\u03b9 R) x = \u21d1(tensor_algebra.\u03b9 R) y \u2194 x = y", "decl_nm": "tensor_algebra.\u03b9_inj"}
{"formal_statement": "theorem norm_nat (n : \u2115) :\n\t\u2225\u2191n\u2225 = \u2191n", "decl_tp": "\u2200 (n : \u2115), \u2225\u2191n\u2225 = \u2191n", "decl_nm": "complex.norm_nat"}
{"formal_statement": "theorem ext {R : Type u} [ring R] {S T : subring R} :\n\t(\u2200 (x : R), x \u2208 S \u2194 x \u2208 T) \u2192 S = T", "decl_tp": "\u2200 {R : Type u} [_inst_1 : ring R] {S T : subring R}, (\u2200 (x : R), x \u2208 S \u2194 x \u2208 T) \u2192 S = T", "decl_nm": "subring.ext"}
{"formal_statement": "theorem pre_le {X : Type*} [emetric_space X] {m : set X \u2192 ennreal} {r : ennreal}\n\t{s : set X} (hs : emetric.diam s \u2264 r) :\n\t\u21d1(measure_theory.outer_measure.mk_metric'.pre m r) s \u2264 m s", "decl_tp": "\u2200 {X : Type u_2} [_inst_1 : emetric_space X] {m : set X \u2192 ennreal} {r : ennreal} {s : set X}, emetric.diam s \u2264 r \u2192 \u21d1(measure_theory.outer_measure.mk_metric'.pre m r) s \u2264 m s", "decl_nm": "measure_theory.outer_measure.mk_metric'.pre_le"}
{"formal_statement": "theorem unique_diff_at_image {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c] {E : Type*}\n\t[normed_group E] [normed_space \ud835\udd5c E] {H : Type*} [topological_space H]\n\t(I : model_with_corners \ud835\udd5c E H) {x : H} :\n\tunique_diff_within_at \ud835\udd5c (set.range \u21d1I) (\u21d1I x)", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {H : Type u_3} [_inst_4 : topological_space H] (I : model_with_corners \ud835\udd5c E H) {x : H}, unique_diff_within_at \ud835\udd5c (set.range \u21d1I) (\u21d1I x)", "decl_nm": "model_with_corners.unique_diff_at_image"}
{"formal_statement": "theorem inv_div_left {G\u2080 : Type*} [group_with_zero G\u2080] {a b : G\u2080} :\n\ta\u207b\u00b9 / b = (b * a)\u207b\u00b9", "decl_tp": "\u2200 {G\u2080 : Type u_2} [_inst_1 : group_with_zero G\u2080] {a b : G\u2080}, a\u207b\u00b9 / b = (b * a)\u207b\u00b9", "decl_nm": "inv_div_left"}
{"formal_statement": "theorem limit_cone_comp_is_limit {C : Type v} [category_theory.small_category C]\n\t{D : Type v} [category_theory.small_category D] (F : C \u2964 D) [F.initial]\n\t{E : Type u} [category_theory.category E] {G : D \u2964 E} (t : category_theory.limits.limit_cone G) :\n\t(category_theory.functor.initial.limit_cone_comp F t).is_limit = \u21d1((category_theory.functor.initial.is_limit_whisker_equiv F t.cone).symm) t.is_limit", "decl_tp": "\u2200 {C : Type v} [_inst_1 : category_theory.small_category C] {D : Type v} [_inst_2 : category_theory.small_category D] (F : C \u2964 D) [_inst_3 : F.initial] {E : Type u} [_inst_4 : category_theory.category E] {G : D \u2964 E} (t : category_theory.limits.limit_cone G), (category_theory.functor.initial.limit_cone_comp F t).is_limit = \u21d1((category_theory.functor.initial.is_limit_whisker_equiv F t.cone).symm) t.is_limit", "decl_nm": "category_theory.functor.initial.limit_cone_comp_is_limit"}
{"formal_statement": "theorem le_seq {\u03b1 : Type u} {\u03b2 : Type v} {f : filter (\u03b1 \u2192 \u03b2)} {g : filter \u03b1}\n\t{h : filter \u03b2} :\n\t(\u2200 (t : set (\u03b1 \u2192 \u03b2)), t \u2208 f \u2192 \u2200 (u : set \u03b1), u \u2208 g \u2192 t.seq u \u2208 h) \u2192 h \u2264 f.seq g", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {f : filter (\u03b1 \u2192 \u03b2)} {g : filter \u03b1} {h : filter \u03b2}, (\u2200 (t : set (\u03b1 \u2192 \u03b2)), t \u2208 f \u2192 \u2200 (u : set \u03b1), u \u2208 g \u2192 t.seq u \u2208 h) \u2192 h \u2264 f.seq g", "decl_nm": "filter.le_seq"}
{"formal_statement": "theorem failure_eq_fail {\u03b1 : Type} {cb : char_buffer} {n n' : \u2115} {err : dlist string} :\n\tfailure cb n = parse_result.fail n' err \u2194 n = n' \u2227 err = dlist.empty", "decl_tp": "\u2200 {\u03b1 : Type} {cb : char_buffer} {n n' : \u2115} {err : dlist string}, failure cb n = parse_result.fail n' err \u2194 n = n' \u2227 err = dlist.empty", "decl_nm": "parser.failure_eq_fail"}
{"formal_statement": "theorem extend_along_yoneda_iso_Kan_app_inv {C : Type u\u2081} [category_theory.small_category C]\n\t{\u2130 : Type u\u2082} [category_theory.category \u2130] (A : C \u2964 \u2130) [category_theory.limits.has_colimits \u2130]\n\t(X : C\u1d52\u1d56 \u2964 Type u\u2081) :\n\t(category_theory.colimit_adj.extend_along_yoneda_iso_Kan_app A X).inv = category_theory.limits.colimit.pre ((category_theory.category_of_elements.\u03c0 X).left_op \u22d9 A)\n\t(category_theory.category_of_elements.costructured_arrow_yoneda_equivalence X).inverse", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.small_category C] {\u2130 : Type u\u2082} [_inst_2 : category_theory.category \u2130] (A : C \u2964 \u2130) [_inst_3 : category_theory.limits.has_colimits \u2130] (X : C\u1d52\u1d56 \u2964 Type u\u2081), (category_theory.colimit_adj.extend_along_yoneda_iso_Kan_app A X).inv = category_theory.limits.colimit.pre ((category_theory.category_of_elements.\u03c0 X).left_op \u22d9 A) (category_theory.category_of_elements.costructured_arrow_yoneda_equivalence X).inverse", "decl_nm": "category_theory.colimit_adj.extend_along_yoneda_iso_Kan_app_inv"}
{"formal_statement": "theorem ext_chart_at_symm_map_nhds_within {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c]\n\t{E : Type*} [normed_group E] [normed_space \ud835\udd5c E] {H : Type*} [topological_space H]\n\t(I : model_with_corners \ud835\udd5c E H) {M : Type*} [topological_space M] [charted_space H M]\n\t(x : M) {s : set M} :\n\tfilter.map \u21d1((ext_chart_at I x).symm) (nhds_within (\u21d1(ext_chart_at I x) x)\n\t(\u21d1((ext_chart_at I x).symm) \u207b\u00b9' s \u2229 set.range \u21d1I)) = nhds_within x s", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {H : Type u_3} [_inst_4 : topological_space H] (I : model_with_corners \ud835\udd5c E H) {M : Type u_4} [_inst_5 : topological_space M] [_inst_6 : charted_space H M] (x : M) {s : set M}, filter.map \u21d1((ext_chart_at I x).symm) (nhds_within (\u21d1(ext_chart_at I x) x) (\u21d1((ext_chart_at I x).symm) \u207b\u00b9' s \u2229 set.range \u21d1I)) = nhds_within x s", "decl_nm": "ext_chart_at_symm_map_nhds_within"}
{"formal_statement": "theorem zero_apply {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C]\n\t(\u03b2 : Type w) (X Y : category_theory.graded_object \u03b2 C) (b : \u03b2) :\n\t0 b = 0", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] [_inst_2 : category_theory.limits.has_zero_morphisms C] (\u03b2 : Type w) (X Y : category_theory.graded_object \u03b2 C) (b : \u03b2), 0 b = 0", "decl_nm": "category_theory.graded_object.zero_apply"}
{"formal_statement": "theorem connected_component_eq_univ {X : Type*} [topological_space X] [h : preconnected_space X]\n\t(x : X) :\n\tconnected_component x = set.univ", "decl_tp": "\u2200 {X : Type u_1} [_inst_2 : topological_space X] [h : preconnected_space X] (x : X), connected_component x = set.univ", "decl_nm": "preconnected_space.connected_component_eq_univ"}
{"formal_statement": "theorem lift_fst_assoc {C : Type u} [category_theory.category C] {W X Y Z : C}\n\t{f : X \u27f6 Z} {g : Y \u27f6 Z} [category_theory.limits.has_pullback f g] (h : W \u27f6 X)\n\t(k : W \u27f6 Y) (w : h \u226b f = k \u226b g) {X' : C} (f' : X \u27f6 X') :\n\tcategory_theory.limits.pullback.lift h k w \u226b category_theory.limits.pullback.fst \u226b f' = h \u226b f'", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] {W X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} [_inst_2 : category_theory.limits.has_pullback f g] (h : W \u27f6 X) (k : W \u27f6 Y) (w : h \u226b f = k \u226b g) {X' : C} (f' : X \u27f6 X'), category_theory.limits.pullback.lift h k w \u226b category_theory.limits.pullback.fst \u226b f' = h \u226b f'", "decl_nm": "category_theory.limits.pullback.lift_fst_assoc"}
{"formal_statement": "theorem deriv_cos' deriv real.cos = \u03bb (x : \u211d) :\n\t-real.sin x", "decl_tp": "deriv real.cos = \u03bb (x : \u211d), -real.sin x", "decl_nm": "real.deriv_cos'"}
{"formal_statement": "theorem mem_of_is_closed {\u03b1 : Type u} [topological_space \u03b1] [linear_order \u03b1]\n\t[order_topology \u03b1] {a : \u03b1} {s : set \u03b1} (ha : is_lub s a) (hs : s.nonempty)\n\t(sc : is_closed s) :\n\ta \u2208 s", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : topological_space \u03b1] [_inst_3 : linear_order \u03b1] [_inst_5 : order_topology \u03b1] {a : \u03b1} {s : set \u03b1}, is_lub s a \u2192 s.nonempty \u2192 is_closed s \u2192 a \u2208 s", "decl_nm": "is_lub.mem_of_is_closed"}
{"formal_statement": "theorem not_nhds_le_map {\u03b1 : Type u} {\u03b2 : Type v} [topological_space \u03b1]\n\t[preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s : set \u03b1} {a : \u03b1} [topological_space \u03b2] (hf : is_local_extr_on f s a) :\n\t\u2200 [(nhds_within (f a) (set.Iio (f a))).ne_bot] [(nhds_within (f a) (set.Ioi (f a))).ne_bot], \u00acnhds (f a) \u2264 filter.map f (nhds_within a s)", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : topological_space \u03b1] [_inst_2 : preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s : set \u03b1} {a : \u03b1} [_inst_4 : topological_space \u03b2], is_local_extr_on f s a \u2192 \u2200 [_inst_5 : (nhds_within (f a) (set.Iio (f a))).ne_bot] [_inst_6 : (nhds_within (f a) (set.Ioi (f a))).ne_bot], \u00acnhds (f a) \u2264 filter.map f (nhds_within a s)", "decl_nm": "is_local_extr_on.not_nhds_le_map"}
{"formal_statement": "theorem is_countably_generated_top {\u03b1 : Type*} :\n\t\u22a4.is_countably_generated", "decl_tp": "\u2200 {\u03b1 : Type u_1}, \u22a4.is_countably_generated", "decl_nm": "filter.is_countably_generated_top"}
{"formal_statement": "theorem union {\u03b1 : Type u} [topological_space \u03b1] {s t : set \u03b1} (hs : is_compact s)\n\t(ht : is_compact t) :\n\tis_compact (s \u222a t)", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : topological_space \u03b1] {s t : set \u03b1}, is_compact s \u2192 is_compact t \u2192 is_compact (s \u222a t)", "decl_nm": "is_compact.union"}
{"formal_statement": "theorem base_set_at {\u03b9 B F : Type*} [topological_space B] [topological_space F]\n\t(Z : topological_fiber_bundle_core \u03b9 B F) (i : \u03b9) :\n\tZ.base_set i = (Z.local_triv i).base_set", "decl_tp": "\u2200 {\u03b9 : Type u_1} {B : Type u_2} {F : Type u_3} [_inst_1 : topological_space B] [_inst_2 : topological_space F] (Z : topological_fiber_bundle_core \u03b9 B F) (i : \u03b9), Z.base_set i = (Z.local_triv i).base_set", "decl_nm": "topological_fiber_bundle_core.base_set_at"}
{"formal_statement": "theorem generate_pi_system_mono {\u03b1 : Type*} {S T : set (set \u03b1)} (hST : S \u2286 T) :\n\tgenerate_pi_system S \u2286 generate_pi_system T", "decl_tp": "\u2200 {\u03b1 : Type u_1} {S T : set (set \u03b1)}, S \u2286 T \u2192 generate_pi_system S \u2286 generate_pi_system T", "decl_nm": "generate_pi_system_mono"}
{"formal_statement": "theorem nil_suffix {\u03b1 : Type*} (l : list \u03b1) :\n\tlist.nil <:+ l", "decl_tp": "\u2200 {\u03b1 : Type u_1} (l : list \u03b1), list.nil <:+ l", "decl_nm": "list.nil_suffix"}
{"formal_statement": "theorem continuous_finsum {\u03b9 X M : Type*} [topological_space X] [topological_space M]\n\t[add_comm_monoid M] [has_continuous_add M] {f : \u03b9 \u2192 X \u2192 M} (hf : locally_finite (\u03bb (i : \u03b9), function.support (f i))) :\n\t(\u2200 (i : \u03b9), continuous (f i)) \u2192  continuous (\u03bb (x : X), finsum (\u03bb (i : \u03b9), f i x))", "decl_tp": "\u2200 {\u03b9 : Type u_1} {X : Type u_3} {M : Type u_4} [_inst_1 : topological_space X] [_inst_2 : topological_space M] [_inst_3 : add_comm_monoid M] [_inst_4 : has_continuous_add M] {f : \u03b9 \u2192 X \u2192 M}, (\u2200 (i : \u03b9), continuous (f i)) \u2192 locally_finite (\u03bb (i : \u03b9), function.support (f i)) \u2192 continuous (\u03bb (x : X), finsum (\u03bb (i : \u03b9), f i x))", "decl_nm": "continuous_finsum"}
{"formal_statement": "theorem tr_init (c : turing.to_partrec.code) (v : list \u2115) :\n\t\u2203 (b : turing.partrec_to_TM2.cfg'), turing.partrec_to_TM2.tr_cfg (turing.to_partrec.step_normal c turing.to_partrec.cont.halt v) b \u2227 turing.reaches\u2081 (turing.TM2.step turing.partrec_to_TM2.tr)\n\t(turing.partrec_to_TM2.init c v) b", "decl_tp": "\u2200 (c : turing.to_partrec.code) (v : list \u2115), \u2203 (b : turing.partrec_to_TM2.cfg'), turing.partrec_to_TM2.tr_cfg (turing.to_partrec.step_normal c turing.to_partrec.cont.halt v) b \u2227 turing.reaches\u2081 (turing.TM2.step turing.partrec_to_TM2.tr) (turing.partrec_to_TM2.init c v) b", "decl_nm": "turing.partrec_to_TM2.tr_init"}
{"formal_statement": "theorem exists_ne_zero_of_finsum_mem_ne_zero {\u03b1 M : Type*} [add_comm_monoid M]\n\t{f : \u03b1 \u2192 M} {s : set \u03b1} (h : finsum (\u03bb (i : \u03b1), finsum (\u03bb (H : i \u2208 s), f i)) \u2260 0) :\n\t(\u2203 (x : \u03b1) (H : x \u2208 s), f x \u2260 0)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {M : Type u_4} [_inst_1 : add_comm_monoid M] {f : \u03b1 \u2192 M} {s : set \u03b1}, finsum (\u03bb (i : \u03b1), finsum (\u03bb (H : i \u2208 s), f i)) \u2260 0 \u2192 (\u2203 (x : \u03b1) (H : x \u2208 s), f x \u2260 0)", "decl_nm": "exists_ne_zero_of_finsum_mem_ne_zero"}
{"formal_statement": "theorem single_eq_lof (R : Type u) [semiring R] {\u03b9 : Type v} [dec_\u03b9 : decidable_eq \u03b9]\n\t{M : \u03b9 \u2192 Type w} [\u03a0 (i : \u03b9), add_comm_monoid (M i)] [\u03a0 (i : \u03b9), module R (M i)]\n\t(i : \u03b9) (b : M i) :\n\tdfinsupp.single i b = \u21d1(direct_sum.lof R \u03b9 M i) b", "decl_tp": "\u2200 (R : Type u) [_inst_1 : semiring R] {\u03b9 : Type v} [dec_\u03b9 : decidable_eq \u03b9] {M : \u03b9 \u2192 Type w} [_inst_2 : \u03a0 (i : \u03b9), add_comm_monoid (M i)] [_inst_3 : \u03a0 (i : \u03b9), module R (M i)] (i : \u03b9) (b : M i), dfinsupp.single i b = \u21d1(direct_sum.lof R \u03b9 M i) b", "decl_nm": "direct_sum.single_eq_lof"}
{"formal_statement": "theorem head_supports {S : finset turing.partrec_to_TM2.\u039b'} {k : turing.partrec_to_TM2.K'}\n\t{q : turing.partrec_to_TM2.\u039b'} (H : turing.partrec_to_TM2.\u039b'.supports S q) :\n\tturing.partrec_to_TM2.\u039b'.supports S (turing.partrec_to_TM2.head k q)", "decl_tp": "\u2200 {S : finset turing.partrec_to_TM2.\u039b'} {k : turing.partrec_to_TM2.K'} {q : turing.partrec_to_TM2.\u039b'}, turing.partrec_to_TM2.\u039b'.supports S q \u2192 turing.partrec_to_TM2.\u039b'.supports S (turing.partrec_to_TM2.head k q)", "decl_nm": "turing.partrec_to_TM2.head_supports"}
{"formal_statement": "theorem mul_ker_mk_eq {M : Type*} [has_mul M] (c : con M) :\n\tcon.mul_ker coe _ = c", "decl_tp": "\u2200 {M : Type u_1} [_inst_1 : has_mul M] (c : con M), con.mul_ker coe _ = c", "decl_nm": "con.mul_ker_mk_eq"}
{"formal_statement": "theorem map_unique {\u03b1 : Type u} {\u03b2 : Type v} [uniform_space \u03b1] [uniform_space \u03b2]\n\t{f : \u03b1 \u2192 \u03b2} (hf : uniform_continuous f) (comm : quotient.mk \u2218 f = g \u2218 quotient.mk) :\n\t\u2200 {g : uniform_space.separation_quotient \u03b1 \u2192 uniform_space.separation_quotient \u03b2},  uniform_space.separation_quotient.map f = g", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : uniform_space \u03b1] [_inst_2 : uniform_space \u03b2] {f : \u03b1 \u2192 \u03b2}, uniform_continuous f \u2192 \u2200 {g : uniform_space.separation_quotient \u03b1 \u2192 uniform_space.separation_quotient \u03b2}, quotient.mk \u2218 f = g \u2218 quotient.mk \u2192 uniform_space.separation_quotient.map f = g", "decl_nm": "uniform_space.separation_quotient.map_unique"}
{"formal_statement": "theorem le_sqrt {m n : \u2115} :\n\tm \u2264 nat.sqrt n \u2194 m * m \u2264 n", "decl_tp": "\u2200 {m n : \u2115}, m \u2264 nat.sqrt n \u2194 m * m \u2264 n", "decl_nm": "nat.le_sqrt"}
{"formal_statement": "theorem Union_true {\u03b1 : Type*} {s : true \u2192 set \u03b1} :\n\tset.Union s = s trivial", "decl_tp": "\u2200 {\u03b1 : Type u_1} {s : true \u2192 set \u03b1}, set.Union s = s trivial", "decl_nm": "set.Union_true"}
{"formal_statement": "theorem forall_le_or_exists_lt_sup {\u03b1 : Type u} [semilattice_sup \u03b1] (a : \u03b1) :\n\t(\u2200 (b : \u03b1), b \u2264 a) \u2228 \u2203 (b : \u03b1), a < b", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : semilattice_sup \u03b1] (a : \u03b1), (\u2200 (b : \u03b1), b \u2264 a) \u2228 \u2203 (b : \u03b1), a < b", "decl_nm": "forall_le_or_exists_lt_sup"}
{"formal_statement": "theorem nhds_eq_nhds_emetric_ball {\u03b2 : Type*} [emetric_space \u03b2] (a x : \u03b2)\n\t(r : ennreal) (h : x \u2208 emetric.ball a r) :\n\tnhds x = filter.map coe (nhds \u27e8x, h\u27e9)", "decl_tp": "\u2200 {\u03b2 : Type u_2} [_inst_1 : emetric_space \u03b2] (a x : \u03b2) (r : ennreal) (h : x \u2208 emetric.ball a r), nhds x = filter.map coe (nhds \u27e8x, h\u27e9)", "decl_nm": "nhds_eq_nhds_emetric_ball"}
{"formal_statement": "theorem empty_product {\u03b1 \u03b2 : Type*} (t : finset \u03b2) :\n\t\u2205.product t = \u2205", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} (t : finset \u03b2), \u2205.product t = \u2205", "decl_nm": "finset.empty_product"}
{"formal_statement": "theorem diagonal_mul_diagonal' {n : Type*} {\u03b1 : Type v} [non_unital_non_assoc_semiring \u03b1]\n\t[fintype n] [decidable_eq n] (d\u2081 d\u2082 : n \u2192 \u03b1) :\n\tmatrix.diagonal d\u2081 * matrix.diagonal d\u2082 = matrix.diagonal (\u03bb (i : n), d\u2081 i * d\u2082 i)", "decl_tp": "\u2200 {n : Type u_3} {\u03b1 : Type v} [_inst_1 : non_unital_non_assoc_semiring \u03b1] [_inst_2 : fintype n] [_inst_3 : decidable_eq n] (d\u2081 d\u2082 : n \u2192 \u03b1), matrix.diagonal d\u2081 * matrix.diagonal d\u2082 = matrix.diagonal (\u03bb (i : n), d\u2081 i * d\u2082 i)", "decl_nm": "matrix.diagonal_mul_diagonal'"}
{"formal_statement": "theorem compares_swap {\u03b1 : Type*} [has_lt \u03b1] {a b : \u03b1} {o : ordering} :\n\to.swap.compares a b \u2194 o.compares b a", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : has_lt \u03b1] {a b : \u03b1} {o : ordering}, o.swap.compares a b \u2194 o.compares b a", "decl_nm": "ordering.compares_swap"}
{"formal_statement": "theorem decode\u2082 {\u03b1 : Type*} [primcodable \u03b1] :\n\tprimrec (encodable.decode\u2082 \u03b1)", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : primcodable \u03b1], primrec (encodable.decode\u2082 \u03b1)", "decl_nm": "primrec.decode\u2082"}
{"formal_statement": "theorem chain_iff_pairwise {\u03b1 : Type u} {R : \u03b1 \u2192 \u03b1 \u2192 Prop} (tr : transitive R) :\n\t\u2200 {a : \u03b1} {l : list \u03b1}, list.chain R a l \u2194 list.pairwise R (a :: l)", "decl_tp": "\u2200 {\u03b1 : Type u} {R : \u03b1 \u2192 \u03b1 \u2192 Prop}, transitive R \u2192 \u2200 {a : \u03b1} {l : list \u03b1}, list.chain R a l \u2194 list.pairwise R (a :: l)", "decl_nm": "list.chain_iff_pairwise"}
{"formal_statement": "theorem deriv_pi {\ud835\udd5c : Type u} [nondiscrete_normed_field \ud835\udd5c] {x : \ud835\udd5c} {\u03b9 : Type*}\n\t[fintype \u03b9] {E' : \u03b9 \u2192 Type*} [\u03a0 (i : \u03b9), normed_group (E' i)] [\u03a0 (i : \u03b9), normed_space \ud835\udd5c (E' i)]\n\t{\u03c6 : \ud835\udd5c \u2192 \u03a0 (i : \u03b9), E' i} :\n\t(\u2200 (i : \u03b9), differentiable_at \ud835\udd5c (\u03bb (x : \ud835\udd5c), \u03c6 x i) x) \u2192 (deriv \u03c6 x = \u03bb (i : \u03b9), deriv (\u03bb (x : \ud835\udd5c), \u03c6 x i) x)", "decl_tp": "\u2200 {\ud835\udd5c : Type u} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {x : \ud835\udd5c} {\u03b9 : Type u_1} [_inst_6 : fintype \u03b9] {E' : \u03b9 \u2192 Type u_2} [_inst_7 : \u03a0 (i : \u03b9), normed_group (E' i)] [_inst_8 : \u03a0 (i : \u03b9), normed_space \ud835\udd5c (E' i)] {\u03c6 : \ud835\udd5c \u2192 \u03a0 (i : \u03b9), E' i}, (\u2200 (i : \u03b9), differentiable_at \ud835\udd5c (\u03bb (x : \ud835\udd5c), \u03c6 x i) x) \u2192 (deriv \u03c6 x = \u03bb (i : \u03b9), deriv (\u03bb (x : \ud835\udd5c), \u03c6 x i) x)", "decl_nm": "deriv_pi"}
{"formal_statement": "theorem prod_zero {\u03b1 : Type*} [comm_monoid \u03b1] :\n\t0.prod = 1", "decl_tp": "\u2200 {\u03b1 : Type u_2} [_inst_1 : comm_monoid \u03b1], 0.prod = 1", "decl_nm": "multiset.prod_zero"}
{"formal_statement": "theorem eq_singleton {\u03b1 : Type uu} {a : \u03b1} {l : list \u03b1} (p : l ~ [a]) :\n\tl = [a]", "decl_tp": "\u2200 {\u03b1 : Type uu} {a : \u03b1} {l : list \u03b1}, l ~ [a] \u2192 l = [a]", "decl_nm": "list.perm.eq_singleton"}
{"formal_statement": "theorem arccos_eq_pi_div_two {x : \u211d} :\n\treal.arccos x = real.pi / 2 \u2194 x = 0", "decl_tp": "\u2200 {x : \u211d}, real.arccos x = real.pi / 2 \u2194 x = 0", "decl_nm": "real.arccos_eq_pi_div_two"}
{"formal_statement": "theorem le_add_right {\u03b1 : Type*} (s t : multiset \u03b1) :\n\ts \u2264 s + t", "decl_tp": "\u2200 {\u03b1 : Type u_1} (s t : multiset \u03b1), s \u2264 s + t", "decl_nm": "multiset.le_add_right"}
{"formal_statement": "theorem even_or_odd' (n : \u2124) :\n\t\u2203 (k : \u2124), n = 2 * k \u2228 n = 2 * k + 1", "decl_tp": "\u2200 (n : \u2124), \u2203 (k : \u2124), n = 2 * k \u2228 n = 2 * k + 1", "decl_nm": "int.even_or_odd'"}
{"formal_statement": "theorem uncurry_curry {C : Type u} [category_theory.category C] {A X Y : C}\n\t[category_theory.limits.has_finite_products C] [category_theory.exponentiable A]\n\t(f : A \u2a2f X \u27f6 Y) :\n\tcategory_theory.cartesian_closed.uncurry (category_theory.cartesian_closed.curry f) = f", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] {A X Y : C} [_inst_2 : category_theory.limits.has_finite_products C] [_inst_3 : category_theory.exponentiable A] (f : A \u2a2f X \u27f6 Y), category_theory.cartesian_closed.uncurry (category_theory.cartesian_closed.curry f) = f", "decl_nm": "category_theory.cartesian_closed.uncurry_curry"}
{"formal_statement": "theorem map_top {\u03b1 \u03b2 : Type*} [has_le \u03b1] [partial_order \u03b2] [order_top \u03b1]\n\t[order_top \u03b2] (f : \u03b1 \u2243o \u03b2) :\n\t\u21d1f \u22a4 = \u22a4", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : has_le \u03b1] [_inst_2 : partial_order \u03b2] [_inst_3 : order_top \u03b1] [_inst_4 : order_top \u03b2] (f : \u03b1 \u2243o \u03b2), \u21d1f \u22a4 = \u22a4", "decl_nm": "order_iso.map_top"}
{"formal_statement": "theorem inf_edist_zero_of_mem {\u03b1 : Type u} [pseudo_emetric_space \u03b1] {x : \u03b1}\n\t{s : set \u03b1} (h : x \u2208 s) :\n\temetric.inf_edist x s = 0", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : pseudo_emetric_space \u03b1] {x : \u03b1} {s : set \u03b1}, x \u2208 s \u2192 emetric.inf_edist x s = 0", "decl_nm": "emetric.inf_edist_zero_of_mem"}
{"formal_statement": "theorem flip_obj_obj {C : Type u\u2081} [category_theory.category C] {D : Type u\u2082}\n\t[category_theory.category D] {E : Type u\u2083} [category_theory.category E]\n\t(F : C \u2964 D \u2964 E) (c : C) (d : D) :\n\t(F.flip.obj d).obj c = (F.obj c).obj d", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {D : Type u\u2082} [_inst_2 : category_theory.category D] {E : Type u\u2083} [_inst_3 : category_theory.category E] (F : C \u2964 D \u2964 E) (c : C) (d : D), (F.flip.obj d).obj c = (F.obj c).obj d", "decl_nm": "category_theory.functor.flip_obj_obj"}
{"formal_statement": "theorem refl_extend {X : Type*} [topological_space X] {a : X} :\n\t(path.refl a).extend = \u03bb (_x : \u211d), a", "decl_tp": "\u2200 {X : Type u_1} [_inst_3 : topological_space X] {a : X}, (path.refl a).extend = \u03bb (_x : \u211d), a", "decl_nm": "path.refl_extend"}
{"formal_statement": "theorem cauchy_seq_of_le_geometric_two {\u03b1 : Type*} [pseudo_metric_space \u03b1]\n\t(C : \u211d) {f : \u2115 \u2192 \u03b1} :\n\t(\u2200 (n : \u2115), has_dist.dist (f n) (f (n + 1)) \u2264 C / 2 / 2 ^ n) \u2192 cauchy_seq f", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : pseudo_metric_space \u03b1] (C : \u211d) {f : \u2115 \u2192 \u03b1}, (\u2200 (n : \u2115), has_dist.dist (f n) (f (n + 1)) \u2264 C / 2 / 2 ^ n) \u2192 cauchy_seq f", "decl_nm": "cauchy_seq_of_le_geometric_two"}
{"formal_statement": "theorem tsub_eq_zero_of_le {\u03b1 : Type*} [canonically_ordered_add_monoid \u03b1]\n\t[has_sub \u03b1] [has_ordered_sub \u03b1] {a b : \u03b1} (h : a \u2264 b) :\n\ta - b = 0", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : canonically_ordered_add_monoid \u03b1] [_inst_2 : has_sub \u03b1] [_inst_3 : has_ordered_sub \u03b1] {a b : \u03b1}, a \u2264 b \u2192 a - b = 0", "decl_nm": "tsub_eq_zero_of_le"}
{"formal_statement": "theorem proj_coe {E : Type*} [normed_group E] [normed_space \u211d E] (v : picard_lindelof E)\n\t(t : \u21a5(set.Icc v.t_min v.t_max)) :\n\tv.proj \u2191t = t", "decl_tp": "\u2200 {E : Type u_1} [_inst_1 : normed_group E] [_inst_2 : normed_space \u211d E] (v : picard_lindelof E) (t : \u21a5(set.Icc v.t_min v.t_max)), v.proj \u2191t = t", "decl_nm": "picard_lindelof.proj_coe"}
{"formal_statement": "theorem prod_trans {\u03b1 \u03b2 \u03b3 \u03b4 : Type*} [topological_space \u03b1] [topological_space \u03b2]\n\t[topological_space \u03b3] [topological_space \u03b4] {\u03b7 \u03b5 : Type*} [topological_space \u03b7]\n\t[topological_space \u03b5] (e : local_homeomorph \u03b1 \u03b2) (f : local_homeomorph \u03b2 \u03b3)\n\t(e' : local_homeomorph \u03b4 \u03b7) (f' : local_homeomorph \u03b7 \u03b5) :\n\t(e.prod e').trans (f.prod f') = (e.trans f).prod (e'.trans f')", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {\u03b3 : Type u_3} {\u03b4 : Type u_4} [_inst_1 : topological_space \u03b1] [_inst_2 : topological_space \u03b2] [_inst_3 : topological_space \u03b3] [_inst_4 : topological_space \u03b4] {\u03b7 : Type u_5} {\u03b5 : Type u_6} [_inst_5 : topological_space \u03b7] [_inst_6 : topological_space \u03b5] (e : local_homeomorph \u03b1 \u03b2) (f : local_homeomorph \u03b2 \u03b3) (e' : local_homeomorph \u03b4 \u03b7) (f' : local_homeomorph \u03b7 \u03b5), (e.prod e').trans (f.prod f') = (e.trans f).prod (e'.trans f')", "decl_nm": "local_homeomorph.prod_trans"}
{"formal_statement": "theorem tendsto_at_top {\u03b1 \u03b2 : Type*} [preorder \u03b2] {m : \u03b1 \u2192 \u03b2} {f : filter \u03b1} :\n\tfilter.tendsto m f filter.at_top \u2194 \u2200 (b : \u03b2), \u2200\u1da0 (a : \u03b1) in f, b \u2264 m a", "decl_tp": "\u2200 {\u03b1 : Type u_3} {\u03b2 : Type u_4} [_inst_1 : preorder \u03b2] {m : \u03b1 \u2192 \u03b2} {f : filter \u03b1}, filter.tendsto m f filter.at_top \u2194 \u2200 (b : \u03b2), \u2200\u1da0 (a : \u03b1) in f, b \u2264 m a", "decl_nm": "filter.tendsto_at_top"}
{"formal_statement": "theorem inf_sup {\u03b1 : Type u} [distrib_lattice \u03b1] [bounded_order \u03b1] {x y x' y' : \u03b1}\n\t(h : is_compl x y) (h' : is_compl x' y') :\n\tis_compl (x \u2293 x') (y \u2294 y')", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : distrib_lattice \u03b1] [_inst_2 : bounded_order \u03b1] {x y x' y' : \u03b1}, is_compl x y \u2192 is_compl x' y' \u2192 is_compl (x \u2293 x') (y \u2294 y')", "decl_nm": "is_compl.inf_sup"}
{"formal_statement": "theorem mul_sub_right_distrib {\u03b1 : Type u} [ring \u03b1] (a b c : \u03b1) :\n\t(a - b) * c = a * c - b * c", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : ring \u03b1] (a b c : \u03b1), (a - b) * c = a * c - b * c", "decl_nm": "mul_sub_right_distrib"}
{"formal_statement": "theorem cexp {f : \u2102 \u2192 \u2102} {f' x : \u2102} (hf : has_strict_deriv_at f f' x) :\n\thas_strict_deriv_at (\u03bb (x : \u2102), complex.exp (f x)) (complex.exp (f x) * f') x", "decl_tp": "\u2200 {f : \u2102 \u2192 \u2102} {f' x : \u2102}, has_strict_deriv_at f f' x \u2192 has_strict_deriv_at (\u03bb (x : \u2102), complex.exp (f x)) (complex.exp (f x) * f') x", "decl_nm": "has_strict_deriv_at.cexp"}
{"formal_statement": "theorem iso_zero_of_epi_zero_inv {C : Type u} [category_theory.category C]\n\t[category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C]\n\t{X Y : C} (h : category_theory.epi 0) :\n\t(category_theory.limits.iso_zero_of_epi_zero h).inv = 0", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] [_inst_2 : category_theory.limits.has_zero_object C] [_inst_3 : category_theory.limits.has_zero_morphisms C] {X Y : C} (h : category_theory.epi 0), (category_theory.limits.iso_zero_of_epi_zero h).inv = 0", "decl_nm": "category_theory.limits.iso_zero_of_epi_zero_inv"}
{"formal_statement": "theorem to_perm_symm_apply {\u03b1 : Type u} {\u03b2 : Type v} [group \u03b1] [mul_action \u03b1 \u03b2]\n\t(a : \u03b1) (x : \u03b2) :\n\t\u21d1(equiv.symm (mul_action.to_perm a)) x = a\u207b\u00b9 \u2022 x", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : group \u03b1] [_inst_2 : mul_action \u03b1 \u03b2] (a : \u03b1) (x : \u03b2), \u21d1(equiv.symm (mul_action.to_perm a)) x = a\u207b\u00b9 \u2022 x", "decl_nm": "mul_action.to_perm_symm_apply"}
{"formal_statement": "theorem fin_congr_apply_mk {n m : \u2115} (h : n = m) (k : \u2115) (w : k < n) :\n\t\u21d1(fin_congr h) \u27e8k, w\u27e9 = \u27e8k, _\u27e9", "decl_tp": "\u2200 {n m : \u2115} (h : n = m) (k : \u2115) (w : k < n), \u21d1(fin_congr h) \u27e8k, w\u27e9 = \u27e8k, _\u27e9", "decl_nm": "fin_congr_apply_mk"}
{"formal_statement": "theorem ite_eq_right_iff {\u03b1 : Sort u_1} {P : Prop} [decidable P] {a b : \u03b1} :\n\tite P a b = b \u2194 P \u2192 a = b", "decl_tp": "\u2200 {\u03b1 : Sort u_1} {P : Prop} [_inst_1 : decidable P] {a b : \u03b1}, ite P a b = b \u2194 P \u2192 a = b", "decl_nm": "ite_eq_right_iff"}
{"formal_statement": "theorem next_mem {\u03b1 : Type*} [decidable_eq \u03b1] (l : list \u03b1) (x : \u03b1) (h : x \u2208 l) :\n\tl.next x h \u2208 l", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : decidable_eq \u03b1] (l : list \u03b1) (x : \u03b1) (h : x \u2208 l), l.next x h \u2208 l", "decl_nm": "list.next_mem"}
{"formal_statement": "theorem continuous_iff' {\u03b1 : Type u} {\u03b2 : Type v} [pseudo_metric_space \u03b1]\n\t[topological_space \u03b2] {f : \u03b2 \u2192 \u03b1} :\n\tcontinuous f \u2194 \u2200 (a : \u03b2) (\u03b5 : \u211d), \u03b5 > 0 \u2192 (\u2200\u1da0 (x : \u03b2) in nhds a, has_dist.dist (f x)\n\t(f a) < \u03b5)", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : pseudo_metric_space \u03b1] [_inst_2 : topological_space \u03b2] {f : \u03b2 \u2192 \u03b1}, continuous f \u2194 \u2200 (a : \u03b2) (\u03b5 : \u211d), \u03b5 > 0 \u2192 (\u2200\u1da0 (x : \u03b2) in nhds a, has_dist.dist (f x) (f a) < \u03b5)", "decl_nm": "metric.continuous_iff'"}
{"formal_statement": "theorem coe_neg {R : Type*} [comm_ring R] {c\u2081 c\u2082 : R} (x : R) :\n\t\u2191-x = -\u2191x", "decl_tp": "\u2200 {R : Type u_1} [_inst_1 : comm_ring R] {c\u2081 c\u2082 : R} (x : R), \u2191-x = -\u2191x", "decl_nm": "quaternion_algebra.coe_neg"}
{"formal_statement": "theorem mem_dom {\u03b1 \u03b2 : Type*} (f : \u03b1 \u2192. \u03b2) (x : \u03b1) :\n\tx \u2208 f.dom \u2194 \u2203 (y : \u03b2), y \u2208 f x", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} (f : \u03b1 \u2192. \u03b2) (x : \u03b1), x \u2208 f.dom \u2194 \u2203 (y : \u03b2), y \u2208 f x", "decl_nm": "pfun.mem_dom"}
{"formal_statement": "theorem fst_linear {k V1 P1 V2 P2 : Type*} [ring k] [add_comm_group V1]\n\t[module k V1] [add_torsor V1 P1] [add_comm_group V2] [module k V2] [add_torsor V2 P2] :\n\taffine_map.fst.linear = linear_map.fst k V1 V2", "decl_tp": "\u2200 {k : Type u_1} {V1 : Type u_2} {P1 : Type u_3} {V2 : Type u_4} {P2 : Type u_5} [_inst_1 : ring k] [_inst_2 : add_comm_group V1] [_inst_3 : module k V1] [_inst_4 : add_torsor V1 P1] [_inst_5 : add_comm_group V2] [_inst_6 : module k V2] [_inst_7 : add_torsor V2 P2], affine_map.fst.linear = linear_map.fst k V1 V2", "decl_nm": "affine_map.fst_linear"}
{"formal_statement": "theorem tsum_add {\u03b1 \u03b2 : Type*} [add_comm_monoid \u03b1] [topological_space \u03b1]\n\t[t2_space \u03b1] {f g : \u03b2 \u2192 \u03b1} [has_continuous_add \u03b1] (hf : summable f) (hg : summable g) :\n\t\u2211' (b : \u03b2), (f b + g b) = \u2211' (b : \u03b2), f b + \u2211' (b : \u03b2), g b", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : add_comm_monoid \u03b1] [_inst_2 : topological_space \u03b1] [_inst_3 : t2_space \u03b1] {f g : \u03b2 \u2192 \u03b1} [_inst_4 : has_continuous_add \u03b1], summable f \u2192 summable g \u2192 \u2211' (b : \u03b2), (f b + g b) = \u2211' (b : \u03b2), f b + \u2211' (b : \u03b2), g b", "decl_nm": "tsum_add"}
{"formal_statement": "theorem log_pos_iff {x : \u211d} (hx : 0 < x) :\n\t(0 < real.log x \u2194 1 < x)", "decl_tp": "\u2200 {x : \u211d}, 0 < x \u2192 (0 < real.log x \u2194 1 < x)", "decl_nm": "real.log_pos_iff"}
{"formal_statement": "theorem univ_map_equiv_to_embedding {\u03b1 \u03b2 : Type*} [fintype \u03b1] [fintype \u03b2]\n\t(e : \u03b1 \u2243 \u03b2) :\n\tfinset.map e.to_embedding finset.univ = finset.univ", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_2 : fintype \u03b1] [_inst_3 : fintype \u03b2] (e : \u03b1 \u2243 \u03b2), finset.map e.to_embedding finset.univ = finset.univ", "decl_nm": "finset.univ_map_equiv_to_embedding"}
{"formal_statement": "theorem pairwise_disjoint_fiber {\u03b1 \u03b9 : Type*} (f : \u03b9 \u2192 \u03b1) :\n\tpairwise (disjoint on \u03bb (a : \u03b1), f \u207b\u00b9' {a})", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b9 : Type u_2} (f : \u03b9 \u2192 \u03b1), pairwise (disjoint on \u03bb (a : \u03b1), f \u207b\u00b9' {a})", "decl_nm": "pairwise_disjoint_fiber"}
{"formal_statement": "theorem sqrt_one :\n\treal.sqrt 1 = 1", "decl_tp": "real.sqrt 1 = 1", "decl_nm": "real.sqrt_one"}
{"formal_statement": "theorem sum_inl {\u03b1 \u03b2 : Type*} [primcodable \u03b1] [primcodable \u03b2] :\n\tprimrec sum.inl", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : primcodable \u03b1] [_inst_2 : primcodable \u03b2], primrec sum.inl", "decl_nm": "primrec.sum_inl"}
{"formal_statement": "theorem all_balance_r {\u03b1 : Type*} {P : \u03b1 \u2192 Prop} {l : ordnode \u03b1} {x : \u03b1}\n\t{r : ordnode \u03b1} (hl : l.balanced) (hr : r.balanced) (sl : l.sized) (sr : r.sized) :\n\t((\u2203 (l' : \u2115), ordnode.raised l.size l' \u2227 ordnode.balanced_sz l' r.size) \u2228 \u2203 (r' : \u2115), ordnode.raised r' r.size \u2227 ordnode.balanced_sz l.size r') \u2192 (ordnode.all P (l.balance_r x r) \u2194 ordnode.all P l \u2227 P x \u2227 ordnode.all P r)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {P : \u03b1 \u2192 Prop} {l : ordnode \u03b1} {x : \u03b1} {r : ordnode \u03b1}, l.balanced \u2192 r.balanced \u2192 l.sized \u2192 r.sized \u2192 ((\u2203 (l' : \u2115), ordnode.raised l.size l' \u2227 ordnode.balanced_sz l' r.size) \u2228 \u2203 (r' : \u2115), ordnode.raised r' r.size \u2227 ordnode.balanced_sz l.size r') \u2192 (ordnode.all P (l.balance_r x r) \u2194 ordnode.all P l \u2227 P x \u2227 ordnode.all P r)", "decl_nm": "ordnode.all_balance_r"}
{"formal_statement": "theorem add_even {m n : \u2124} (hm : even m) (hn : even n) :\n\teven (m + n)", "decl_tp": "\u2200 {m n : \u2124}, even m \u2192 even n \u2192 even (m + n)", "decl_nm": "int.even.add_even"}
{"formal_statement": "theorem mk_hom_eq_self {C : Type u\u2081} [category_theory.category C] {D : Type u\u2082}\n\t[category_theory.category D] {S : D} {Y : C} {T : C \u2964 D} (f : S \u27f6 T.obj Y) :\n\t(category_theory.structured_arrow.mk f).hom = f", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {D : Type u\u2082} [_inst_2 : category_theory.category D] {S : D} {Y : C} {T : C \u2964 D} (f : S \u27f6 T.obj Y), (category_theory.structured_arrow.mk f).hom = f", "decl_nm": "category_theory.structured_arrow.mk_hom_eq_self"}
{"formal_statement": "theorem mul_left_symm {G : Type*} [group G] (a : G) :\n\tequiv.symm (equiv.mul_left a) = equiv.mul_left a\u207b\u00b9", "decl_tp": "\u2200 {G : Type u_7} [_inst_1 : group G] (a : G), equiv.symm (equiv.mul_left a) = equiv.mul_left a\u207b\u00b9", "decl_nm": "equiv.mul_left_symm"}
{"formal_statement": "theorem coe_zero {\u03b9 : Type u} {\u03b2 : \u03b9 \u2192 Type v} [\u03a0 (i : \u03b9), has_zero (\u03b2 i)] :\n\t\u21d10 = 0", "decl_tp": "\u2200 {\u03b9 : Type u} {\u03b2 : \u03b9 \u2192 Type v} [_inst_1 : \u03a0 (i : \u03b9), has_zero (\u03b2 i)], \u21d10 = 0", "decl_nm": "dfinsupp.coe_zero"}
{"formal_statement": "theorem coeff_rescale {R : Type*} [comm_semiring R] (f : power_series R)\n\t(a : R) (n : \u2115) :\n\t\u21d1(power_series.coeff R n) (\u21d1(power_series.rescale a) f) = a ^ n * \u21d1(power_series.coeff R n) f", "decl_tp": "\u2200 {R : Type u_1} [_inst_1 : comm_semiring R] (f : power_series R) (a : R) (n : \u2115), \u21d1(power_series.coeff R n) (\u21d1(power_series.rescale a) f) = a ^ n * \u21d1(power_series.coeff R n) f", "decl_nm": "power_series.coeff_rescale"}
{"formal_statement": "theorem has_fpower_series_at_exp_zero_of_radius_pos {\ud835\udd42 \ud835\udd38 : Type*} [nondiscrete_normed_field \ud835\udd42]\n\t[normed_ring \ud835\udd38] [normed_algebra \ud835\udd42 \ud835\udd38] [complete_space \ud835\udd38] (h : 0 < (exp_series \ud835\udd42 \ud835\udd38).radius) :\n\thas_fpower_series_at (exp \ud835\udd42 \ud835\udd38) (exp_series \ud835\udd42 \ud835\udd38) 0", "decl_tp": "\u2200 {\ud835\udd42 : Type u_1} {\ud835\udd38 : Type u_2} [_inst_1 : nondiscrete_normed_field \ud835\udd42] [_inst_2 : normed_ring \ud835\udd38] [_inst_3 : normed_algebra \ud835\udd42 \ud835\udd38] [_inst_4 : complete_space \ud835\udd38], 0 < (exp_series \ud835\udd42 \ud835\udd38).radius \u2192 has_fpower_series_at (exp \ud835\udd42 \ud835\udd38) (exp_series \ud835\udd42 \ud835\udd38) 0", "decl_nm": "has_fpower_series_at_exp_zero_of_radius_pos"}
{"formal_statement": "theorem is_supported_upwards {\u03b1 : Type u} {x : free_comm_ring \u03b1} {s t : set \u03b1}\n\t(hs : x.is_supported s) (hst : s \u2286 t) :\n\tx.is_supported t", "decl_tp": "\u2200 {\u03b1 : Type u} {x : free_comm_ring \u03b1} {s t : set \u03b1}, x.is_supported s \u2192 s \u2286 t \u2192 x.is_supported t", "decl_nm": "free_comm_ring.is_supported_upwards"}
{"formal_statement": "theorem card {n : \u2115} [fact (0 < n)] :\n\tfintype.card (dihedral_group n) = 2 * n", "decl_tp": "\u2200 {n : \u2115} [_inst_1 : fact (0 < n)], fintype.card (dihedral_group n) = 2 * n", "decl_nm": "dihedral_group.card"}
{"formal_statement": "theorem invertible_equiv_det_invertible_symm_apply {n : Type u} [decidable_eq n]\n\t[fintype n] {\u03b1 : Type v} [comm_ring \u03b1] (A : matrix n n \u03b1) [invertible A.det] :\n\t\u21d1(A.invertible_equiv_det_invertible.symm) _inst_4 = A.invertible_of_det_invertible", "decl_tp": "\u2200 {n : Type u} [_inst_1 : decidable_eq n] [_inst_2 : fintype n] {\u03b1 : Type v} [_inst_3 : comm_ring \u03b1] (A : matrix n n \u03b1) [_inst_4 : invertible A.det], \u21d1(A.invertible_equiv_det_invertible.symm) _inst_4 = A.invertible_of_det_invertible", "decl_nm": "matrix.invertible_equiv_det_invertible_symm_apply"}
{"formal_statement": "theorem filter_map_some {\u03b1 : Type*} (s : multiset \u03b1) :\n\tmultiset.filter_map option.some s = s", "decl_tp": "\u2200 {\u03b1 : Type u_1} (s : multiset \u03b1), multiset.filter_map option.some s = s", "decl_nm": "multiset.filter_map_some"}
{"formal_statement": "theorem image_union {\u03b1 : Type u} {\u03b2 : Type v} (f : \u03b1 \u2192 \u03b2) (s t : set \u03b1) :\n\tf '' (s \u222a t) = f '' s \u222a f '' t", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} (f : \u03b1 \u2192 \u03b2) (s t : set \u03b1), f '' (s \u222a t) = f '' s \u222a f '' t", "decl_nm": "set.image_union"}
{"formal_statement": "theorem disjoint_comm {\u03b1 : Type*} {l\u2081 l\u2082 : list \u03b1} :\n\tl\u2081.disjoint l\u2082 \u2194 l\u2082.disjoint l\u2081", "decl_tp": "\u2200 {\u03b1 : Type u_1} {l\u2081 l\u2082 : list \u03b1}, l\u2081.disjoint l\u2082 \u2194 l\u2082.disjoint l\u2081", "decl_nm": "list.disjoint_comm"}
{"formal_statement": "theorem heq_iff_coe_eq {\u03b1 : Sort u_1} {p q : \u03b1 \u2192 Prop} :\n\t(\u2200 (x : \u03b1), p x \u2194 q x) \u2192 \u2200 {a1 : {x // p x}} {a2 : {x // q x}}, a1 == a2 \u2194 \u2191a1 = \u2191a2", "decl_tp": "\u2200 {\u03b1 : Sort u_1} {p q : \u03b1 \u2192 Prop}, (\u2200 (x : \u03b1), p x \u2194 q x) \u2192 \u2200 {a1 : {x // p x}} {a2 : {x // q x}}, a1 == a2 \u2194 \u2191a1 = \u2191a2", "decl_nm": "subtype.heq_iff_coe_eq"}
{"formal_statement": "theorem is_localization_iff_of_ring_equiv {R : Type*} [comm_ring R] (M : submonoid R)\n\t{S : Type*} [comm_ring S] [algebra R S] {P : Type*} [comm_ring P] (h : S \u2243+* P) :\n\tis_localization M S \u2194 is_localization M P", "decl_tp": "\u2200 {R : Type u_1} [_inst_1 : comm_ring R] (M : submonoid R) {S : Type u_2} [_inst_2 : comm_ring S] [_inst_3 : algebra R S] {P : Type u_3} [_inst_4 : comm_ring P] (h : S \u2243+* P), is_localization M S \u2194 is_localization M P", "decl_nm": "is_localization.is_localization_iff_of_ring_equiv"}
{"formal_statement": "theorem compl_set_of {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) :\n\t{a : \u03b1 | p a}\u1d9c = {a : \u03b1 | \u00acp a}", "decl_tp": "\u2200 {\u03b1 : Type u_1} (p : \u03b1 \u2192 Prop), {a : \u03b1 | p a}\u1d9c = {a : \u03b1 | \u00acp a}", "decl_nm": "set.compl_set_of"}
{"formal_statement": "theorem normal_iff {F K : Type*} [field F] [field K] [algebra F K] :\n\tnormal F K \u2194 \u2200 (x : K), is_integral F x \u2227 polynomial.splits (algebra_map F K)\n\t(minpoly F x)", "decl_tp": "\u2200 {F : Type u_1} {K : Type u_2} [_inst_1 : field F] [_inst_2 : field K] [_inst_3 : algebra F K], normal F K \u2194 \u2200 (x : K), is_integral F x \u2227 polynomial.splits (algebra_map F K) (minpoly F x)", "decl_nm": "normal_iff"}
{"formal_statement": "theorem cof_zero :\n\t0.cof = 0", "decl_tp": "0.cof = 0", "decl_nm": "ordinal.cof_zero"}
{"formal_statement": "theorem lin_mul_lin_comp_left {R\u2082 M\u2082 : Type*} [comm_semiring R\u2082] [add_comm_monoid M\u2082]\n\t[module R\u2082 M\u2082] {f g : M\u2082 \u2192\u2097[R\u2082] R\u2082} (l : M\u2082 \u2192\u2097[R\u2082] M\u2082) :\n\t(bilin_form.lin_mul_lin f g).comp_left l = bilin_form.lin_mul_lin (f.comp l) g", "decl_tp": "\u2200 {R\u2082 : Type u_5} {M\u2082 : Type u_6} [_inst_7 : comm_semiring R\u2082] [_inst_8 : add_comm_monoid M\u2082] [_inst_9 : module R\u2082 M\u2082] {f g : M\u2082 \u2192\u2097[R\u2082] R\u2082} (l : M\u2082 \u2192\u2097[R\u2082] M\u2082), (bilin_form.lin_mul_lin f g).comp_left l = bilin_form.lin_mul_lin (f.comp l) g", "decl_nm": "bilin_form.lin_mul_lin_comp_left"}
{"formal_statement": "theorem mirror_C {R : Type*} [semiring R] (a : R) :\n\t(\u21d1polynomial.C a).mirror = \u21d1polynomial.C a", "decl_tp": "\u2200 {R : Type u_1} [_inst_1 : semiring R] (a : R), (\u21d1polynomial.C a).mirror = \u21d1polynomial.C a", "decl_nm": "polynomial.mirror_C"}
{"formal_statement": "theorem refl_target (\u03b1 : Type*) [topological_space \u03b1] :\n\t(local_homeomorph.refl \u03b1).to_local_equiv.target = set.univ", "decl_tp": "\u2200 (\u03b1 : Type u_1) [_inst_5 : topological_space \u03b1], (local_homeomorph.refl \u03b1).to_local_equiv.target = set.univ", "decl_nm": "local_homeomorph.refl_target"}
{"formal_statement": "theorem essentially_small_mono_over_iff_small_subobject {C : Type u\u2081} [category_theory.category C]\n\t(X : C) :\n\tcategory_theory.essentially_small (category_theory.mono_over X) \u2194 small (category_theory.subobject X)", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] (X : C), category_theory.essentially_small (category_theory.mono_over X) \u2194 small (category_theory.subobject X)", "decl_nm": "category_theory.essentially_small_mono_over_iff_small_subobject"}
{"formal_statement": "theorem Ico_subset_Icc_union_Ioo {\u03b1 : Type u} [linear_order \u03b1] {a b c : \u03b1} :\n\tset.Ico a c \u2286 set.Icc a b \u222a set.Ioo b c", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : linear_order \u03b1] {a b c : \u03b1}, set.Ico a c \u2286 set.Icc a b \u222a set.Ioo b c", "decl_nm": "set.Ico_subset_Icc_union_Ioo"}
{"formal_statement": "theorem measurable_unit {\u03b1 : Type*} [measurable_space \u03b1] (f : unit \u2192 \u03b1) :\n\tmeasurable f", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : measurable_space \u03b1] (f : unit \u2192 \u03b1), measurable f", "decl_nm": "measurable_unit"}
{"formal_statement": "theorem sUnion_union {\u03b1 : Type*} (S T : set (set \u03b1)) :\n\t\u22c3\u2080(S \u222a T) = \u22c3\u2080 S \u222a \u22c3\u2080 T", "decl_tp": "\u2200 {\u03b1 : Type u_1} (S T : set (set \u03b1)), \u22c3\u2080(S \u222a T) = \u22c3\u2080 S \u222a \u22c3\u2080 T", "decl_nm": "set.sUnion_union"}
{"formal_statement": "theorem eval\u2082_pow {R : Type u} {S : Type v} [semiring R] {p : polynomial R}\n\t[comm_semiring S] (f : R \u2192+* S) (x : S) (n : \u2115) :\n\tpolynomial.eval\u2082 f x (p ^ n) = polynomial.eval\u2082 f x p ^ n", "decl_tp": "\u2200 {R : Type u} {S : Type v} [_inst_1 : semiring R] {p : polynomial R} [_inst_2 : comm_semiring S] (f : R \u2192+* S) (x : S) (n : \u2115), polynomial.eval\u2082 f x (p ^ n) = polynomial.eval\u2082 f x p ^ n", "decl_nm": "polynomial.eval\u2082_pow"}
{"formal_statement": "theorem init_prefix {\u03b1 : Type*} (l : list \u03b1) :\n\tl.init <+: l", "decl_tp": "\u2200 {\u03b1 : Type u_1} (l : list \u03b1), l.init <+: l", "decl_nm": "list.init_prefix"}
{"formal_statement": "theorem is_unit_of_map_unit {R : Type u} {S : Type v} [semiring R] [semiring S]\n\t(f : R \u2192+* S) [is_local_ring_hom f] (a : R) (h : is_unit (\u21d1f a)) :\n\tis_unit a", "decl_tp": "\u2200 {R : Type u} {S : Type v} [_inst_1 : semiring R] [_inst_2 : semiring S] (f : R \u2192+* S) [_inst_3 : is_local_ring_hom f] (a : R), is_unit (\u21d1f a) \u2192 is_unit a", "decl_nm": "is_unit_of_map_unit"}
{"formal_statement": "theorem cos {E : Type*} [normed_group E] [normed_space \u211d E] {f : E \u2192 \u211d}\n\t{s : set E} {n : with_top \u2115} (hf : times_cont_diff_on \u211d n f s) :\n\ttimes_cont_diff_on \u211d n (\u03bb (x : E), real.cos (f x)) s", "decl_tp": "\u2200 {E : Type u_1} [_inst_1 : normed_group E] [_inst_2 : normed_space \u211d E] {f : E \u2192 \u211d} {s : set E} {n : with_top \u2115}, times_cont_diff_on \u211d n f s \u2192 times_cont_diff_on \u211d n (\u03bb (x : E), real.cos (f x)) s", "decl_nm": "times_cont_diff_on.cos"}
{"formal_statement": "theorem Ioo_eq_zero_of_le {\u03b1 : Type*} [preorder \u03b1] [locally_finite_order \u03b1]\n\t{a b : \u03b1} (h : b \u2264 a) :\n\tmultiset.Ioo a b = 0", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : preorder \u03b1] [_inst_2 : locally_finite_order \u03b1] {a b : \u03b1}, b \u2264 a \u2192 multiset.Ioo a b = 0", "decl_nm": "multiset.Ioo_eq_zero_of_le"}
{"formal_statement": "theorem sub_le_self (a b : ordinal) :\n\ta - b \u2264 a", "decl_tp": "\u2200 (a b : ordinal), a - b \u2264 a", "decl_nm": "ordinal.sub_le_self"}
{"formal_statement": "theorem succ_nsmul {M : Type*} [add_monoid M] (a : M) (n : \u2115) :\n\t(n + 1) \u2022 a = a + n \u2022 a", "decl_tp": "\u2200 {M : Type u_1} [_inst_1 : add_monoid M] (a : M) (n : \u2115), (n + 1) \u2022 a = a + n \u2022 a", "decl_nm": "succ_nsmul"}
{"formal_statement": "theorem list_dprod_eq {\u03b9 R \u03b1 S : Type*} [set_like S R] [monoid R] [add_monoid \u03b9]\n\t(A : \u03b9 \u2192 S) [set_like.graded_monoid A] (f\u03b9 : \u03b1 \u2192 \u03b9) (fA : \u03a0 (a : \u03b1), \u21a5(A (f\u03b9 a)))\n\t(l : list \u03b1) :\n\tl.dprod f\u03b9 fA = \u27e8(list.map (\u03bb (a : \u03b1), \u2191(fA a)) l).prod, _\u27e9", "decl_tp": "\u2200 {\u03b9 : Type u_1} {R : Type u_2} {\u03b1 : Type u_3} {S : Type u_4} [_inst_1 : set_like S R] [_inst_2 : monoid R] [_inst_3 : add_monoid \u03b9] (A : \u03b9 \u2192 S) [_inst_4 : set_like.graded_monoid A] (f\u03b9 : \u03b1 \u2192 \u03b9) (fA : \u03a0 (a : \u03b1), \u21a5(A (f\u03b9 a))) (l : list \u03b1), l.dprod f\u03b9 fA = \u27e8(list.map (\u03bb (a : \u03b1), \u2191(fA a)) l).prod, _\u27e9", "decl_nm": "set_like.list_dprod_eq"}
{"formal_statement": "theorem mem_uniformity_is_closed {\u03b1 : Type*} [uniform_space \u03b1] {s : set (\u03b1 \u00d7 \u03b1)}\n\t(h : s \u2208 uniformity \u03b1) :\n\t(\u2203 (t : set (\u03b1 \u00d7 \u03b1)) (H : t \u2208 uniformity \u03b1), is_closed t \u2227 t \u2286 s)", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : uniform_space \u03b1] {s : set (\u03b1 \u00d7 \u03b1)}, s \u2208 uniformity \u03b1 \u2192 (\u2203 (t : set (\u03b1 \u00d7 \u03b1)) (H : t \u2208 uniformity \u03b1), is_closed t \u2227 t \u2286 s)", "decl_nm": "mem_uniformity_is_closed"}
{"formal_statement": "theorem principal_is_measurably_generated {\u03b1 : Type*} [measurable_space \u03b1]\n\t{s : set \u03b1} :\n\tmeasurable_set s \u2192 (filter.principal s).is_measurably_generated", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : measurable_space \u03b1] {s : set \u03b1}, measurable_set s \u2192 (filter.principal s).is_measurably_generated", "decl_nm": "measurable_set.principal_is_measurably_generated"}
{"formal_statement": "theorem eq_of_eq_on_dense {L : first_order.language} {M N : Type*} [L.Structure M]\n\t[L.Structure N] {s : set M} (hs : \u21d1(first_order.language.substructure.closure L) s = \u22a4)\n\t(h : set.eq_on \u21d1f \u21d1g s) :\n\t\u2200 {f g : L.hom M N},  f = g", "decl_tp": "\u2200 {L : first_order.language} {M : Type u_3} {N : Type u_4} [_inst_1 : L.Structure M] [_inst_2 : L.Structure N] {s : set M}, \u21d1(first_order.language.substructure.closure L) s = \u22a4 \u2192 \u2200 {f g : L.hom M N}, set.eq_on \u21d1f \u21d1g s \u2192 f = g", "decl_nm": "first_order.language.hom.eq_of_eq_on_dense"}
{"formal_statement": "theorem forall\u2082_take_append {\u03b1 \u03b2 : Type*} {R : \u03b1 \u2192 \u03b2 \u2192 Prop} (l : list \u03b1)\n\t(l\u2081 l\u2082 : list \u03b2) (h : list.forall\u2082 R l (l\u2081 ++ l\u2082)) :\n\tlist.forall\u2082 R (list.take l\u2081.length l) l\u2081", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {R : \u03b1 \u2192 \u03b2 \u2192 Prop} (l : list \u03b1) (l\u2081 l\u2082 : list \u03b2), list.forall\u2082 R l (l\u2081 ++ l\u2082) \u2192 list.forall\u2082 R (list.take l\u2081.length l) l\u2081", "decl_nm": "list.forall\u2082_take_append"}
{"formal_statement": "theorem finsum_sub_distrib {\u03b1 G : Type*} [add_comm_group G] {f g : \u03b1 \u2192 G}\n\t(hf : (function.support f).finite) (hg : (function.support g).finite) :\n\tfinsum (\u03bb (i : \u03b1), f i - g i) = finsum (\u03bb (i : \u03b1), f i) - finsum (\u03bb (i : \u03b1), g i)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {G : Type u_2} [_inst_3 : add_comm_group G] {f g : \u03b1 \u2192 G}, (function.support f).finite \u2192 (function.support g).finite \u2192 finsum (\u03bb (i : \u03b1), f i - g i) = finsum (\u03bb (i : \u03b1), f i) - finsum (\u03bb (i : \u03b1), g i)", "decl_nm": "finsum_sub_distrib"}
{"formal_statement": "theorem distortion_bUnion_prepartition {\u03b9 : Type*} {I : box_integral.box \u03b9}\n\t[fintype \u03b9] (\u03c0 : box_integral.tagged_prepartition I) (\u03c0i : \u03a0 (J : box_integral.box \u03b9), box_integral.prepartition J) :\n\t(\u03c0.bUnion_prepartition \u03c0i).distortion = \u03c0.to_prepartition.boxes.sup (\u03bb (J : box_integral.box \u03b9), (\u03c0i J).distortion)", "decl_tp": "\u2200 {\u03b9 : Type u_1} {I : box_integral.box \u03b9} [_inst_1 : fintype \u03b9] (\u03c0 : box_integral.tagged_prepartition I) (\u03c0i : \u03a0 (J : box_integral.box \u03b9), box_integral.prepartition J), (\u03c0.bUnion_prepartition \u03c0i).distortion = \u03c0.to_prepartition.boxes.sup (\u03bb (J : box_integral.box \u03b9), (\u03c0i J).distortion)", "decl_nm": "box_integral.tagged_prepartition.distortion_bUnion_prepartition"}
{"formal_statement": "theorem times_cont_diff_within_at_inter {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c]\n\t{E : Type*} [normed_group E] [normed_space \ud835\udd5c E] {F : Type*} [normed_group F]\n\t[normed_space \ud835\udd5c F] {s t : set E} {f : E \u2192 F} {x : E} {n : with_top \u2115}\n\t(h : t \u2208 nhds x) :\n\t(times_cont_diff_within_at \ud835\udd5c n f (s \u2229 t) x \u2194 times_cont_diff_within_at \ud835\udd5c n f s x)", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {F : Type u_3} [_inst_4 : normed_group F] [_inst_5 : normed_space \ud835\udd5c F] {s t : set E} {f : E \u2192 F} {x : E} {n : with_top \u2115}, t \u2208 nhds x \u2192 (times_cont_diff_within_at \ud835\udd5c n f (s \u2229 t) x \u2194 times_cont_diff_within_at \ud835\udd5c n f s x)", "decl_nm": "times_cont_diff_within_at_inter"}
{"formal_statement": "theorem real_smul_neg {\u03b1 : Type*} [measurable_space \u03b1] (j : measure_theory.jordan_decomposition \u03b1)\n\t(r : \u211d) (hr : r < 0) :\n\tr \u2022 j = -((-r).to_nnreal \u2022 j)", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : measurable_space \u03b1] (j : measure_theory.jordan_decomposition \u03b1) (r : \u211d), r < 0 \u2192 r \u2022 j = -((-r).to_nnreal \u2022 j)", "decl_nm": "measure_theory.jordan_decomposition.real_smul_neg"}
{"formal_statement": "theorem lt_def {\u03b1 \u03b2 : Type*} [topological_space \u03b1] [topological_space \u03b2]\n\t[partial_order \u03b2] {f g : C(\u03b1, \u03b2)} :\n\tf < g \u2194 (\u2200 (a : \u03b1), \u21d1f a \u2264 \u21d1g a) \u2227 \u2203 (a : \u03b1), \u21d1f a < \u21d1g a", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : topological_space \u03b1] [_inst_2 : topological_space \u03b2] [_inst_4 : partial_order \u03b2] {f g : C(\u03b1, \u03b2)}, f < g \u2194 (\u2200 (a : \u03b1), \u21d1f a \u2264 \u21d1g a) \u2227 \u2203 (a : \u03b1), \u21d1f a < \u21d1g a", "decl_nm": "continuous_map.lt_def"}
{"formal_statement": "theorem comp_one {M N P : Type*} [has_one M] [has_one N] [has_one P] (f : one_hom N P) :\n\tf.comp 1 = 1", "decl_tp": "\u2200 {M : Type u_1} {N : Type u_2} {P : Type u_3} [_inst_1 : has_one M] [_inst_2 : has_one N] [_inst_3 : has_one P] (f : one_hom N P), f.comp 1 = 1", "decl_nm": "one_hom.comp_one"}
{"formal_statement": "theorem is_sheaf_for_subsieve {C : Type u\u2081} [category_theory.category C]\n\t{X : C} (P : C\u1d52\u1d56 \u2964 Type w) {S : category_theory.sieve X} {R : category_theory.presieve X}\n\t(h : \u21d1S \u2264 R) :\n\t(\u2200 \u2983Y : C\u2984 (f : Y \u27f6 X), category_theory.presieve.is_sheaf_for P \u21d1(category_theory.sieve.pullback f S)) \u2192 category_theory.presieve.is_sheaf_for P R", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {X : C} (P : C\u1d52\u1d56 \u2964 Type w) {S : category_theory.sieve X} {R : category_theory.presieve X}, \u21d1S \u2264 R \u2192 (\u2200 \u2983Y : C\u2984 (f : Y \u27f6 X), category_theory.presieve.is_sheaf_for P \u21d1(category_theory.sieve.pullback f S)) \u2192 category_theory.presieve.is_sheaf_for P R", "decl_nm": "category_theory.presieve.is_sheaf_for_subsieve"}
{"formal_statement": "theorem mul {\u03b1 : Type*} {s t : set \u03b1} [has_mul \u03b1] (hs : s.finite) (ht : t.finite) :\n\t(s * t).finite", "decl_tp": "\u2200 {\u03b1 : Type u_1} {s t : set \u03b1} [_inst_1 : has_mul \u03b1], s.finite \u2192 t.finite \u2192 (s * t).finite", "decl_nm": "set.finite.mul"}
{"formal_statement": "theorem algebra_functor_of_monad_hom_eq_inv_app_f {C : Type u\u2081} [category_theory.category C]\n\t{T\u2081 T\u2082 : category_theory.monad C} {f g : T\u2081 \u27f6 T\u2082} (h : f = g) (X : T\u2082.algebra) :\n\t((category_theory.monad.algebra_functor_of_monad_hom_eq h).inv.app X).f = (category_theory.iso.refl ((category_theory.monad.algebra_functor_of_monad_hom f).obj X).A).inv", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {T\u2081 T\u2082 : category_theory.monad C} {f g : T\u2081 \u27f6 T\u2082} (h : f = g) (X : T\u2082.algebra), ((category_theory.monad.algebra_functor_of_monad_hom_eq h).inv.app X).f = (category_theory.iso.refl ((category_theory.monad.algebra_functor_of_monad_hom f).obj X).A).inv", "decl_nm": "category_theory.monad.algebra_functor_of_monad_hom_eq_inv_app_f"}
{"formal_statement": "theorem of_eq_top_imp_eq_top {\u03b1 : Type*} {m : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1}\n\t{\u03b2 : Type*} [add_comm_monoid \u03b2] {T : set \u03b1 \u2192 \u03b2} {\u03bc' : measure_theory.measure \u03b1}\n\t(hT : measure_theory.fin_meas_additive \u03bc T) (hs : measurable_set s) :\n\t(\u2200 (s : set \u03b1),  \u21d1\u03bc s = \u22a4 \u2192 \u21d1\u03bc' s = \u22a4) \u2192  measure_theory.fin_meas_additive \u03bc' T", "decl_tp": "\u2200 {\u03b1 : Type u_1} {m : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} {\u03b2 : Type u_7} [_inst_10 : add_comm_monoid \u03b2] {T : set \u03b1 \u2192 \u03b2} {\u03bc' : measure_theory.measure \u03b1}, (\u2200 (s : set \u03b1), measurable_set s \u2192 \u21d1\u03bc s = \u22a4 \u2192 \u21d1\u03bc' s = \u22a4) \u2192 measure_theory.fin_meas_additive \u03bc T \u2192 measure_theory.fin_meas_additive \u03bc' T", "decl_nm": "measure_theory.fin_meas_additive.of_eq_top_imp_eq_top"}
{"formal_statement": "theorem mul_tsub {\u03b1 : Type u} [canonically_ordered_comm_semiring \u03b1] [has_sub \u03b1]\n\t[has_ordered_sub \u03b1] [is_total \u03b1 has_le.le] [contravariant_class \u03b1 \u03b1 has_add.add has_le.le]\n\t(a b c : \u03b1) :\n\ta * (b - c) = a * b - a * c", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : canonically_ordered_comm_semiring \u03b1] [_inst_2 : has_sub \u03b1] [_inst_3 : has_ordered_sub \u03b1] [_inst_4 : is_total \u03b1 has_le.le] [_inst_5 : contravariant_class \u03b1 \u03b1 has_add.add has_le.le] (a b c : \u03b1), a * (b - c) = a * b - a * c", "decl_nm": "mul_tsub"}
{"formal_statement": "theorem exists_elim_eq_right {\u03b1 : Sort u} (a : \u03b1) (p : \u03a0 (a' : \u03b1), a = a' \u2192 Prop) :\n\t(\u2203 (a' : \u03b1) (h : a = a'), p a' h) \u2194 p a rfl", "decl_tp": "\u2200 {\u03b1 : Sort u} (a : \u03b1) (p : \u03a0 (a' : \u03b1), a = a' \u2192 Prop), (\u2203 (a' : \u03b1) (h : a = a'), p a' h) \u2194 p a rfl", "decl_nm": "exists_elim_eq_right"}
{"formal_statement": "theorem coe_eq_singleton {\u03b1 : Type*} {s : finset \u03b1} {a : \u03b1} :\n\t\u2191s = {a} \u2194 s = {a}", "decl_tp": "\u2200 {\u03b1 : Type u_1} {s : finset \u03b1} {a : \u03b1}, \u2191s = {a} \u2194 s = {a}", "decl_nm": "finset.coe_eq_singleton"}
{"formal_statement": "theorem integral_to_real {\u03b1 : Type*} {m : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1}\n\t{f : \u03b1 \u2192 ennreal} (hfm : ae_measurable f \u03bc) :\n\t(\u2200\u1d50 (x : \u03b1) \u2202\u03bc, f x < \u22a4) \u2192 \u222b (a : \u03b1), (f a).to_real \u2202\u03bc = (\u222b\u207b (a : \u03b1), f a \u2202\u03bc).to_real", "decl_tp": "\u2200 {\u03b1 : Type u_1} {m : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} {f : \u03b1 \u2192 ennreal}, ae_measurable f \u03bc \u2192 (\u2200\u1d50 (x : \u03b1) \u2202\u03bc, f x < \u22a4) \u2192 \u222b (a : \u03b1), (f a).to_real \u2202\u03bc = (\u222b\u207b (a : \u03b1), f a \u2202\u03bc).to_real", "decl_nm": "measure_theory.integral_to_real"}
{"formal_statement": "theorem tendsto_add {M : Type*} [topological_space M] [has_add M] [has_continuous_add M]\n\t{a b : M} :\n\tfilter.tendsto (\u03bb (p : M \u00d7 M), p.fst + p.snd) (nhds (a, b)) (nhds (a + b))", "decl_tp": "\u2200 {M : Type u_4} [_inst_2 : topological_space M] [_inst_3 : has_add M] [_inst_4 : has_continuous_add M] {a b : M}, filter.tendsto (\u03bb (p : M \u00d7 M), p.fst + p.snd) (nhds (a, b)) (nhds (a + b))", "decl_nm": "tendsto_add"}
{"formal_statement": "theorem div_le_div_of_le {\u03b1 : Type*} [linear_ordered_field \u03b1] {a b c : \u03b1}\n\t(hc : 0 \u2264 c) (h : a \u2264 b) :\n\ta / c \u2264 b / c", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : linear_ordered_field \u03b1] {a b c : \u03b1}, 0 \u2264 c \u2192 a \u2264 b \u2192 a / c \u2264 b / c", "decl_nm": "div_le_div_of_le"}
{"formal_statement": "theorem has_colimits_of_shape_of_has_colimits_of_shape_creates_colimits_of_shape {C : Type u\u2081}\n\t[category_theory.category C] {D : Type u\u2082} [category_theory.category D]\n\t{J : Type w} [category_theory.category J] (F : C \u2964 D) [category_theory.limits.has_colimits_of_shape J D]\n\t[category_theory.creates_colimits_of_shape J F] :\n\tcategory_theory.limits.has_colimits_of_shape J C", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {D : Type u\u2082} [_inst_2 : category_theory.category D] {J : Type w} [_inst_3 : category_theory.category J] (F : C \u2964 D) [_inst_4 : category_theory.limits.has_colimits_of_shape J D] [_inst_5 : category_theory.creates_colimits_of_shape J F], category_theory.limits.has_colimits_of_shape J C", "decl_nm": "category_theory.has_colimits_of_shape_of_has_colimits_of_shape_creates_colimits_of_shape"}
{"formal_statement": "theorem cone_points_iso_of_nat_iso_hom {J : Type u\u2081} [category_theory.category J]\n\t{C : Type u\u2083} [category_theory.category C] {F G : J \u2964 C} {s : category_theory.limits.cone F}\n\t{t : category_theory.limits.cone G} (P : category_theory.limits.is_limit s)\n\t(Q : category_theory.limits.is_limit t) (w : F \u2245 G) :\n\t(P.cone_points_iso_of_nat_iso Q w).hom = category_theory.limits.is_limit.map s Q w.hom", "decl_tp": "\u2200 {J : Type u\u2081} [_inst_1 : category_theory.category J] {C : Type u\u2083} [_inst_3 : category_theory.category C] {F G : J \u2964 C} {s : category_theory.limits.cone F} {t : category_theory.limits.cone G} (P : category_theory.limits.is_limit s) (Q : category_theory.limits.is_limit t) (w : F \u2245 G), (P.cone_points_iso_of_nat_iso Q w).hom = category_theory.limits.is_limit.map s Q w.hom", "decl_nm": "category_theory.limits.is_limit.cone_points_iso_of_nat_iso_hom"}
{"formal_statement": "theorem lift_map {C : Type u\u2081} [category_theory.category C] [category_theory.preadditive C]\n\t{D : Type u\u2081} [category_theory.category D] [category_theory.preadditive D]\n\t[category_theory.limits.has_finite_biproducts D] (F : C \u2964 D) [F.additive]\n\t(X Y : category_theory.Mat_ C) (f : X \u27f6 Y) :\n\t(category_theory.Mat_.lift F).map f = category_theory.limits.biproduct.matrix (\u03bb (i : X.\u03b9)\n\t(j : Y.\u03b9), F.map (f i j))", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] [_inst_2 : category_theory.preadditive C] {D : Type u\u2081} [_inst_3 : category_theory.category D] [_inst_4 : category_theory.preadditive D] [_inst_5 : category_theory.limits.has_finite_biproducts D] (F : C \u2964 D) [_inst_6 : F.additive] (X Y : category_theory.Mat_ C) (f : X \u27f6 Y), (category_theory.Mat_.lift F).map f = category_theory.limits.biproduct.matrix (\u03bb (i : X.\u03b9) (j : Y.\u03b9), F.map (f i j))", "decl_nm": "category_theory.Mat_.lift_map"}
{"formal_statement": "theorem map_apply {\u03b1 \u03b2 : Type*} [measurable_space \u03b1] [measurable_space \u03b2]\n\t{\u03bc : measure_theory.measure \u03b1} (f : \u03b1 \u2243\u1d50 \u03b2) (s : set \u03b2) :\n\t\u21d1(\u21d1(measure_theory.measure.map \u21d1f) \u03bc) s = \u21d1\u03bc (\u21d1f \u207b\u00b9' s)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : measurable_space \u03b1] [_inst_2 : measurable_space \u03b2] {\u03bc : measure_theory.measure \u03b1} (f : \u03b1 \u2243\u1d50 \u03b2) (s : set \u03b2), \u21d1(\u21d1(measure_theory.measure.map \u21d1f) \u03bc) s = \u21d1\u03bc (\u21d1f \u207b\u00b9' s)", "decl_nm": "measurable_equiv.map_apply"}
{"formal_statement": "theorem coeff_zero_eq_constant_coeff {\u03c3 R : Type*} [semiring R] :\n\t\u21d1(mv_power_series.coeff R 0) = \u21d1(mv_power_series.constant_coeff \u03c3 R)", "decl_tp": "\u2200 {\u03c3 : Type u_1} {R : Type u_2} [_inst_1 : semiring R], \u21d1(mv_power_series.coeff R 0) = \u21d1(mv_power_series.constant_coeff \u03c3 R)", "decl_nm": "mv_power_series.coeff_zero_eq_constant_coeff"}
{"formal_statement": "theorem fg_iff_add_fg {M : Type*} [monoid M] :\n\tmonoid.fg M \u2194 add_monoid.fg (additive M)", "decl_tp": "\u2200 {M : Type u_1} [_inst_1 : monoid M], monoid.fg M \u2194 add_monoid.fg (additive M)", "decl_nm": "monoid.fg_iff_add_fg"}
{"formal_statement": "theorem union_symm_apply_left {\u03b1 : Type*} {s t : set \u03b1} [decidable_pred (\u03bb (x : \u03b1), x \u2208 s)]\n\t(H : s \u2229 t \u2286 \u2205) (a : \u21a5s) :\n\t\u21d1((equiv.set.union H).symm) (sum.inl a) = \u27e8\u2191a, _\u27e9", "decl_tp": "\u2200 {\u03b1 : Type u_1} {s t : set \u03b1} [_inst_1 : decidable_pred (\u03bb (x : \u03b1), x \u2208 s)] (H : s \u2229 t \u2286 \u2205) (a : \u21a5s), \u21d1((equiv.set.union H).symm) (sum.inl a) = \u27e8\u2191a, _\u27e9", "decl_nm": "equiv.set.union_symm_apply_left"}
{"formal_statement": "theorem ODE_solution_unique {E : Type*} [normed_group E] [normed_space \u211d E]\n\t{v : \u211d \u2192 E \u2192 E} {K : nnreal} (hf : continuous_on f (set.Icc a b)) (hg : continuous_on g (set.Icc a b))\n\t(ha : f a = g a) :\n\t(\u2200 (t : \u211d), lipschitz_with K (v t)) \u2192 \u2200 {f g : \u211d \u2192 E} {a b : \u211d},  (\u2200 (t : \u211d), t \u2208 set.Ico a b \u2192 has_deriv_within_at f (v t (f t))\n\t(set.Ici t) t) \u2192  (\u2200 (t : \u211d), t \u2208 set.Ico a b \u2192 has_deriv_within_at g (v t (g t))\n\t(set.Ici t) t) \u2192  \u2200 (t : \u211d), t \u2208 set.Icc a b \u2192 f t = g t", "decl_tp": "\u2200 {E : Type u_1} [_inst_1 : normed_group E] [_inst_2 : normed_space \u211d E] {v : \u211d \u2192 E \u2192 E} {K : nnreal}, (\u2200 (t : \u211d), lipschitz_with K (v t)) \u2192 \u2200 {f g : \u211d \u2192 E} {a b : \u211d}, continuous_on f (set.Icc a b) \u2192 (\u2200 (t : \u211d), t \u2208 set.Ico a b \u2192 has_deriv_within_at f (v t (f t)) (set.Ici t) t) \u2192 continuous_on g (set.Icc a b) \u2192 (\u2200 (t : \u211d), t \u2208 set.Ico a b \u2192 has_deriv_within_at g (v t (g t)) (set.Ici t) t) \u2192 f a = g a \u2192 \u2200 (t : \u211d), t \u2208 set.Icc a b \u2192 f t = g t", "decl_nm": "ODE_solution_unique"}
{"formal_statement": "theorem sbtw_cyclic {\u03b1 : Type*} [circular_preorder \u03b1] {a b c : \u03b1} :\n\thas_sbtw.sbtw a b c \u2194 has_sbtw.sbtw c a b", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : circular_preorder \u03b1] {a b c : \u03b1}, has_sbtw.sbtw a b c \u2194 has_sbtw.sbtw c a b", "decl_nm": "sbtw_cyclic"}
{"formal_statement": "theorem tendsto_zpow_at_top_at_top {\ud835\udd5c : Type*} [linear_ordered_field \ud835\udd5c]\n\t{n : \u2124} (hn : 0 < n) :\n\tfilter.tendsto (\u03bb (x : \ud835\udd5c), x ^ n) filter.at_top filter.at_top", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : linear_ordered_field \ud835\udd5c] {n : \u2124}, 0 < n \u2192 filter.tendsto (\u03bb (x : \ud835\udd5c), x ^ n) filter.at_top filter.at_top", "decl_nm": "tendsto_zpow_at_top_at_top"}
{"formal_statement": "theorem mem_closure_iff_nhds_within_ne_bot {\u03b1 : Type u} [topological_space \u03b1]\n\t{s : set \u03b1} {x : \u03b1} :\n\tx \u2208 closure s \u2194 (nhds_within x s).ne_bot", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : topological_space \u03b1] {s : set \u03b1} {x : \u03b1}, x \u2208 closure s \u2194 (nhds_within x s).ne_bot", "decl_nm": "mem_closure_iff_nhds_within_ne_bot"}
{"formal_statement": "theorem top_mul {R : Type u} [comm_semiring R] (I : ideal R) :\n\t\u22a4 * I = I", "decl_tp": "\u2200 {R : Type u} [_inst_1 : comm_semiring R] (I : ideal R), \u22a4 * I = I", "decl_nm": "ideal.top_mul"}
{"formal_statement": "theorem coe_smul {\u03b1 : Type u} {\u03b2 : Type v} [monoid \u03b1] [mul_action \u03b1 \u03b2]\n\t{b : \u03b2} {a : \u03b1} {b' : \u21a5(mul_action.orbit \u03b1 b)} :\n\t\u2191(a \u2022 b') = a \u2022 \u2191b'", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : monoid \u03b1] [_inst_2 : mul_action \u03b1 \u03b2] {b : \u03b2} {a : \u03b1} {b' : \u21a5(mul_action.orbit \u03b1 b)}, \u2191(a \u2022 b') = a \u2022 \u2191b'", "decl_nm": "mul_action.orbit.coe_smul"}
{"formal_statement": "theorem prod_ite_eq' {\u03b1 M N : Type*} [has_zero M] [comm_monoid N] [decidable_eq \u03b1]\n\t(f : \u03b1 \u2192\u2080 M) (a : \u03b1) (b : \u03b1 \u2192 M \u2192 N) :\n\tf.prod (\u03bb (x : \u03b1) (v : M), ite (x = a) (b x v) 1) = ite (a \u2208 f.support)\n\t(b a (\u21d1f a)) 1", "decl_tp": "\u2200 {\u03b1 : Type u_1} {M : Type u_5} {N : Type u_7} [_inst_1 : has_zero M] [_inst_3 : comm_monoid N] [_inst_4 : decidable_eq \u03b1] (f : \u03b1 \u2192\u2080 M) (a : \u03b1) (b : \u03b1 \u2192 M \u2192 N), f.prod (\u03bb (x : \u03b1) (v : M), ite (x = a) (b x v) 1) = ite (a \u2208 f.support) (b a (\u21d1f a)) 1", "decl_nm": "finsupp.prod_ite_eq'"}
{"formal_statement": "theorem terminates_of_mem {\u03b1 : Type u} {s : computation \u03b1} {a : \u03b1} (h : a \u2208 s) :\n\ts.terminates", "decl_tp": "\u2200 {\u03b1 : Type u} {s : computation \u03b1} {a : \u03b1}, a \u2208 s \u2192 s.terminates", "decl_nm": "computation.terminates_of_mem"}
{"formal_statement": "theorem multiples_eq_zmultiples {G : Type u} [fintype G] [add_group G]\n\t(x : G) :\n\t\u2191(add_submonoid.multiples x) = \u2191(add_subgroup.zmultiples x)", "decl_tp": "\u2200 {G : Type u} [_inst_1 : fintype G] [_inst_3 : add_group G] (x : G), \u2191(add_submonoid.multiples x) = \u2191(add_subgroup.zmultiples x)", "decl_nm": "multiples_eq_zmultiples"}
{"formal_statement": "theorem inv_one {\u03b1 : Type u} [group \u03b1] :\n\t1\u207b\u00b9 = 1", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : group \u03b1], 1\u207b\u00b9 = 1", "decl_nm": "with_zero.inv_one"}
{"formal_statement": "theorem teichmuller_coeff_pos (p : \u2115) {R : Type*} [hp : fact (nat.prime p)]\n\t[comm_ring R] (r : R) (n : \u2115) (hn : 0 < n) :\n\t(\u21d1(witt_vector.teichmuller p) r).coeff n = 0", "decl_tp": "\u2200 (p : \u2115) {R : Type u_1} [hp : fact (nat.prime p)] [_inst_1 : comm_ring R] (r : R) (n : \u2115), 0 < n \u2192 (\u21d1(witt_vector.teichmuller p) r).coeff n = 0", "decl_nm": "witt_vector.teichmuller_coeff_pos"}
{"formal_statement": "theorem empty_right {\u03b1 : Type u} [topological_space \u03b1] (a : set \u03b1) :\n\tseparated a \u2205", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : topological_space \u03b1] (a : set \u03b1), separated a \u2205", "decl_nm": "separated.empty_right"}
{"formal_statement": "theorem prod_erase_mul {\u03b2 : Type u} {\u03b1 : Type v} [comm_monoid \u03b2] [decidable_eq \u03b1]\n\t(s : finset \u03b1) (f : \u03b1 \u2192 \u03b2) {a : \u03b1} (h : a \u2208 s) :\n\t(s.erase a).prod (\u03bb (x : \u03b1), f x) * f a = s.prod (\u03bb (x : \u03b1), f x)", "decl_tp": "\u2200 {\u03b2 : Type u} {\u03b1 : Type v} [_inst_1 : comm_monoid \u03b2] [_inst_2 : decidable_eq \u03b1] (s : finset \u03b1) (f : \u03b1 \u2192 \u03b2) {a : \u03b1}, a \u2208 s \u2192 (s.erase a).prod (\u03bb (x : \u03b1), f x) * f a = s.prod (\u03bb (x : \u03b1), f x)", "decl_nm": "finset.prod_erase_mul"}
{"formal_statement": "theorem inv_mem_Ioc_iff {\u03b1 : Type*} [ordered_comm_group \u03b1] {a c d : \u03b1} :\n\ta\u207b\u00b9 \u2208 set.Ioc c d \u2194 a \u2208 set.Ico d\u207b\u00b9 c\u207b\u00b9", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : ordered_comm_group \u03b1] {a c d : \u03b1}, a\u207b\u00b9 \u2208 set.Ioc c d \u2194 a \u2208 set.Ico d\u207b\u00b9 c\u207b\u00b9", "decl_nm": "set.inv_mem_Ioc_iff"}
{"formal_statement": "theorem pow_right_injective {x : \u2115} (k : 2 \u2264 x) :\n\tfunction.injective (\u03bb (n : \u2115), x ^ n)", "decl_tp": "\u2200 {x : \u2115}, 2 \u2264 x \u2192 function.injective (\u03bb (n : \u2115), x ^ n)", "decl_nm": "nat.pow_right_injective"}
{"formal_statement": "theorem binary_coproduct_colimit_desc (X Y : Type u) (s : category_theory.limits.binary_cofan X Y)\n\t(\u1fb0 : X \u2295 Y) :\n\t(category_theory.limits.types.binary_coproduct_colimit X Y).desc s \u1fb0 = sum.elim s.inl s.inr \u1fb0", "decl_tp": "\u2200 (X Y : Type u) (s : category_theory.limits.binary_cofan X Y) (\u1fb0 : X \u2295 Y), (category_theory.limits.types.binary_coproduct_colimit X Y).desc s \u1fb0 = sum.elim s.inl s.inr \u1fb0", "decl_nm": "category_theory.limits.types.binary_coproduct_colimit_desc"}
{"formal_statement": "theorem le_one {\u03b9 : Type u\u03b9} {E : Type uE} [normed_group E] [normed_space \u211d E]\n\t[finite_dimensional \u211d E] {H : Type uH} [topological_space H] {I : model_with_corners \u211d E H}\n\t{M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M]\n\t{s : set M} (f : smooth_partition_of_unity \u03b9 I M s) (i : \u03b9) (x : M) :\n\t\u21d1(\u21d1f i) x \u2264 1", "decl_tp": "\u2200 {\u03b9 : Type u\u03b9} {E : Type uE} [_inst_1 : normed_group E] [_inst_2 : normed_space \u211d E] [_inst_3 : finite_dimensional \u211d E] {H : Type uH} [_inst_4 : topological_space H] {I : model_with_corners \u211d E H} {M : Type uM} [_inst_5 : topological_space M] [_inst_6 : charted_space H M] [_inst_7 : smooth_manifold_with_corners I M] {s : set M} (f : smooth_partition_of_unity \u03b9 I M s) (i : \u03b9) (x : M), \u21d1(\u21d1f i) x \u2264 1", "decl_nm": "smooth_partition_of_unity.le_one"}
{"formal_statement": "theorem one_div_nonneg {p q : \u211d} (h : p.is_conjugate_exponent q) :\n\t0 \u2264 1 / p", "decl_tp": "\u2200 {p q : \u211d}, p.is_conjugate_exponent q \u2192 0 \u2264 1 / p", "decl_nm": "real.is_conjugate_exponent.one_div_nonneg"}
{"formal_statement": "theorem lt_of_mul_lt_mul_left {\u03b1 : Type u} [linear_ordered_semiring \u03b1]\n\t{a b c : \u03b1} (h : c * a < c * b) (hc : 0 \u2264 c) :\n\ta < b", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : linear_ordered_semiring \u03b1] {a b c : \u03b1}, c * a < c * b \u2192 0 \u2264 c \u2192 a < b", "decl_nm": "lt_of_mul_lt_mul_left"}
{"formal_statement": "theorem cons_nil_iff_singleton {\u03b1 : Type u} {L : list (\u03b1 \u00d7 bool)} {x : \u03b1}\n\t{b : bool} :\n\tfree_group.red ((x, b) :: L) list.nil \u2194 free_group.red L [(x, !b)]", "decl_tp": "\u2200 {\u03b1 : Type u} {L : list (\u03b1 \u00d7 bool)} {x : \u03b1} {b : bool}, free_group.red ((x, b) :: L) list.nil \u2194 free_group.red L [(x, !b)]", "decl_nm": "free_group.red.cons_nil_iff_singleton"}
{"formal_statement": "theorem nonempty_of_mem_countable_basis {\u03b1 : Type u} [t : topological_space \u03b1]\n\t[topological_space.second_countable_topology \u03b1] {s : set \u03b1} (hs : s \u2208 topological_space.countable_basis \u03b1) :\n\ts.nonempty", "decl_tp": "\u2200 {\u03b1 : Type u} [t : topological_space \u03b1] [_inst_1 : topological_space.second_countable_topology \u03b1] {s : set \u03b1}, s \u2208 topological_space.countable_basis \u03b1 \u2192 s.nonempty", "decl_nm": "topological_space.nonempty_of_mem_countable_basis"}
{"formal_statement": "theorem uniform_continuous_on_of_continuous' {\u03b1 \u03b2 : Type*} [uniform_space \u03b1]\n\t[uniform_space \u03b2] {s : set \u03b1} {f : \u03b1 \u2192 \u03b2} (hs : is_compact s) (hs' : is_separated s)\n\t(hf : continuous_on f s) :\n\tuniform_continuous_on f s", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : uniform_space \u03b1] [_inst_2 : uniform_space \u03b2] {s : set \u03b1} {f : \u03b1 \u2192 \u03b2}, is_compact s \u2192 is_separated s \u2192 continuous_on f s \u2192 uniform_continuous_on f s", "decl_nm": "is_compact.uniform_continuous_on_of_continuous'"}
{"formal_statement": "theorem cardinal_mk_le_finrank_of_linear_independent {K : Type u} {V : Type v}\n\t[division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V]\n\t{\u03b9 : Type w} {b : \u03b9 \u2192 V} (h : linear_independent K b) :\n\tcardinal.mk \u03b9 \u2264 \u2191(finite_dimensional.finrank K V)", "decl_tp": "\u2200 {K : Type u} {V : Type v} [_inst_1 : division_ring K] [_inst_2 : add_comm_group V] [_inst_3 : module K V] [_inst_6 : finite_dimensional K V] {\u03b9 : Type w} {b : \u03b9 \u2192 V}, linear_independent K b \u2192 cardinal.mk \u03b9 \u2264 \u2191(finite_dimensional.finrank K V)", "decl_nm": "finite_dimensional.cardinal_mk_le_finrank_of_linear_independent"}
{"formal_statement": "theorem of_comp_iff' {\u03b1 : Sort u_1} {\u03b2 : Sort u_2} {\u03b3 : Sort u_3} {f : \u03b1 \u2192 \u03b2}\n\t(hf : function.bijective f) :\n\t\u2200 (g : \u03b3 \u2192 \u03b1), function.bijective (f \u2218 g) \u2194 function.bijective g", "decl_tp": "\u2200 {\u03b1 : Sort u_1} {\u03b2 : Sort u_2} {\u03b3 : Sort u_3} {f : \u03b1 \u2192 \u03b2}, function.bijective f \u2192 \u2200 (g : \u03b3 \u2192 \u03b1), function.bijective (f \u2218 g) \u2194 function.bijective g", "decl_nm": "function.bijective.of_comp_iff'"}
{"formal_statement": "theorem ker_comp_of_ker_eq_bot {R R\u2082 R\u2083 M M\u2082 : Type*2} {M\u2083 : Type*3} [semiring R]\n\t[semiring R\u2082] [semiring R\u2083] [add_comm_monoid M] [add_comm_monoid M\u2082] [add_comm_monoid M\u2083]\n\t[module R M] [module R\u2082 M\u2082] [module R\u2083 M\u2083] {\u03c4\u2081\u2082 : R \u2192+* R\u2082} {\u03c4\u2082\u2083 : R\u2082 \u2192+* R\u2083}\n\t{\u03c4\u2081\u2083 : R \u2192+* R\u2083} [ring_hom_comp_triple \u03c4\u2081\u2082 \u03c4\u2082\u2083 \u03c4\u2081\u2083] (f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082)\n\t{g : M\u2082 \u2192\u209b\u2097[\u03c4\u2082\u2083] M\u2083} (hg : g.ker = \u22a5) :\n\t(g.comp f).ker = f.ker", "decl_tp": "\u2200 {R : Type u_1} {R\u2082 : Type u_3} {R\u2083 : Type u_4} {M : Type u_9} {M\u2082 : Type u_12} {M\u2083 : Type u_13} [_inst_1 : semiring R] [_inst_2 : semiring R\u2082] [_inst_3 : semiring R\u2083] [_inst_4 : add_comm_monoid M] [_inst_5 : add_comm_monoid M\u2082] [_inst_6 : add_comm_monoid M\u2083] [_inst_7 : module R M] [_inst_8 : module R\u2082 M\u2082] [_inst_9 : module R\u2083 M\u2083] {\u03c4\u2081\u2082 : R \u2192+* R\u2082} {\u03c4\u2082\u2083 : R\u2082 \u2192+* R\u2083} {\u03c4\u2081\u2083 : R \u2192+* R\u2083} [_inst_10 : ring_hom_comp_triple \u03c4\u2081\u2082 \u03c4\u2082\u2083 \u03c4\u2081\u2083] (f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082) {g : M\u2082 \u2192\u209b\u2097[\u03c4\u2082\u2083] M\u2083}, g.ker = \u22a5 \u2192 (g.comp f).ker = f.ker", "decl_nm": "linear_map.ker_comp_of_ker_eq_bot"}
{"formal_statement": "theorem fun_unique_symm_apply (\u03b1 \u03b2 : Type*) [unique \u03b1] [measurable_space \u03b2] :\n\t\u21d1((measurable_equiv.fun_unique \u03b1 \u03b2).symm) = function.const \u03b1", "decl_tp": "\u2200 (\u03b1 : Type u_1) (\u03b2 : Type u_2) [_inst_7 : unique \u03b1] [_inst_8 : measurable_space \u03b2], \u21d1((measurable_equiv.fun_unique \u03b1 \u03b2).symm) = function.const \u03b1", "decl_nm": "measurable_equiv.fun_unique_symm_apply"}
{"formal_statement": "theorem to_block_apply {m n \u03b1 : Type*} (M : matrix m n \u03b1) (p : m \u2192 Prop)\n\t(q : n \u2192 Prop) (i : {a // p a}) (j : {a // q a}) :\n\tM.to_block p q i j = M \u2191i \u2191j", "decl_tp": "\u2200 {m : Type u_2} {n : Type u_3} {\u03b1 : Type u_9} (M : matrix m n \u03b1) (p : m \u2192 Prop) (q : n \u2192 Prop) (i : {a // p a}) (j : {a // q a}), M.to_block p q i j = M \u2191i \u2191j", "decl_nm": "matrix.to_block_apply"}
{"formal_statement": "theorem bind_assoc {\u03b1 \u03b2 \u03b3 : Type*} (x : option \u03b1) (f : \u03b1 \u2192 option \u03b2) (g : \u03b2 \u2192 option \u03b3) :\n\t(x.bind f).bind g = x.bind (\u03bb (y : \u03b1), (f y).bind g)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {\u03b3 : Type u_3} (x : option \u03b1) (f : \u03b1 \u2192 option \u03b2) (g : \u03b2 \u2192 option \u03b3), (x.bind f).bind g = x.bind (\u03bb (y : \u03b1), (f y).bind g)", "decl_nm": "option.bind_assoc"}
{"formal_statement": "theorem lift_dim_eq {R : Type u} [ring R] {M : Type v} [add_comm_group M]\n\t[module R M] {M' : Type v'} [add_comm_group M'] [module R M'] :\n\t(M \u2243\u2097[R] M') \u2192 (module.rank R M).lift = (module.rank R M').lift", "decl_tp": "\u2200 {R : Type u} [_inst_1 : ring R] {M : Type v} [_inst_2 : add_comm_group M] [_inst_3 : module R M] {M' : Type v'} [_inst_4 : add_comm_group M'] [_inst_5 : module R M'], (M \u2243\u2097[R] M') \u2192 (module.rank R M).lift = (module.rank R M').lift", "decl_nm": "linear_equiv.lift_dim_eq"}
{"formal_statement": "theorem cauchy_seq_finset_of_norm_bounded {\u03b9 E : Type*} [semi_normed_group E]\n\t{f : \u03b9 \u2192 E} (g : \u03b9 \u2192 \u211d) (hg : summable g) :\n\t(\u2200 (i : \u03b9), \u2225f i\u2225 \u2264 g i) \u2192 cauchy_seq (\u03bb (s : finset \u03b9), s.sum (\u03bb (i : \u03b9), f i))", "decl_tp": "\u2200 {\u03b9 : Type u_1} {E : Type u_3} [_inst_1 : semi_normed_group E] {f : \u03b9 \u2192 E} (g : \u03b9 \u2192 \u211d), summable g \u2192 (\u2200 (i : \u03b9), \u2225f i\u2225 \u2264 g i) \u2192 cauchy_seq (\u03bb (s : finset \u03b9), s.sum (\u03bb (i : \u03b9), f i))", "decl_nm": "cauchy_seq_finset_of_norm_bounded"}
{"formal_statement": "theorem coe_fst_eventually_eq_proj {B F Z : Type*} [topological_space B]\n\t[topological_space F] {proj : Z \u2192 B} [topological_space Z] (e : topological_fiber_bundle.trivialization F proj)\n\t{x : Z} (ex : x \u2208 e.to_local_homeomorph.to_local_equiv.source) :\n\tprod.fst \u2218 \u21d1e =\u1da0[nhds x] proj", "decl_tp": "\u2200 {B : Type u_2} {F : Type u_3} {Z : Type u_4} [_inst_1 : topological_space B] [_inst_2 : topological_space F] {proj : Z \u2192 B} [_inst_3 : topological_space Z] (e : topological_fiber_bundle.trivialization F proj) {x : Z}, x \u2208 e.to_local_homeomorph.to_local_equiv.source \u2192 prod.fst \u2218 \u21d1e =\u1da0[nhds x] proj", "decl_nm": "topological_fiber_bundle.trivialization.coe_fst_eventually_eq_proj"}
{"formal_statement": "theorem faces_bot {\ud835\udd5c E : Type*} [ordered_ring \ud835\udd5c] [add_comm_group E] [module \ud835\udd5c E] :\n\t\u22a5.faces = \u2205", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} {E : Type u_2} [_inst_1 : ordered_ring \ud835\udd5c] [_inst_2 : add_comm_group E] [_inst_3 : module \ud835\udd5c E], \u22a5.faces = \u2205", "decl_nm": "geometry.simplicial_complex.faces_bot"}
{"formal_statement": "theorem extend_from_extends {X Y : Type*} [topological_space X] [topological_space Y]\n\t[t2_space Y] {f : X \u2192 Y} {A : set X} (hf : continuous_on f A) (x_in : x \u2208 A) :\n\t\u2200 (x : X),  extend_from A f x = f x", "decl_tp": "\u2200 {X : Type u_1} {Y : Type u_2} [_inst_1 : topological_space X] [_inst_2 : topological_space Y] [_inst_3 : t2_space Y] {f : X \u2192 Y} {A : set X}, continuous_on f A \u2192 \u2200 (x : X), x \u2208 A \u2192 extend_from A f x = f x", "decl_nm": "extend_from_extends"}
{"formal_statement": "theorem eq_of_Ico_disjoint {\u03b1 : Type v} [linear_order \u03b1] {x\u2081 x\u2082 y\u2081 y\u2082 : \u03b1}\n\t(h : disjoint (set.Ico x\u2081 x\u2082) (set.Ico y\u2081 y\u2082)) (hx : x\u2081 < x\u2082) (h2 : x\u2082 \u2208 set.Ico y\u2081 y\u2082) :\n\ty\u2081 = x\u2082", "decl_tp": "\u2200 {\u03b1 : Type v} [_inst_1 : linear_order \u03b1] {x\u2081 x\u2082 y\u2081 y\u2082 : \u03b1}, disjoint (set.Ico x\u2081 x\u2082) (set.Ico y\u2081 y\u2082) \u2192 x\u2081 < x\u2082 \u2192 x\u2082 \u2208 set.Ico y\u2081 y\u2082 \u2192 y\u2081 = x\u2082", "decl_nm": "set.eq_of_Ico_disjoint"}
{"formal_statement": "theorem div_mem_center\u2080 {M : Type*} [group_with_zero M] {a b : M} (a : M) :\n\ta \u2208 set.center  b \u2208 set.center  a / b \u2208 set.center M", "decl_tp": "\u2200 {M : Type u_1} [_inst_1 : group_with_zero M] {a b : M}, a \u2208 set.center M \u2192 b \u2208 set.center M \u2192 a / b \u2208 set.center M", "decl_nm": "set.div_mem_center\u2080"}
{"formal_statement": "theorem measure_empty {\u03b1 : Type*} [measurable_space \u03b1] {\u03bc : measure_theory.measure \u03b1} :\n\t\u21d1\u03bc \u2205 = 0", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : measurable_space \u03b1] {\u03bc : measure_theory.measure \u03b1}, \u21d1\u03bc \u2205 = 0", "decl_nm": "measure_theory.measure_empty"}
{"formal_statement": "theorem indep_set_iff_measure_inter_eq_mul {\u03b1 : Type*} [measurable_space \u03b1]\n\t{s t : set \u03b1} (hs_meas : measurable_set s) (ht_meas : measurable_set t) :\n\t\u2200 (\u03bc : auto_param (measure_theory.measure \u03b1) (name.mk_string \"volume_tac\" (name.mk_string \"measure_theory\" name.anonymous)))\n\t[measure_theory.is_probability_measure \u03bc], probability_theory.indep_set s t \u03bc \u2194 \u21d1\u03bc (s \u2229 t) = \u21d1\u03bc s * \u21d1\u03bc t", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : measurable_space \u03b1] {s t : set \u03b1}, measurable_set s \u2192 measurable_set t \u2192 \u2200 (\u03bc : auto_param (measure_theory.measure \u03b1) (name.mk_string \"volume_tac\" (name.mk_string \"measure_theory\" name.anonymous))) [_inst_2 : measure_theory.is_probability_measure \u03bc], probability_theory.indep_set s t \u03bc \u2194 \u21d1\u03bc (s \u2229 t) = \u21d1\u03bc s * \u21d1\u03bc t", "decl_nm": "probability_theory.indep_set_iff_measure_inter_eq_mul"}
{"formal_statement": "theorem cast_succ_injective (n : \u2115) :\n\tfunction.injective \u21d1fin.cast_succ", "decl_tp": "\u2200 (n : \u2115), function.injective \u21d1fin.cast_succ", "decl_nm": "fin.cast_succ_injective"}
{"formal_statement": "theorem congr_arg {F : Type u \u2192 Type v} [applicative F] [is_lawful_applicative F]\n\t{G : Type u \u2192 Type w} [applicative G] [is_lawful_applicative G] (\u03b7 : applicative_transformation F G)\n\t{\u03b1 : Type u} {x y : F \u03b1} (h : x = y) :\n\t\u21d1\u03b7 x = \u21d1\u03b7 y", "decl_tp": "\u2200 {F : Type u \u2192 Type v} [_inst_1 : applicative F] [_inst_2 : is_lawful_applicative F] {G : Type u \u2192 Type w} [_inst_3 : applicative G] [_inst_4 : is_lawful_applicative G] (\u03b7 : applicative_transformation F G) {\u03b1 : Type u} {x y : F \u03b1}, x = y \u2192 \u21d1\u03b7 x = \u21d1\u03b7 y", "decl_nm": "applicative_transformation.congr_arg"}
{"formal_statement": "theorem sub {\u03b1 : Type u} {G : Type w} [topological_space G] [has_sub G]\n\t[has_continuous_sub G] [topological_space \u03b1] {f g : \u03b1 \u2192 G} {s : set \u03b1}\n\t{x : \u03b1} (hf : continuous_within_at f s x) (hg : continuous_within_at g s x) :\n\tcontinuous_within_at (\u03bb (x : \u03b1), f x - g x) s x", "decl_tp": "\u2200 {\u03b1 : Type u} {G : Type w} [_inst_1 : topological_space G] [_inst_2 : has_sub G] [_inst_3 : has_continuous_sub G] [_inst_4 : topological_space \u03b1] {f g : \u03b1 \u2192 G} {s : set \u03b1} {x : \u03b1}, continuous_within_at f s x \u2192 continuous_within_at g s x \u2192 continuous_within_at (\u03bb (x : \u03b1), f x - g x) s x", "decl_nm": "continuous_within_at.sub"}
{"formal_statement": "theorem val_lt {n : \u2115} [fact (0 < n)] (a : zmod n) :\n\ta.val < n", "decl_tp": "\u2200 {n : \u2115} [_inst_1 : fact (0 < n)] (a : zmod n), a.val < n", "decl_nm": "zmod.val_lt"}
{"formal_statement": "theorem measurable_coe_fn {\u03b1 \u03b2 : Type*} {m : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1}\n\t[normed_group \u03b2] [measurable_space \u03b2] [topological_space.second_countable_topology \u03b2]\n\t[borel_space \u03b2] (f : \u21a5(measure_theory.Lp \u03b2 1 \u03bc)) :\n\tmeasurable \u21d1f", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {m : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} [_inst_1 : normed_group \u03b2] [_inst_3 : measurable_space \u03b2] [_inst_6 : topological_space.second_countable_topology \u03b2] [_inst_7 : borel_space \u03b2] (f : \u21a5(measure_theory.Lp \u03b2 1 \u03bc)), measurable \u21d1f", "decl_nm": "measure_theory.L1.measurable_coe_fn"}
{"formal_statement": "theorem tensor_right_obj {C : Type u} [category_theory.category C] [category_theory.monoidal_category C]\n\t(X Y : C) :\n\t(category_theory.monoidal_category.tensor_right X).obj Y = Y \u2297 X", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] [_inst_2 : category_theory.monoidal_category C] (X Y : C), (category_theory.monoidal_category.tensor_right X).obj Y = Y \u2297 X", "decl_nm": "category_theory.monoidal_category.tensor_right_obj"}
{"formal_statement": "theorem tensor_obj_obj {C : Type u\u2081} [category_theory.category C] {D : Type u\u2082}\n\t[category_theory.category D] [category_theory.monoidal_category D] {F G : C \u2964 D}\n\t{X : C} :\n\t(F \u2297 G).obj X = F.obj X \u2297 G.obj X", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {D : Type u\u2082} [_inst_2 : category_theory.category D] [_inst_3 : category_theory.monoidal_category D] {F G : C \u2964 D} {X : C}, (F \u2297 G).obj X = F.obj X \u2297 G.obj X", "decl_nm": "category_theory.monoidal.tensor_obj_obj"}
{"formal_statement": "theorem coe_one {\u03b1 \u03b2 : Type*} [topological_space \u03b1] [topological_space \u03b2]\n\t[has_one \u03b2] :\n\t\u21d11 = 1", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : topological_space \u03b1] [_inst_2 : topological_space \u03b2] [_inst_3 : has_one \u03b2], \u21d11 = 1", "decl_nm": "continuous_map.coe_one"}
{"formal_statement": "theorem trans_le {\u03b1 : Type u} [preorder \u03b1] {x y z : \u03b1} (h1 : x = y) (h2 : y \u2264 z) :\n\tx \u2264 z", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : preorder \u03b1] {x y z : \u03b1}, x = y \u2192 y \u2264 z \u2192 x \u2264 z", "decl_nm": "eq.trans_le"}
{"formal_statement": "theorem monic_scale_roots_iff {R : Type*} [comm_ring R] {p : polynomial R}\n\t(s : R) :\n\t(scale_roots p s).monic \u2194 p.monic", "decl_tp": "\u2200 {R : Type u_3} [_inst_4 : comm_ring R] {p : polynomial R} (s : R), (scale_roots p s).monic \u2194 p.monic", "decl_nm": "monic_scale_roots_iff"}
{"formal_statement": "theorem annihilator_mono {R : Type u} {M : Type v} [comm_semiring R] [add_comm_monoid M]\n\t[module R M] {N P : submodule R M} (h : N \u2264 P) :\n\tP.annihilator \u2264 N.annihilator", "decl_tp": "\u2200 {R : Type u} {M : Type v} [_inst_1 : comm_semiring R] [_inst_2 : add_comm_monoid M] [_inst_3 : module R M] {N P : submodule R M}, N \u2264 P \u2192 P.annihilator \u2264 N.annihilator", "decl_nm": "submodule.annihilator_mono"}
{"formal_statement": "theorem measurable_to_real :\n\tmeasurable ennreal.to_real", "decl_tp": "measurable ennreal.to_real", "decl_nm": "ennreal.measurable_to_real"}
{"formal_statement": "theorem neg_le {\u03b1 : Type u} [add_group \u03b1] [has_le \u03b1] [covariant_class \u03b1 \u03b1 has_add.add has_le.le]\n\t[covariant_class \u03b1 \u03b1 (function.swap has_add.add) has_le.le] {a b : \u03b1} :\n\t-a \u2264 b \u2194 -b \u2264 a", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : add_group \u03b1] [_inst_2 : has_le \u03b1] [_inst_3 : covariant_class \u03b1 \u03b1 has_add.add has_le.le] [_inst_4 : covariant_class \u03b1 \u03b1 (function.swap has_add.add) has_le.le] {a b : \u03b1}, -a \u2264 b \u2194 -b \u2264 a", "decl_nm": "neg_le"}
{"formal_statement": "theorem of_disjoint_Union {\u03b1 \u03b2 : Type*} {m : measurable_space \u03b1} {M : Type*}\n\t[add_comm_monoid M] [topological_space M] [t2_space M] {v : measure_theory.vector_measure \u03b1 M}\n\t[encodable \u03b2] {f : \u03b2 \u2192 set \u03b1} (hf\u2082 : pairwise (disjoint on f)) :\n\t(\u2200 (i : \u03b2), measurable_set (f i)) \u2192  \u21d1v (\u22c3 (i : \u03b2), f i) = \u2211' (i : \u03b2), \u21d1v (f i)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {m : measurable_space \u03b1} {M : Type u_3} [_inst_1 : add_comm_monoid M] [_inst_2 : topological_space M] [_inst_3 : t2_space M] {v : measure_theory.vector_measure \u03b1 M} [_inst_4 : encodable \u03b2] {f : \u03b2 \u2192 set \u03b1}, (\u2200 (i : \u03b2), measurable_set (f i)) \u2192 pairwise (disjoint on f) \u2192 \u21d1v (\u22c3 (i : \u03b2), f i) = \u2211' (i : \u03b2), \u21d1v (f i)", "decl_nm": "measure_theory.vector_measure.of_disjoint_Union"}
{"formal_statement": "theorem coeff_sum {R : Type u} {\u03c3 : Type*} [comm_semiring R] {X : Type*}\n\t(s : finset X) (f : X \u2192 mv_polynomial \u03c3 R) (m : \u03c3 \u2192\u2080 \u2115) :\n\tmv_polynomial.coeff m (s.sum (\u03bb (x : X), f x)) = s.sum (\u03bb (x : X), mv_polynomial.coeff m (f x))", "decl_tp": "\u2200 {R : Type u} {\u03c3 : Type u_1} [_inst_1 : comm_semiring R] {X : Type u_2} (s : finset X) (f : X \u2192 mv_polynomial \u03c3 R) (m : \u03c3 \u2192\u2080 \u2115), mv_polynomial.coeff m (s.sum (\u03bb (x : X), f x)) = s.sum (\u03bb (x : X), mv_polynomial.coeff m (f x))", "decl_nm": "mv_polynomial.coeff_sum"}
{"formal_statement": "theorem apply {\u03b1 n : Type*} {A : matrix n n \u03b1} (h : A.is_symm) :\n\t\u2200 (i j : n), A j i = A i j", "decl_tp": "\u2200 {\u03b1 : Type u_1} {n : Type u_3} {A : matrix n n \u03b1}, A.is_symm \u2192 \u2200 (i j : n), A j i = A i j", "decl_nm": "matrix.is_symm.apply"}
{"formal_statement": "theorem preimage_const_add_Iio {G : Type u} [ordered_add_comm_group G]\n\t(a b : G) :\n\t(\u03bb (x : G), a + x) \u207b\u00b9' set.Iio b = set.Iio (b - a)", "decl_tp": "\u2200 {G : Type u} [_inst_1 : ordered_add_comm_group G] (a b : G), (\u03bb (x : G), a + x) \u207b\u00b9' set.Iio b = set.Iio (b - a)", "decl_nm": "set.preimage_const_add_Iio"}
{"formal_statement": "theorem sub_is_limit {a b : ordinal} (l : a.is_limit) (h : b < a) :\n\t(a - b).is_limit", "decl_tp": "\u2200 {a b : ordinal}, a.is_limit \u2192 b < a \u2192 (a - b).is_limit", "decl_nm": "ordinal.sub_is_limit"}
{"formal_statement": "theorem map_map {L : first_order.language} {M N : Type*} [L.Structure M]\n\t[L.Structure N] {P : Type*} [L.Structure P] (S : L.substructure M) (g : L.hom N P)\n\t(f : L.hom M N) :\n\tfirst_order.language.substructure.map g (first_order.language.substructure.map f S) = first_order.language.substructure.map (g.comp f) S", "decl_tp": "\u2200 {L : first_order.language} {M : Type u_3} {N : Type u_4} [_inst_1 : L.Structure M] [_inst_2 : L.Structure N] {P : Type u_5} [_inst_3 : L.Structure P] (S : L.substructure M) (g : L.hom N P) (f : L.hom M N), first_order.language.substructure.map g (first_order.language.substructure.map f S) = first_order.language.substructure.map (g.comp f) S", "decl_nm": "first_order.language.substructure.map_map"}
{"formal_statement": "theorem adjugate_eq_one_of_card_eq_one {n : Type u} [decidable_eq n] [fintype n]\n\t{\u03b1 : Type v} [comm_ring \u03b1] {A : matrix n n \u03b1} (h : fintype.card n = 1) :\n\tA.adjugate = 1", "decl_tp": "\u2200 {n : Type u} [_inst_1 : decidable_eq n] [_inst_2 : fintype n] {\u03b1 : Type v} [_inst_3 : comm_ring \u03b1] {A : matrix n n \u03b1}, fintype.card n = 1 \u2192 A.adjugate = 1", "decl_nm": "matrix.adjugate_eq_one_of_card_eq_one"}
{"formal_statement": "theorem not_prime_mul {a b : \u2115} (a1 : 1 < a) (b1 : 1 < b) :\n\t\u00acnat.prime (a * b)", "decl_tp": "\u2200 {a b : \u2115}, 1 < a \u2192 1 < b \u2192 \u00acnat.prime (a * b)", "decl_nm": "nat.not_prime_mul"}
{"formal_statement": "theorem nonempty_range_succ {n : \u2115} :\n\t(finset.range (n + 1)).nonempty", "decl_tp": "\u2200 {n : \u2115}, (finset.range (n + 1)).nonempty", "decl_nm": "finset.nonempty_range_succ"}
{"formal_statement": "theorem hom_as_subtype (M : Type*) [monoid M] (X : Type u) [mul_action M X]\n\t(p q : category_theory.action_category M X) :\n\t(p \u27f6 q) = {m // m \u2022 p.back = q.back}", "decl_tp": "\u2200 (M : Type u_1) [_inst_1 : monoid M] (X : Type u) [_inst_2 : mul_action M X] (p q : category_theory.action_category M X), (p \u27f6 q) = {m // m \u2022 p.back = q.back}", "decl_nm": "category_theory.action_category.hom_as_subtype"}
{"formal_statement": "theorem rpow_le_rpow_of_exponent_le {x y z : \u211d} (hx : 1 \u2264 x) (hyz : y \u2264 z) :\n\tx ^ y \u2264 x ^ z", "decl_tp": "\u2200 {x y z : \u211d}, 1 \u2264 x \u2192 y \u2264 z \u2192 x ^ y \u2264 x ^ z", "decl_nm": "real.rpow_le_rpow_of_exponent_le"}
{"formal_statement": "theorem to_module_lof (R : Type u) [semiring R] {\u03b9 : Type v} [dec_\u03b9 : decidable_eq \u03b9]\n\t{M : \u03b9 \u2192 Type w} [\u03a0 (i : \u03b9), add_comm_monoid (M i)] [\u03a0 (i : \u03b9), module R (M i)]\n\t{N : Type u\u2081} [add_comm_monoid N] [module R N] {\u03c6 : \u03a0 (i : \u03b9), M i \u2192\u2097[R] N}\n\t(i : \u03b9) (x : M i) :\n\t\u21d1(direct_sum.to_module R \u03b9 N \u03c6) (\u21d1(direct_sum.lof R \u03b9 M i) x) = \u21d1(\u03c6 i) x", "decl_tp": "\u2200 (R : Type u) [_inst_1 : semiring R] {\u03b9 : Type v} [dec_\u03b9 : decidable_eq \u03b9] {M : \u03b9 \u2192 Type w} [_inst_2 : \u03a0 (i : \u03b9), add_comm_monoid (M i)] [_inst_3 : \u03a0 (i : \u03b9), module R (M i)] {N : Type u\u2081} [_inst_4 : add_comm_monoid N] [_inst_5 : module R N] {\u03c6 : \u03a0 (i : \u03b9), M i \u2192\u2097[R] N} (i : \u03b9) (x : M i), \u21d1(direct_sum.to_module R \u03b9 N \u03c6) (\u21d1(direct_sum.lof R \u03b9 M i) x) = \u21d1(\u03c6 i) x", "decl_nm": "direct_sum.to_module_lof"}
{"formal_statement": "theorem eq_zero_of_sum_eq_zero {\u03b2 : Type u} {\u03b1 : Type v} [add_comm_monoid \u03b2]\n\t{s : finset \u03b1} {f : \u03b1 \u2192 \u03b2} {a : \u03b1} (hp : s.sum (\u03bb (x : \u03b1), f x) = 0) (hx : x \u2208 s) :\n\t(\u2200 (x : \u03b1),  x \u2260 a \u2192 f x = 0) \u2192 \u2200 (x : \u03b1),  f x = 0", "decl_tp": "\u2200 {\u03b2 : Type u} {\u03b1 : Type v} [_inst_1 : add_comm_monoid \u03b2] {s : finset \u03b1} {f : \u03b1 \u2192 \u03b2} {a : \u03b1}, s.sum (\u03bb (x : \u03b1), f x) = 0 \u2192 (\u2200 (x : \u03b1), x \u2208 s \u2192 x \u2260 a \u2192 f x = 0) \u2192 \u2200 (x : \u03b1), x \u2208 s \u2192 f x = 0", "decl_nm": "finset.eq_zero_of_sum_eq_zero"}
{"formal_statement": "theorem sdiff_le_sdiff_of_sup_le_sup_right {\u03b1 : Type u} {x y z : \u03b1} [generalized_boolean_algebra \u03b1]\n\t(h : x \u2294 z \u2264 y \u2294 z) :\n\tx \\ z \u2264 y \\ z", "decl_tp": "\u2200 {\u03b1 : Type u} {x y z : \u03b1} [_inst_1 : generalized_boolean_algebra \u03b1], x \u2294 z \u2264 y \u2294 z \u2192 x \\ z \u2264 y \\ z", "decl_nm": "sdiff_le_sdiff_of_sup_le_sup_right"}
{"formal_statement": "theorem eq_bot_iff {R M : Type*} [semiring R] [add_comm_monoid M] [module R M]\n\t(p : submodule R M) :\n\tp = \u22a5 \u2194 \u2200 (x : M), x \u2208 p \u2192 x = 0", "decl_tp": "\u2200 {R : Type u_1} {M : Type u_3} [_inst_1 : semiring R] [_inst_3 : add_comm_monoid M] [_inst_4 : module R M] (p : submodule R M), p = \u22a5 \u2194 \u2200 (x : M), x \u2208 p \u2192 x = 0", "decl_nm": "submodule.eq_bot_iff"}
{"formal_statement": "theorem singleton_inter_of_mem {\u03b1 : Type*} [decidable_eq \u03b1] {a : \u03b1} {s : finset \u03b1}\n\t(H : a \u2208 s) :\n\t{a} \u2229 s = {a}", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : decidable_eq \u03b1] {a : \u03b1} {s : finset \u03b1}, a \u2208 s \u2192 {a} \u2229 s = {a}", "decl_nm": "finset.singleton_inter_of_mem"}
{"formal_statement": "theorem dual_map_comp_dual_map {R : Type*} [comm_ring R] {M\u2081 M\u2082 : Type*}\n\t[add_comm_group M\u2081] [module R M\u2081] [add_comm_group M\u2082] [module R M\u2082] {M\u2083 : Type*}\n\t[add_comm_group M\u2083] [module R M\u2083] (f : M\u2081 \u2192\u2097[R] M\u2082) (g : M\u2082 \u2192\u2097[R] M\u2083) :\n\tf.dual_map.comp g.dual_map = (g.comp f).dual_map", "decl_tp": "\u2200 {R : Type u_1} [_inst_1 : comm_ring R] {M\u2081 : Type u_2} {M\u2082 : Type u_3} [_inst_2 : add_comm_group M\u2081] [_inst_3 : module R M\u2081] [_inst_4 : add_comm_group M\u2082] [_inst_5 : module R M\u2082] {M\u2083 : Type u_4} [_inst_6 : add_comm_group M\u2083] [_inst_7 : module R M\u2083] (f : M\u2081 \u2192\u2097[R] M\u2082) (g : M\u2082 \u2192\u2097[R] M\u2083), f.dual_map.comp g.dual_map = (g.comp f).dual_map", "decl_nm": "linear_map.dual_map_comp_dual_map"}
{"formal_statement": "theorem integral_closure_eq_bot (R : Type*) [comm_ring R] [is_domain R]\n\t[iic : is_integrally_closed R] (K : Type*) [field K] [algebra R K] [is_fraction_ring R K] :\n\tintegral_closure R K = \u22a5", "decl_tp": "\u2200 (R : Type u_1) [_inst_1 : comm_ring R] [_inst_2 : is_domain R] [iic : is_integrally_closed R] (K : Type u_2) [_inst_3 : field K] [_inst_4 : algebra R K] [_inst_5 : is_fraction_ring R K], integral_closure R K = \u22a5", "decl_nm": "is_integrally_closed.integral_closure_eq_bot"}
{"formal_statement": "theorem normal_iff_eq_add_cosets {\u03b1 : Type*} [add_group \u03b1] (s : add_subgroup \u03b1) :\n\ts.normal \u2194 \u2200 (g : \u03b1), left_add_coset g \u2191s = right_add_coset \u2191s g", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : add_group \u03b1] (s : add_subgroup \u03b1), s.normal \u2194 \u2200 (g : \u03b1), left_add_coset g \u2191s = right_add_coset \u2191s g", "decl_nm": "normal_iff_eq_add_cosets"}
{"formal_statement": "theorem inv {G : Type*} [group G] [preorder G] [covariant_class G G has_mul.mul has_le.le]\n\t[covariant_class G G (function.swap has_mul.mul) has_le.le] {s : set G}\n\t(h : bdd_below s) :\n\tbdd_above s\u207b\u00b9", "decl_tp": "\u2200 {G : Type u_1} [_inst_1 : group G] [_inst_2 : preorder G] [_inst_3 : covariant_class G G has_mul.mul has_le.le] [_inst_4 : covariant_class G G (function.swap has_mul.mul) has_le.le] {s : set G}, bdd_below s \u2192 bdd_above s\u207b\u00b9", "decl_nm": "bdd_below.inv"}
{"formal_statement": "theorem symm {\u03b1 \u03b2 : Type*} [normed_group \u03b2] {u v : \u03b1 \u2192 \u03b2} {l : filter \u03b1}\n\t(h : asymptotics.is_equivalent u v l) :\n\tasymptotics.is_equivalent v u l", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : normed_group \u03b2] {u v : \u03b1 \u2192 \u03b2} {l : filter \u03b1}, asymptotics.is_equivalent u v l \u2192 asymptotics.is_equivalent v u l", "decl_nm": "asymptotics.is_equivalent.symm"}
{"formal_statement": "theorem mul_nat {x : \u211d} (h : irrational x) (hm : m \u2260 0) :\n\t\u2200 {m : \u2115},  irrational (x * \u2191m)", "decl_tp": "\u2200 {x : \u211d}, irrational x \u2192 \u2200 {m : \u2115}, m \u2260 0 \u2192 irrational (x * \u2191m)", "decl_nm": "irrational.mul_nat"}
{"formal_statement": "theorem inv_of_one {\u03b1 : Type u} [monoid \u03b1] [invertible 1] :\n\t\u215f 1 = 1", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : monoid \u03b1] [_inst_2 : invertible 1], \u215f 1 = 1", "decl_nm": "inv_of_one"}
{"formal_statement": "theorem mk_lt {f g : cau_seq \u211a has_abs.abs} :\n\treal.mk f < real.mk g \u2194 f < g", "decl_tp": "\u2200 {f g : cau_seq \u211a has_abs.abs}, real.mk f < real.mk g \u2194 f < g", "decl_nm": "real.mk_lt"}
{"formal_statement": "theorem coe_erase {\u03b1 : Type*} [decidable_eq \u03b1] (l : list \u03b1) (a : \u03b1) :\n\t\u2191l.erase a = \u2191(l.erase a)", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : decidable_eq \u03b1] (l : list \u03b1) (a : \u03b1), \u2191l.erase a = \u2191(l.erase a)", "decl_nm": "multiset.coe_erase"}
{"formal_statement": "theorem of_le {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c] {E : Type*} [normed_group E]\n\t[normed_space \ud835\udd5c E] {F : Type*} [normed_group F] [normed_space \ud835\udd5c F] {f : E \u2192 F}\n\t{x : E} {m n : with_top \u2115} (h : times_cont_diff_at \ud835\udd5c n f x) (hmn : m \u2264 n) :\n\ttimes_cont_diff_at \ud835\udd5c m f x", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {F : Type u_3} [_inst_4 : normed_group F] [_inst_5 : normed_space \ud835\udd5c F] {f : E \u2192 F} {x : E} {m n : with_top \u2115}, times_cont_diff_at \ud835\udd5c n f x \u2192 m \u2264 n \u2192 times_cont_diff_at \ud835\udd5c m f x", "decl_nm": "times_cont_diff_at.of_le"}
{"formal_statement": "theorem ae_measurable'_of_ae_measurable'_trim {\u03b1 \u03b2 : Type*} {m m0 m0' : measurable_space \u03b1}\n\t[measurable_space \u03b2] (hm0 : m0 \u2264 m0') {\u03bc : measure_theory.measure \u03b1} {f : \u03b1 \u2192 \u03b2}\n\t(hf : measure_theory.ae_measurable' m f (\u03bc.trim hm0)) :\n\tmeasure_theory.ae_measurable' m f \u03bc", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {m m0 m0' : measurable_space \u03b1} [_inst_1 : measurable_space \u03b2] (hm0 : m0 \u2264 m0') {\u03bc : measure_theory.measure \u03b1} {f : \u03b1 \u2192 \u03b2}, measure_theory.ae_measurable' m f (\u03bc.trim hm0) \u2192 measure_theory.ae_measurable' m f \u03bc", "decl_nm": "measure_theory.ae_measurable'_of_ae_measurable'_trim"}
{"formal_statement": "theorem mdifferentiable_at {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c] {E : Type*}\n\t[normed_group E] [normed_space \ud835\udd5c E] {E' : Type*} [normed_group E'] [normed_space \ud835\udd5c E']\n\t{H : Type*} [topological_space H] {H' : Type*} [topological_space H']\n\t{I : model_with_corners \ud835\udd5c E H} {I' : model_with_corners \ud835\udd5c E' H'} {M : Type*}\n\t[topological_space M] [charted_space H M] {M' : Type*} [topological_space M']\n\t[charted_space H' M'] (f : times_cont_mdiff_map I I' M M' \u22a4) {x : M} :\n\tmdifferentiable_at I I' \u21d1f x", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {E' : Type u_3} [_inst_4 : normed_group E'] [_inst_5 : normed_space \ud835\udd5c E'] {H : Type u_4} [_inst_6 : topological_space H] {H' : Type u_5} [_inst_7 : topological_space H'] {I : model_with_corners \ud835\udd5c E H} {I' : model_with_corners \ud835\udd5c E' H'} {M : Type u_6} [_inst_8 : topological_space M] [_inst_9 : charted_space H M] {M' : Type u_7} [_inst_10 : topological_space M'] [_inst_11 : charted_space H' M'] (f : times_cont_mdiff_map I I' M M' \u22a4) {x : M}, mdifferentiable_at I I' \u21d1f x", "decl_nm": "times_cont_mdiff_map.mdifferentiable_at"}
{"formal_statement": "theorem sub_one_lt_floor {\u03b1 : Type*} [linear_ordered_ring \u03b1] [floor_ring \u03b1]\n\t(a : \u03b1) :\n\ta - 1 < \u2191\u230aa\u230b", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : linear_ordered_ring \u03b1] [_inst_2 : floor_ring \u03b1] (a : \u03b1), a - 1 < \u2191\u230aa\u230b", "decl_nm": "int.sub_one_lt_floor"}
{"formal_statement": "theorem mem_Iic {\u03b1 : Type u} [preorder \u03b1] {b x : \u03b1} :\n\tx \u2208 set.Iic b \u2194 x \u2264 b", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : preorder \u03b1] {b x : \u03b1}, x \u2208 set.Iic b \u2194 x \u2264 b", "decl_nm": "set.mem_Iic"}
{"formal_statement": "theorem map_right_map_left {A : Type u\u2081} [category_theory.category A] {B : Type u\u2082}\n\t[category_theory.category B] {T : Type u\u2083} [category_theory.category T]\n\t(L : A \u2964 T) {R\u2081 R\u2082 : B \u2964 T} (r : R\u2081 \u27f6 R\u2082) (X Y : category_theory.comma L R\u2081)\n\t(f : X \u27f6 Y) :\n\t((category_theory.comma.map_right L r).map f).left = f.left", "decl_tp": "\u2200 {A : Type u\u2081} [_inst_1 : category_theory.category A] {B : Type u\u2082} [_inst_2 : category_theory.category B] {T : Type u\u2083} [_inst_3 : category_theory.category T] (L : A \u2964 T) {R\u2081 R\u2082 : B \u2964 T} (r : R\u2081 \u27f6 R\u2082) (X Y : category_theory.comma L R\u2081) (f : X \u27f6 Y), ((category_theory.comma.map_right L r).map f).left = f.left", "decl_nm": "category_theory.comma.map_right_map_left"}
{"formal_statement": "theorem r_mul_r {n : \u2115} (i j : zmod n) :\n\tdihedral_group.r i * dihedral_group.r j = dihedral_group.r (i + j)", "decl_tp": "\u2200 {n : \u2115} (i j : zmod n), dihedral_group.r i * dihedral_group.r j = dihedral_group.r (i + j)", "decl_nm": "dihedral_group.r_mul_r"}
{"formal_statement": "theorem scanl_nil {\u03b1 \u03b2 : Type*} (f : \u03b2 \u2192 \u03b1 \u2192 \u03b2) (b : \u03b2) :\n\tvector.scanl f b vector.nil = b::\u1d65 vector.nil", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} (f : \u03b2 \u2192 \u03b1 \u2192 \u03b2) (b : \u03b2), vector.scanl f b vector.nil = b::\u1d65 vector.nil", "decl_nm": "vector.scanl_nil"}
{"formal_statement": "theorem sup'_mem {\u03b1 : Type*} [semilattice_sup \u03b1] (s : set \u03b1) :\n\t(\u2200 (x y : \u03b1), x \u2208 s \u2192 y \u2208 s \u2192 x \u2294 y \u2208 s) \u2192 \u2200 {\u03b9 : Type*} (t : finset \u03b9)\n\t(H : t.nonempty) (p : \u03b9 \u2192 \u03b1), (\u2200 (i : \u03b9), i \u2208 t \u2192 p i \u2208 s) \u2192 t.sup' H p \u2208 s", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : semilattice_sup \u03b1] (s : set \u03b1), (\u2200 (x y : \u03b1), x \u2208 s \u2192 y \u2208 s \u2192 x \u2294 y \u2208 s) \u2192 \u2200 {\u03b9 : Type u_2} (t : finset \u03b9) (H : t.nonempty) (p : \u03b9 \u2192 \u03b1), (\u2200 (i : \u03b9), i \u2208 t \u2192 p i \u2208 s) \u2192 t.sup' H p \u2208 s", "decl_nm": "finset.sup'_mem"}
{"formal_statement": "theorem coe_val_eq_self {n : \u2115} (a : fin (n + 1)) :\n\t\u2191(a.val) = a", "decl_tp": "\u2200 {n : \u2115} (a : fin (n + 1)), \u2191(a.val) = a", "decl_nm": "fin.coe_val_eq_self"}
{"formal_statement": "theorem div_zero (a : \u2124) :\n\ta / 0 = 0", "decl_tp": "\u2200 (a : \u2124), a / 0 = 0", "decl_nm": "int.div_zero"}
{"formal_statement": "theorem dist_mul_left (k n m : \u2115) :\n\t(k * n).dist (k * m) = k * n.dist m", "decl_tp": "\u2200 (k n m : \u2115), (k * n).dist (k * m) = k * n.dist m", "decl_nm": "nat.dist_mul_left"}
{"formal_statement": "theorem add_mem_iff_right {R : Type u} {M : Type v} [ring R] [add_comm_group M]\n\t{module_M : module R M} (p : submodule R M) {x y : M} :\n\tx \u2208 p \u2192 (x + y \u2208 p \u2194 y \u2208 p)", "decl_tp": "\u2200 {R : Type u} {M : Type v} [_inst_1 : ring R] [_inst_2 : add_comm_group M] {module_M : module R M} (p : submodule R M) {x y : M}, x \u2208 p \u2192 (x + y \u2208 p \u2194 y \u2208 p)", "decl_nm": "submodule.add_mem_iff_right"}
{"formal_statement": "theorem divisors_subset_proper_divisors {n m : \u2115} (hzero : n \u2260 0) (h : m \u2223 n)\n\t(hdiff : m \u2260 n) :\n\tm.divisors \u2286 n.proper_divisors", "decl_tp": "\u2200 {n m : \u2115}, n \u2260 0 \u2192 m \u2223 n \u2192 m \u2260 n \u2192 m.divisors \u2286 n.proper_divisors", "decl_nm": "nat.divisors_subset_proper_divisors"}
{"formal_statement": "theorem sum_arrow_equiv_prod_arrow_symm_apply_inl {\u03b1 \u03b2 \u03b3 : Type*} (f : \u03b1 \u2192 \u03b3)\n\t(g : \u03b2 \u2192 \u03b3) (a : \u03b1) :\n\t\u21d1((equiv.sum_arrow_equiv_prod_arrow \u03b1 \u03b2 \u03b3).symm) (f, g) (sum.inl a) = f a", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {\u03b3 : Type u_3} (f : \u03b1 \u2192 \u03b3) (g : \u03b2 \u2192 \u03b3) (a : \u03b1), \u21d1((equiv.sum_arrow_equiv_prod_arrow \u03b1 \u03b2 \u03b3).symm) (f, g) (sum.inl a) = f a", "decl_nm": "equiv.sum_arrow_equiv_prod_arrow_symm_apply_inl"}
{"formal_statement": "theorem coe_eq_val {n : \u2115} (a : fin n) :\n\t\u2191a = a.val", "decl_tp": "\u2200 {n : \u2115} (a : fin n), \u2191a = a.val", "decl_nm": "fin.coe_eq_val"}
{"formal_statement": "theorem congr {\u03b1 \u03b2 : Type*} {m m0 : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1}\n\t[measurable_space \u03b2] {f g : \u03b1 \u2192 \u03b2} (hf : measure_theory.ae_measurable' m f \u03bc)\n\t(hfg : f =\u1d50[\u03bc] g) :\n\tmeasure_theory.ae_measurable' m g \u03bc", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {m m0 : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} [_inst_1 : measurable_space \u03b2] {f g : \u03b1 \u2192 \u03b2}, measure_theory.ae_measurable' m f \u03bc \u2192 f =\u1d50[\u03bc] g \u2192 measure_theory.ae_measurable' m g \u03bc", "decl_nm": "measure_theory.ae_measurable'.congr"}
{"formal_statement": "theorem map_add_eq_zero {M N : Type*} {mM : add_zero_class M} {mN : add_zero_class N}\n\t(f : M \u2192+ N) {a b : M} (h : a + b = 0) :\n\t\u21d1f a + \u21d1f b = 0", "decl_tp": "\u2200 {M : Type u_1} {N : Type u_2} {mM : add_zero_class M} {mN : add_zero_class N} (f : M \u2192+ N) {a b : M}, a + b = 0 \u2192 \u21d1f a + \u21d1f b = 0", "decl_nm": "add_monoid_hom.map_add_eq_zero"}
{"formal_statement": "theorem norm {\ud835\udd5c E : Type*} [is_R_or_C \ud835\udd5c] [inner_product_space \ud835\udd5c E] [normed_space \u211d E]\n\t{G : Type*} [normed_group G] [normed_space \u211d G] {f : G \u2192 E} {x : G} {n : with_top \u2115}\n\t(hf : times_cont_diff_at \u211d n f x) (h0 : f x \u2260 0) :\n\ttimes_cont_diff_at \u211d n (\u03bb (y : G), \u2225f y\u2225) x", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} {E : Type u_2} [_inst_1 : is_R_or_C \ud835\udd5c] [_inst_2 : inner_product_space \ud835\udd5c E] [_inst_4 : normed_space \u211d E] {G : Type u_4} [_inst_5 : normed_group G] [_inst_6 : normed_space \u211d G] {f : G \u2192 E} {x : G} {n : with_top \u2115}, times_cont_diff_at \u211d n f x \u2192 f x \u2260 0 \u2192 times_cont_diff_at \u211d n (\u03bb (y : G), \u2225f y\u2225) x", "decl_nm": "times_cont_diff_at.norm"}
{"formal_statement": "theorem whiskering_map_hom {J : Type u\u2081} [category_theory.category J] {K : Type u\u2082}\n\t[category_theory.category K] {C : Type u\u2083} [category_theory.category C]\n\t{F : J \u2964 C} (E : K \u2964 J) (c c' : category_theory.limits.cone F) (f : c \u27f6 c') :\n\t((category_theory.limits.cones.whiskering E).map f).hom = f.hom", "decl_tp": "\u2200 {J : Type u\u2081} [_inst_1 : category_theory.category J] {K : Type u\u2082} [_inst_2 : category_theory.category K] {C : Type u\u2083} [_inst_3 : category_theory.category C] {F : J \u2964 C} (E : K \u2964 J) (c c' : category_theory.limits.cone F) (f : c \u27f6 c'), ((category_theory.limits.cones.whiskering E).map f).hom = f.hom", "decl_nm": "category_theory.limits.cones.whiskering_map_hom"}
{"formal_statement": "theorem rel_nth_le_of_lt {\u03b1 : Type uu} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {l : list \u03b1}\n\t(h : list.sorted r l) (hab : a < b) :\n\t\u2200 {a b : \u2115} (ha : a < l.length) (hb : b < l.length),  r (l.nth_le a ha)\n\t(l.nth_le b hb)", "decl_tp": "\u2200 {\u03b1 : Type uu} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {l : list \u03b1}, list.sorted r l \u2192 \u2200 {a b : \u2115} (ha : a < l.length) (hb : b < l.length), a < b \u2192 r (l.nth_le a ha) (l.nth_le b hb)", "decl_nm": "list.sorted.rel_nth_le_of_lt"}
{"formal_statement": "theorem cast_zero {\u03b1 : Type*} [has_zero \u03b1] [has_one \u03b1] [has_add \u03b1] [has_neg \u03b1] :\n\t\u21910 = 0", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : has_zero \u03b1] [_inst_2 : has_one \u03b1] [_inst_3 : has_add \u03b1] [_inst_4 : has_neg \u03b1], \u21910 = 0", "decl_nm": "int.cast_zero"}
{"formal_statement": "theorem re_add_im {K : Type*} [is_R_or_C K] (z : K) :\n\t\u2191(\u21d1is_R_or_C.re z) + \u2191(\u21d1is_R_or_C.im z) * is_R_or_C.I = z", "decl_tp": "\u2200 {K : Type u_1} [_inst_1 : is_R_or_C K] (z : K), \u2191(\u21d1is_R_or_C.re z) + \u2191(\u21d1is_R_or_C.im z) * is_R_or_C.I = z", "decl_nm": "is_R_or_C.re_add_im"}
{"formal_statement": "theorem bUnion_singleton {\u03b1 \u03b2 : Type*} [decidable_eq \u03b2] {s : finset \u03b1}\n\t{f : \u03b1 \u2192 \u03b2} :\n\ts.bUnion (\u03bb (a : \u03b1), {f a}) = finset.image f s", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : decidable_eq \u03b2] {s : finset \u03b1} {f : \u03b1 \u2192 \u03b2}, s.bUnion (\u03bb (a : \u03b1), {f a}) = finset.image f s", "decl_nm": "finset.bUnion_singleton"}
{"formal_statement": "theorem compl_eq {\u03b1 : Type u} {x y : \u03b1} [boolean_algebra.core \u03b1] (h : is_compl x y) :\n\tx\u1d9c = y", "decl_tp": "\u2200 {\u03b1 : Type u} {x y : \u03b1} [_inst_1 : boolean_algebra.core \u03b1], is_compl x y \u2192 x\u1d9c = y", "decl_nm": "is_compl.compl_eq"}
{"formal_statement": "theorem infi_insert_update {\u03b1 \u03b2 : Type*} [complete_lattice \u03b2] [decidable_eq \u03b1]\n\t{x : \u03b1} {t : finset \u03b1} (f : \u03b1 \u2192 \u03b2) {s : \u03b2} (hx : x \u2209 t) :\n\t((\u2a05 (i : \u03b1) (H : i \u2208 has_insert.insert x t), function.update f x s i) = s \u2293 \u2a05 (i : \u03b1)\n\t(H : i \u2208 t), f i)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : complete_lattice \u03b2] [_inst_2 : decidable_eq \u03b1] {x : \u03b1} {t : finset \u03b1} (f : \u03b1 \u2192 \u03b2) {s : \u03b2}, x \u2209 t \u2192 ((\u2a05 (i : \u03b1) (H : i \u2208 has_insert.insert x t), function.update f x s i) = s \u2293 \u2a05 (i : \u03b1) (H : i \u2208 t), f i)", "decl_nm": "finset.infi_insert_update"}
{"formal_statement": "theorem times_cont_mdiff {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c] {E : Type*}\n\t[normed_group E] [normed_space \ud835\udd5c E] {E' : Type*} [normed_group E'] [normed_space \ud835\udd5c E']\n\t{H : Type*} [topological_space H] {H' : Type*} [topological_space H']\n\t{I : model_with_corners \ud835\udd5c E H} {I' : model_with_corners \ud835\udd5c E' H'} {M : Type*}\n\t[topological_space M] [charted_space H M] {M' : Type*} [topological_space M']\n\t[charted_space H' M'] {n : with_top \u2115} (f : times_cont_mdiff_map I I' M M' n) :\n\ttimes_cont_mdiff I I' n \u21d1f", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {E' : Type u_3} [_inst_4 : normed_group E'] [_inst_5 : normed_space \ud835\udd5c E'] {H : Type u_4} [_inst_6 : topological_space H] {H' : Type u_5} [_inst_7 : topological_space H'] {I : model_with_corners \ud835\udd5c E H} {I' : model_with_corners \ud835\udd5c E' H'} {M : Type u_6} [_inst_8 : topological_space M] [_inst_9 : charted_space H M] {M' : Type u_7} [_inst_10 : topological_space M'] [_inst_11 : charted_space H' M'] {n : with_top \u2115} (f : times_cont_mdiff_map I I' M M' n), times_cont_mdiff I I' n \u21d1f", "decl_nm": "times_cont_mdiff_map.times_cont_mdiff"}
{"formal_statement": "theorem exists_lt {\u03b1 : Type u} [topological_space \u03b1] [linear_order \u03b1] [order_topology \u03b1]\n\t[densely_ordered \u03b1] [no_bot_order \u03b1] {a : \u03b1} {p : \u03b1 \u2192 Prop} :\n\t(\u2200\u1da0 (x : \u03b1) in nhds a, p x) \u2192 (\u2203 (b : \u03b1) (H : b < a), p b)", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : topological_space \u03b1] [_inst_2 : linear_order \u03b1] [_inst_3 : order_topology \u03b1] [_inst_4 : densely_ordered \u03b1] [_inst_5 : no_bot_order \u03b1] {a : \u03b1} {p : \u03b1 \u2192 Prop}, (\u2200\u1da0 (x : \u03b1) in nhds a, p x) \u2192 (\u2203 (b : \u03b1) (H : b < a), p b)", "decl_nm": "filter.eventually.exists_lt"}
{"formal_statement": "theorem eq_top_of_is_unit_mem {\u03b1 : Type u} [semiring \u03b1] (I : ideal \u03b1) {x : \u03b1}\n\t(hx : x \u2208 I) (h : is_unit x) :\n\tI = \u22a4", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : semiring \u03b1] (I : ideal \u03b1) {x : \u03b1}, x \u2208 I \u2192 is_unit x \u2192 I = \u22a4", "decl_nm": "ideal.eq_top_of_is_unit_mem"}
{"formal_statement": "theorem of_nat_to_znum_neg (n : \u2115) :\n\t\u2191n.to_znum_neg = -\u2191n", "decl_tp": "\u2200 (n : \u2115), \u2191n.to_znum_neg = -\u2191n", "decl_nm": "num.of_nat_to_znum_neg"}
{"formal_statement": "theorem sup_const {\u03b1 \u03b2 : Type*} [semilattice_sup \u03b1] [order_bot \u03b1] {s : finset \u03b2}\n\t(h : s.nonempty) :\n\t\u2200 (c : \u03b1), s.sup (\u03bb (_x : \u03b2), c) = c", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : semilattice_sup \u03b1] [_inst_2 : order_bot \u03b1] {s : finset \u03b2}, s.nonempty \u2192 \u2200 (c : \u03b1), s.sup (\u03bb (_x : \u03b2), c) = c", "decl_nm": "finset.sup_const"}
{"formal_statement": "theorem lipschitz {E : Type*} [normed_group E] [normed_space \u211d E] {v : picard_lindelof E}\n\t(f : v.fun_space) :\n\tlipschitz_with v.C \u21d1f", "decl_tp": "\u2200 {E : Type u_1} [_inst_1 : normed_group E] [_inst_2 : normed_space \u211d E] {v : picard_lindelof E} (f : v.fun_space), lipschitz_with v.C \u21d1f", "decl_nm": "picard_lindelof.fun_space.lipschitz"}
{"formal_statement": "theorem inner {\ud835\udd5c E : Type*} [is_R_or_C \ud835\udd5c] [inner_product_space \ud835\udd5c E] [normed_space \u211d E]\n\t{G : Type*} [normed_group G] [normed_space \u211d G] {f g : G \u2192 E} {x : G}\n\t(hf : differentiable_at \u211d f x) (hg : differentiable_at \u211d g x) :\n\tdifferentiable_at \u211d (\u03bb (x : G), has_inner.inner (f x) (g x)) x", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} {E : Type u_2} [_inst_1 : is_R_or_C \ud835\udd5c] [_inst_2 : inner_product_space \ud835\udd5c E] [_inst_4 : normed_space \u211d E] {G : Type u_4} [_inst_5 : normed_group G] [_inst_6 : normed_space \u211d G] {f g : G \u2192 E} {x : G}, differentiable_at \u211d f x \u2192 differentiable_at \u211d g x \u2192 differentiable_at \u211d (\u03bb (x : G), has_inner.inner (f x) (g x)) x", "decl_nm": "differentiable_at.inner"}
{"formal_statement": "theorem span_insert {\u03b1 : Type u} [semiring \u03b1] (x : \u03b1) (s : set \u03b1) :\n\tideal.span (has_insert.insert x s) = ideal.span {x} \u2294 ideal.span s", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : semiring \u03b1] (x : \u03b1) (s : set \u03b1), ideal.span (has_insert.insert x s) = ideal.span {x} \u2294 ideal.span s", "decl_nm": "ideal.span_insert"}
{"formal_statement": "theorem pointwise_smul_subset_iff {M R : Type*} [group M] [ring R] [mul_semiring_action M R]\n\t{a : M} {S T : subring R} :\n\ta \u2022 S \u2264 T \u2194 S \u2264 a\u207b\u00b9 \u2022 T", "decl_tp": "\u2200 {M : Type u_1} {R : Type u_2} [_inst_1 : group M] [_inst_2 : ring R] [_inst_3 : mul_semiring_action M R] {a : M} {S T : subring R}, a \u2022 S \u2264 T \u2194 S \u2264 a\u207b\u00b9 \u2022 T", "decl_nm": "subring.pointwise_smul_subset_iff"}
{"formal_statement": "theorem smul_mem_smul_set_iff\u2080 {\u03b1 \u03b2 : Type*} [group_with_zero \u03b1] [mul_action \u03b1 \u03b2]\n\t{a : \u03b1} (ha : a \u2260 0) :\n\t\u2200 (A : set \u03b2) (x : \u03b2), a \u2022 x \u2208 a \u2022 A \u2194 x \u2208 A", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : group_with_zero \u03b1] [_inst_2 : mul_action \u03b1 \u03b2] {a : \u03b1}, a \u2260 0 \u2192 \u2200 (A : set \u03b2) (x : \u03b2), a \u2022 x \u2208 a \u2022 A \u2194 x \u2208 A", "decl_nm": "smul_mem_smul_set_iff\u2080"}
{"formal_statement": "theorem symm_add_left {G : Type*} [measurable_space G] [add_group G] [has_measurable_add G]\n\t(g : G) :\n\t(measurable_equiv.add_left g).symm = measurable_equiv.add_left (-g)", "decl_tp": "\u2200 {G : Type u_1} [_inst_1 : measurable_space G] [_inst_4 : add_group G] [_inst_10 : has_measurable_add G] (g : G), (measurable_equiv.add_left g).symm = measurable_equiv.add_left (-g)", "decl_nm": "measurable_equiv.symm_add_left"}
{"formal_statement": "theorem Ico_inter_Ico_of_le {\u03b1 : Type*} [partial_order \u03b1] [locally_finite_order \u03b1]\n\t[decidable_eq \u03b1] {a b c d : \u03b1} (h : b \u2264 c) :\n\tmultiset.Ico a b \u2229 multiset.Ico c d = 0", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : partial_order \u03b1] [_inst_2 : locally_finite_order \u03b1] [_inst_3 : decidable_eq \u03b1] {a b c d : \u03b1}, b \u2264 c \u2192 multiset.Ico a b \u2229 multiset.Ico c d = 0", "decl_nm": "multiset.Ico_inter_Ico_of_le"}
{"formal_statement": "theorem ord_eq_min (\u03b1 : Type u) :\n\t(cardinal.mk \u03b1).ord = ordinal.min _ (\u03bb (i : {r // is_well_order \u03b1 r}), \u27e6{\u03b1 := \u03b1, r := i.val, wo := _}\u27e7)", "decl_tp": "\u2200 (\u03b1 : Type u), (cardinal.mk \u03b1).ord = ordinal.min _ (\u03bb (i : {r // is_well_order \u03b1 r}), \u27e6{\u03b1 := \u03b1, r := i.val, wo := _}\u27e7)", "decl_nm": "cardinal.ord_eq_min"}
{"formal_statement": "theorem fixed_eq_Inter_fixed_by (\u03b1 : Type u) (\u03b2 : Type v) [monoid \u03b1] [mul_action \u03b1 \u03b2] :\n\tmul_action.fixed_points \u03b1 \u03b2 = \u22c2 (g : \u03b1), mul_action.fixed_by \u03b1 \u03b2 g", "decl_tp": "\u2200 (\u03b1 : Type u) (\u03b2 : Type v) [_inst_1 : monoid \u03b1] [_inst_2 : mul_action \u03b1 \u03b2], mul_action.fixed_points \u03b1 \u03b2 = \u22c2 (g : \u03b1), mul_action.fixed_by \u03b1 \u03b2 g", "decl_nm": "mul_action.fixed_eq_Inter_fixed_by"}
{"formal_statement": "theorem condition {C : Type u} [category_theory.category C] {X Y Z : C}\n\t{f : X \u27f6 Y} {g : X \u27f6 Z} [category_theory.limits.has_pushout f g] :\n\tf \u226b category_theory.limits.pushout.inl = g \u226b category_theory.limits.pushout.inr", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] {X Y Z : C} {f : X \u27f6 Y} {g : X \u27f6 Z} [_inst_2 : category_theory.limits.has_pushout f g], f \u226b category_theory.limits.pushout.inl = g \u226b category_theory.limits.pushout.inr", "decl_nm": "category_theory.limits.pushout.condition"}
{"formal_statement": "theorem iso_app_inv {\u03b9 : Type*} {V : Type u} [category_theory.category V]\n\t[category_theory.limits.has_zero_morphisms V] {c : complex_shape \u03b9} {C\u2081 C\u2082 : homological_complex V c}\n\t(f : C\u2081 \u2245 C\u2082) (i : \u03b9) :\n\t(homological_complex.hom.iso_app f i).inv = f.inv.f i", "decl_tp": "\u2200 {\u03b9 : Type u_1} {V : Type u} [_inst_1 : category_theory.category V] [_inst_2 : category_theory.limits.has_zero_morphisms V] {c : complex_shape \u03b9} {C\u2081 C\u2082 : homological_complex V c} (f : C\u2081 \u2245 C\u2082) (i : \u03b9), (homological_complex.hom.iso_app f i).inv = f.inv.f i", "decl_nm": "homological_complex.hom.iso_app_inv"}
{"formal_statement": "theorem mem_cons_iff {\u03b1 : Type u} (s : wseq \u03b1) (b : \u03b1) {a : \u03b1} :\n\ta \u2208 wseq.cons b s \u2194 a = b \u2228 a \u2208 s", "decl_tp": "\u2200 {\u03b1 : Type u} (s : wseq \u03b1) (b : \u03b1) {a : \u03b1}, a \u2208 wseq.cons b s \u2194 a = b \u2228 a \u2208 s", "decl_nm": "wseq.mem_cons_iff"}
{"formal_statement": "theorem nil_diff {\u03b1 : Type u} [decidable_eq \u03b1] (l : list \u03b1) :\n\tlist.nil.diff l = list.nil", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : decidable_eq \u03b1] (l : list \u03b1), list.nil.diff l = list.nil", "decl_nm": "list.nil_diff"}
{"formal_statement": "theorem max_sub_sub_left {\u03b1 : Type u} [linear_ordered_add_comm_group \u03b1]\n\t(a b c : \u03b1) :\n\tlinear_order.max (a - b) (a - c) = a - linear_order.min b c", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : linear_ordered_add_comm_group \u03b1] (a b c : \u03b1), linear_order.max (a - b) (a - c) = a - linear_order.min b c", "decl_nm": "max_sub_sub_left"}
{"formal_statement": "theorem coe_eq_cast_succ {n : \u2115} {a : fin n} :\n\t\u2191a = \u21d1fin.cast_succ a", "decl_tp": "\u2200 {n : \u2115} {a : fin n}, \u2191a = \u21d1fin.cast_succ a", "decl_nm": "fin.coe_eq_cast_succ"}
{"formal_statement": "theorem range_find_greatest_subset {\u03b1 : Type u} {P : \u03b1 \u2192 \u2115 \u2192 Prop} [\u03a0 (x : \u03b1), decidable_pred (P x)]\n\t{b : \u2115} :\n\tset.range (\u03bb (x : \u03b1), nat.find_greatest (P x) b) \u2286 \u2191(finset.range (b + 1))", "decl_tp": "\u2200 {\u03b1 : Type u} {P : \u03b1 \u2192 \u2115 \u2192 Prop} [_inst_1 : \u03a0 (x : \u03b1), decidable_pred (P x)] {b : \u2115}, set.range (\u03bb (x : \u03b1), nat.find_greatest (P x) b) \u2286 \u2191(finset.range (b + 1))", "decl_nm": "set.range_find_greatest_subset"}
{"formal_statement": "theorem left_inv_on {\u03b1 \u03b2 : Type*} [topological_space \u03b1] [topological_space \u03b2]\n\t(e : local_homeomorph \u03b1 \u03b2) :\n\tset.left_inv_on \u21d1(e.symm) \u21d1e e.to_local_equiv.source", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : topological_space \u03b1] [_inst_2 : topological_space \u03b2] (e : local_homeomorph \u03b1 \u03b2), set.left_inv_on \u21d1(e.symm) \u21d1e e.to_local_equiv.source", "decl_nm": "local_homeomorph.left_inv_on"}
{"formal_statement": "theorem I_re {K : Type*} [is_R_or_C K] :\n\t\u21d1is_R_or_C.re is_R_or_C.I = 0", "decl_tp": "\u2200 {K : Type u_1} [_inst_1 : is_R_or_C K], \u21d1is_R_or_C.re is_R_or_C.I = 0", "decl_nm": "is_R_or_C.I_re"}
{"formal_statement": "theorem semiconj_conj {\u03b1\u2081 \u03b2\u2081 : Type*} (e : \u03b1\u2081 \u2243 \u03b2\u2081) (f : \u03b1\u2081 \u2192 \u03b1\u2081) :\n\tfunction.semiconj \u21d1e f (\u21d1(e.conj) f)", "decl_tp": "\u2200 {\u03b1\u2081 : Type u_1} {\u03b2\u2081 : Type u_2} (e : \u03b1\u2081 \u2243 \u03b2\u2081) (f : \u03b1\u2081 \u2192 \u03b1\u2081), function.semiconj \u21d1e f (\u21d1(e.conj) f)", "decl_nm": "equiv.semiconj_conj"}
{"formal_statement": "theorem eventually_all_finset {\u03b1 : Type u} {\u03b9 : Type*} (I : finset \u03b9) {l : filter \u03b1}\n\t{p : \u03b9 \u2192 \u03b1 \u2192 Prop} :\n\t(\u2200\u1da0 (x : \u03b1) in l, \u2200 (i : \u03b9), i \u2208 I \u2192 p i x) \u2194 \u2200 (i : \u03b9), i \u2208 I \u2192 (\u2200\u1da0 (x : \u03b1) in l, p i x)", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b9 : Type u_1} (I : finset \u03b9) {l : filter \u03b1} {p : \u03b9 \u2192 \u03b1 \u2192 Prop}, (\u2200\u1da0 (x : \u03b1) in l, \u2200 (i : \u03b9), i \u2208 I \u2192 p i x) \u2194 \u2200 (i : \u03b9), i \u2208 I \u2192 (\u2200\u1da0 (x : \u03b1) in l, p i x)", "decl_nm": "filter.eventually_all_finset"}
{"formal_statement": "theorem mem_perms_of_list_iff {\u03b1 : Type*} [decidable_eq \u03b1] {l : list \u03b1}\n\t{f : equiv.perm \u03b1} :\n\tf \u2208 perms_of_list l \u2194 \u2200 {x : \u03b1}, \u21d1f x \u2260 x \u2192 x \u2208 l", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : decidable_eq \u03b1] {l : list \u03b1} {f : equiv.perm \u03b1}, f \u2208 perms_of_list l \u2194 \u2200 {x : \u03b1}, \u21d1f x \u2260 x \u2192 x \u2208 l", "decl_nm": "mem_perms_of_list_iff"}
{"formal_statement": "theorem nhds_within_Ioc_eq_nhds_within_Iic {\u03b1 : Type u} [topological_space \u03b1]\n\t[linear_order \u03b1] [order_closed_topology \u03b1] {a b : \u03b1} (h : a < b) :\n\tnhds_within b (set.Ioc a b) = nhds_within b (set.Iic b)", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : topological_space \u03b1] [_inst_2 : linear_order \u03b1] [_inst_3 : order_closed_topology \u03b1] {a b : \u03b1}, a < b \u2192 nhds_within b (set.Ioc a b) = nhds_within b (set.Iic b)", "decl_nm": "nhds_within_Ioc_eq_nhds_within_Iic"}
{"formal_statement": "theorem snorm_le_snorm_of_exponent_le {\u03b1 E : Type*} {m0 : measurable_space \u03b1}\n\t{\u03bc : measure_theory.measure \u03b1} [measurable_space E] [normed_group E] [borel_space E]\n\t{p q : ennreal} (hpq : p \u2264 q) (hf : ae_measurable f \u03bc) :\n\t\u2200 [measure_theory.is_probability_measure \u03bc] {f : \u03b1 \u2192 E},  measure_theory.snorm f p \u03bc \u2264 measure_theory.snorm f q \u03bc", "decl_tp": "\u2200 {\u03b1 : Type u_1} {E : Type u_2} {m0 : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} [_inst_1 : measurable_space E] [_inst_2 : normed_group E] [_inst_5 : borel_space E] {p q : ennreal}, p \u2264 q \u2192 \u2200 [_inst_6 : measure_theory.is_probability_measure \u03bc] {f : \u03b1 \u2192 E}, ae_measurable f \u03bc \u2192 measure_theory.snorm f p \u03bc \u2264 measure_theory.snorm f q \u03bc", "decl_nm": "measure_theory.snorm_le_snorm_of_exponent_le"}
{"formal_statement": "theorem closed_embedding_id {\u03b1 : Type*} [topological_space \u03b1] :\n\tclosed_embedding id", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : topological_space \u03b1], closed_embedding id", "decl_nm": "closed_embedding_id"}
{"formal_statement": "theorem card_pos {\u03b1 : Type*} {s : multiset \u03b1} :\n\t0 < \u21d1multiset.card s \u2194 s \u2260 0", "decl_tp": "\u2200 {\u03b1 : Type u_1} {s : multiset \u03b1}, 0 < \u21d1multiset.card s \u2194 s \u2260 0", "decl_nm": "multiset.card_pos"}
{"formal_statement": "theorem filter_or {\u03b1 : Type*} (p q : \u03b1 \u2192 Prop) [decidable_pred p] [decidable_pred q]\n\t[decidable_eq \u03b1] [decidable_pred (\u03bb (a : \u03b1), p a \u2228 q a)] (s : finset \u03b1) :\n\tfinset.filter (\u03bb (a : \u03b1), p a \u2228 q a) s = finset.filter p s \u222a finset.filter q s", "decl_tp": "\u2200 {\u03b1 : Type u_1} (p q : \u03b1 \u2192 Prop) [_inst_1 : decidable_pred p] [_inst_2 : decidable_pred q] [_inst_3 : decidable_eq \u03b1] [_inst_4 : decidable_pred (\u03bb (a : \u03b1), p a \u2228 q a)] (s : finset \u03b1), finset.filter (\u03bb (a : \u03b1), p a \u2228 q a) s = finset.filter p s \u222a finset.filter q s", "decl_nm": "finset.filter_or"}
{"formal_statement": "theorem map_norm_noninc {V W : SemiNormedGroup} {f : V \u27f6 W} (hf : normed_group_hom.norm_noninc f) :\n\tnormed_group_hom.norm_noninc (SemiNormedGroup.Completion.map f)", "decl_tp": "\u2200 {V W : SemiNormedGroup} {f : V \u27f6 W}, normed_group_hom.norm_noninc f \u2192 normed_group_hom.norm_noninc (SemiNormedGroup.Completion.map f)", "decl_nm": "SemiNormedGroup.Completion.map_norm_noninc"}
{"formal_statement": "theorem midpoint_sub_right {R V : Type*} [ring R] [invertible 2] [add_comm_group V]\n\t[module R V] (v\u2081 v\u2082 : V) :\n\tmidpoint R v\u2081 v\u2082 - v\u2082 = \u215f 2 \u2022 (v\u2081 - v\u2082)", "decl_tp": "\u2200 {R : Type u_1} {V : Type u_2} [_inst_1 : ring R] [_inst_2 : invertible 2] [_inst_3 : add_comm_group V] [_inst_4 : module R V] (v\u2081 v\u2082 : V), midpoint R v\u2081 v\u2082 - v\u2082 = \u215f 2 \u2022 (v\u2081 - v\u2082)", "decl_nm": "midpoint_sub_right"}
{"formal_statement": "theorem mul_div_cancel' {a b : ennreal} (h0 : a \u2260 0) (hI : a \u2260 \u22a4) :\n\ta * (b / a) = b", "decl_tp": "\u2200 {a b : ennreal}, a \u2260 0 \u2192 a \u2260 \u22a4 \u2192 a * (b / a) = b", "decl_nm": "ennreal.mul_div_cancel'"}
{"formal_statement": "theorem continuous_on_exp {s : set \u2102} :\n\tcontinuous_on complex.exp s", "decl_tp": "\u2200 {s : set \u2102}, continuous_on complex.exp s", "decl_nm": "complex.continuous_on_exp"}
{"formal_statement": "theorem coe_dual_basis {R M \u03b9 : Type*} [comm_ring R] [add_comm_group M]\n\t[module R M] [decidable_eq \u03b9] (b : basis \u03b9 R M) [fintype \u03b9] :\n\t\u21d1(b.dual_basis) = b.coord", "decl_tp": "\u2200 {R : Type u_1} {M : Type u_2} {\u03b9 : Type u_5} [_inst_1 : comm_ring R] [_inst_2 : add_comm_group M] [_inst_3 : module R M] [_inst_4 : decidable_eq \u03b9] (b : basis \u03b9 R M) [_inst_5 : fintype \u03b9], \u21d1(b.dual_basis) = b.coord", "decl_nm": "basis.coe_dual_basis"}
{"formal_statement": "theorem ae_le_set_pi {\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} [fintype \u03b9] [\u03a0 (i : \u03b9), measurable_space (\u03b1 i)]\n\t{\u03bc : \u03a0 (i : \u03b9), measure_theory.measure (\u03b1 i)} [\u2200 (i : \u03b9), measure_theory.sigma_finite (\u03bc i)]\n\t{I : set \u03b9} {s t : \u03a0 (i : \u03b9), set (\u03b1 i)} :\n\t(\u2200 (i : \u03b9), i \u2208 I \u2192 s i \u2264\u1d50[\u03bc i] t i) \u2192 I.pi s \u2264\u1d50[measure_theory.measure.pi \u03bc] I.pi t", "decl_tp": "\u2200 {\u03b9 : Type u_1} {\u03b1 : \u03b9 \u2192 Type u_3} [_inst_1 : fintype \u03b9] [_inst_3 : \u03a0 (i : \u03b9), measurable_space (\u03b1 i)] {\u03bc : \u03a0 (i : \u03b9), measure_theory.measure (\u03b1 i)} [_inst_4 : \u2200 (i : \u03b9), measure_theory.sigma_finite (\u03bc i)] {I : set \u03b9} {s t : \u03a0 (i : \u03b9), set (\u03b1 i)}, (\u2200 (i : \u03b9), i \u2208 I \u2192 s i \u2264\u1d50[\u03bc i] t i) \u2192 I.pi s \u2264\u1d50[measure_theory.measure.pi \u03bc] I.pi t", "decl_nm": "measure_theory.measure.ae_le_set_pi"}
{"formal_statement": "theorem lift_eq_coe {\u03b1 \u03b2 : Type*} (f : \u03b1 \u2192 \u03b2) :\n\tpfun.lift f = \u2191f", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} (f : \u03b1 \u2192 \u03b2), pfun.lift f = \u2191f", "decl_nm": "pfun.lift_eq_coe"}
{"formal_statement": "theorem Ioo_subset_Ioo_right {\u03b1 : Type u} [preorder \u03b1] {a b\u2081 b\u2082 : \u03b1} (h : b\u2081 \u2264 b\u2082) :\n\tset.Ioo a b\u2081 \u2286 set.Ioo a b\u2082", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : preorder \u03b1] {a b\u2081 b\u2082 : \u03b1}, b\u2081 \u2264 b\u2082 \u2192 set.Ioo a b\u2081 \u2286 set.Ioo a b\u2082", "decl_nm": "set.Ioo_subset_Ioo_right"}
{"formal_statement": "theorem mul_indicator_of_not_mem {\u03b1 M : Type*} [has_one M] {s : set \u03b1}\n\t{a : \u03b1} (a : \u03b1) (h : a \u2209 s) :\n\t\u2200 (f :  M), s.mul_indicator f a = 1", "decl_tp": "\u2200 {\u03b1 : Type u_1} {M : Type u_4} [_inst_1 : has_one M] {s : set \u03b1} {a : \u03b1}, a \u2209 s \u2192 \u2200 (f : \u03b1 \u2192 M), s.mul_indicator f a = 1", "decl_nm": "set.mul_indicator_of_not_mem"}
{"formal_statement": "theorem add {\u03b1 \u03b2 : Type*} {m : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1}\n\t[normed_group \u03b2] [measurable_space \u03b2] [borel_space \u03b2] [topological_space.second_countable_topology \u03b2]\n\t{f g : \u03b1 \u2192\u2098[\u03bc] \u03b2} :\n\tf.integrable \u2192 g.integrable \u2192 (f + g).integrable", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {m : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} [_inst_1 : normed_group \u03b2] [_inst_3 : measurable_space \u03b2] [_inst_6 : borel_space \u03b2] [_inst_7 : topological_space.second_countable_topology \u03b2] {f g : \u03b1 \u2192\u2098[\u03bc] \u03b2}, f.integrable \u2192 g.integrable \u2192 (f + g).integrable", "decl_nm": "measure_theory.ae_eq_fun.integrable.add"}
{"formal_statement": "theorem relindex_self {G : Type*} [group G] (H : subgroup G) :\n\tH.relindex H = 1", "decl_tp": "\u2200 {G : Type u_1} [_inst_1 : group G] (H : subgroup G), H.relindex H = 1", "decl_nm": "subgroup.relindex_self"}
{"formal_statement": "theorem div_pos_of_pos_of_dvd {a b : \u2124} (H1 : 0 < a) (H2 : 0 \u2264 b) (H3 : b \u2223 a) :\n\t0 < a / b", "decl_tp": "\u2200 {a b : \u2124}, 0 < a \u2192 0 \u2264 b \u2192 b \u2223 a \u2192 0 < a / b", "decl_nm": "int.div_pos_of_pos_of_dvd"}
{"formal_statement": "theorem to_list_inv_as_string (l : list char) :\n\tl.as_string.to_list = l", "decl_tp": "\u2200 (l : list char), l.as_string.to_list = l", "decl_nm": "list.to_list_inv_as_string"}
{"formal_statement": "theorem is_spanning_iff {V : Type u} {G : simple_graph V} {G' : G.subgraph} :\n\tG'.is_spanning \u2194 G'.verts = set.univ", "decl_tp": "\u2200 {V : Type u} {G : simple_graph V} {G' : G.subgraph}, G'.is_spanning \u2194 G'.verts = set.univ", "decl_nm": "simple_graph.subgraph.is_spanning_iff"}
{"formal_statement": "theorem to_add_subgroup_injective {R : Type u} [ring R] :\n\tfunction.injective subring.to_add_subgroup", "decl_tp": "\u2200 {R : Type u} [_inst_1 : ring R], function.injective subring.to_add_subgroup", "decl_nm": "subring.to_add_subgroup_injective"}
{"formal_statement": "theorem coe_coe_ring_hom {\u03b1 : Type*} {l : filter \u03b1} {R : Type*} [semiring R] :\n\t\u21d1(filter.germ.coe_ring_hom l) = coe", "decl_tp": "\u2200 {\u03b1 : Type u_1} {l : filter \u03b1} {R : Type u_5} [_inst_1 : semiring R], \u21d1(filter.germ.coe_ring_hom l) = coe", "decl_nm": "filter.germ.coe_coe_ring_hom"}
{"formal_statement": "theorem symmetric_rel_inter {\u03b1 : Type*} {U V : set (\u03b1 \u00d7 \u03b1)} (hU : symmetric_rel U)\n\t(hV : symmetric_rel V) :\n\tsymmetric_rel (U \u2229 V)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {U V : set (\u03b1 \u00d7 \u03b1)}, symmetric_rel U \u2192 symmetric_rel V \u2192 symmetric_rel (U \u2229 V)", "decl_nm": "symmetric_rel_inter"}
{"formal_statement": "theorem indicator_apply_nonpos {\u03b1 M : Type*} [has_zero M] [preorder M]\n\t{s : set \u03b1} {f : \u03b1 \u2192 M} {a : \u03b1} :\n\t(a \u2208 s \u2192 f a \u2264 0) \u2192 s.indicator f a \u2264 0", "decl_tp": "\u2200 {\u03b1 : Type u_1} {M : Type u_4} [_inst_1 : has_zero M] [_inst_2 : preorder M] {s : set \u03b1} {f : \u03b1 \u2192 M} {a : \u03b1}, (a \u2208 s \u2192 f a \u2264 0) \u2192 s.indicator f a \u2264 0", "decl_nm": "set.indicator_apply_nonpos"}
{"formal_statement": "theorem ae_ae_of_ae_prod {\u03b1 \u03b2 : Type*} [measurable_space \u03b1] [measurable_space \u03b2]\n\t{\u03bc : measure_theory.measure \u03b1} {\u03bd : measure_theory.measure \u03b2} [measure_theory.sigma_finite \u03bd]\n\t{p : \u03b1 \u00d7 \u03b2 \u2192 Prop} :\n\t(\u2200\u1d50 (z : \u03b1 \u00d7 \u03b2) \u2202\u03bc.prod \u03bd, p z) \u2192 (\u2200\u1d50 (x : \u03b1) \u2202\u03bc, \u2200\u1d50 (y : \u03b2) \u2202\u03bd, p (x, y))", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_3} [_inst_1 : measurable_space \u03b1] [_inst_3 : measurable_space \u03b2] {\u03bc : measure_theory.measure \u03b1} {\u03bd : measure_theory.measure \u03b2} [_inst_8 : measure_theory.sigma_finite \u03bd] {p : \u03b1 \u00d7 \u03b2 \u2192 Prop}, (\u2200\u1d50 (z : \u03b1 \u00d7 \u03b2) \u2202\u03bc.prod \u03bd, p z) \u2192 (\u2200\u1d50 (x : \u03b1) \u2202\u03bc, \u2200\u1d50 (y : \u03b2) \u2202\u03bd, p (x, y))", "decl_nm": "measure_theory.measure.ae_ae_of_ae_prod"}
{"formal_statement": "theorem inv_bijective :\n\tfunction.bijective (\u03bb (a : ennreal), a\u207b\u00b9)", "decl_tp": "function.bijective (\u03bb (a : ennreal), a\u207b\u00b9)", "decl_nm": "ennreal.inv_bijective"}
{"formal_statement": "theorem one (p : \u2115) :\n\tpadic_norm p 1 = 1", "decl_tp": "\u2200 (p : \u2115), padic_norm p 1 = 1", "decl_nm": "padic_norm.one"}
{"formal_statement": "theorem inter {\u03b1 : Type u} {\u03b2 : Type v} [preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s : set \u03b1}\n\t{a : \u03b1} (hf : is_max_on f s a) :\n\t\u2200 (t : set \u03b1), is_max_on f (s \u2229 t) a", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s : set \u03b1} {a : \u03b1}, is_max_on f s a \u2192 \u2200 (t : set \u03b1), is_max_on f (s \u2229 t) a", "decl_nm": "is_max_on.inter"}
{"formal_statement": "theorem symm_apply_apply {R : Type u} {L : Type v} {M : Type w} {N : Type w\u2081}\n\t[comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [add_comm_group N]\n\t[module R M] [module R N] [lie_ring_module L M] [lie_ring_module L N]\n\t[lie_module R L M] [lie_module R L N] (e : M \u2243\u2097\u2045R,L\u2046 N) (x : M) :\n\t\u21d1(e.symm) (\u21d1e x) = x", "decl_tp": "\u2200 {R : Type u} {L : Type v} {M : Type w} {N : Type w\u2081} [_inst_1 : comm_ring R] [_inst_2 : lie_ring L] [_inst_3 : lie_algebra R L] [_inst_4 : add_comm_group M] [_inst_5 : add_comm_group N] [_inst_7 : module R M] [_inst_8 : module R N] [_inst_10 : lie_ring_module L M] [_inst_11 : lie_ring_module L N] [_inst_13 : lie_module R L M] [_inst_14 : lie_module R L N] (e : M \u2243\u2097\u2045R,L\u2046 N) (x : M), \u21d1(e.symm) (\u21d1e x) = x", "decl_nm": "lie_module_equiv.symm_apply_apply"}
{"formal_statement": "theorem prime_def_min_fac {p : \u2115} :\n\tnat.prime p \u2194 2 \u2264 p \u2227 p.min_fac = p", "decl_tp": "\u2200 {p : \u2115}, nat.prime p \u2194 2 \u2264 p \u2227 p.min_fac = p", "decl_nm": "nat.prime_def_min_fac"}
{"formal_statement": "theorem smul_ite {M \u03b1 : Type*} [has_scalar M \u03b1] (p : Prop) [decidable p]\n\t(a : M) (b\u2081 b\u2082 : \u03b1) :\n\ta \u2022 ite p b\u2081 b\u2082 = ite p (a \u2022 b\u2081) (a \u2022 b\u2082)", "decl_tp": "\u2200 {M : Type u_1} {\u03b1 : Type u_6} [_inst_1 : has_scalar M \u03b1] (p : Prop) [_inst_2 : decidable p] (a : M) (b\u2081 b\u2082 : \u03b1), a \u2022 ite p b\u2081 b\u2082 = ite p (a \u2022 b\u2081) (a \u2022 b\u2082)", "decl_nm": "smul_ite"}
{"formal_statement": "theorem exp_sum {\u03b1 : Type*} (s : finset \u03b1) (f : \u03b1 \u2192 \u2102) :\n\tcomplex.exp (s.sum (\u03bb (x : \u03b1), f x)) = s.prod (\u03bb (x : \u03b1), complex.exp (f x))", "decl_tp": "\u2200 {\u03b1 : Type u_1} (s : finset \u03b1) (f : \u03b1 \u2192 \u2102), complex.exp (s.sum (\u03bb (x : \u03b1), f x)) = s.prod (\u03bb (x : \u03b1), complex.exp (f x))", "decl_nm": "complex.exp_sum"}
{"formal_statement": "theorem le_generate_from_iff_subset_is_open {\u03b1 : Type u} {g : set (set \u03b1)}\n\t{t : topological_space \u03b1} :\n\tt \u2264 topological_space.generate_from g \u2194 g \u2286 {s : set \u03b1 | t.is_open s}", "decl_tp": "\u2200 {\u03b1 : Type u} {g : set (set \u03b1)} {t : topological_space \u03b1}, t \u2264 topological_space.generate_from g \u2194 g \u2286 {s : set \u03b1 | t.is_open s}", "decl_nm": "le_generate_from_iff_subset_is_open"}
{"formal_statement": "theorem mk' {\u03b1 \u03b2 : Type*} [topological_space \u03b1] [topological_space \u03b2] (f : \u03b1 \u2192 \u03b2)\n\t(inj : function.injective f) :\n\t(\u2200 (a : \u03b1), filter.comap f (nhds (f a)) = nhds a) \u2192 embedding f", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : topological_space \u03b1] [_inst_2 : topological_space \u03b2] (f : \u03b1 \u2192 \u03b2), function.injective f \u2192 (\u2200 (a : \u03b1), filter.comap f (nhds (f a)) = nhds a) \u2192 embedding f", "decl_nm": "embedding.mk'"}
{"formal_statement": "theorem adjoin_one {F : Type*} [field F] {E : Type*} [field E] [algebra F E] :\n\tF\u27ee1\u27ef = \u22a5", "decl_tp": "\u2200 {F : Type u_1} [_inst_1 : field F] {E : Type u_2} [_inst_2 : field E] [_inst_3 : algebra F E], F\u27ee1\u27ef = \u22a5", "decl_nm": "intermediate_field.adjoin_one"}
{"formal_statement": "theorem nth_zero {\u0393 : Type*} [inhabited \u0393] (l : turing.list_blank \u0393) :\n\tl.nth 0 = l.head", "decl_tp": "\u2200 {\u0393 : Type u_1} [_inst_1 : inhabited \u0393] (l : turing.list_blank \u0393), l.nth 0 = l.head", "decl_nm": "turing.list_blank.nth_zero"}
{"formal_statement": "theorem whisker_left_comp {C : Type u\u2081} [category_theory.category C] {D : Type u\u2082}\n\t[category_theory.category D] {E : Type u\u2083} [category_theory.category E]\n\t(F : C \u2964 D) {G H K : D \u2964 E} (\u03b1 : G \u27f6 H) (\u03b2 : H \u27f6 K) :\n\tcategory_theory.whisker_left F (\u03b1 \u226b \u03b2) = category_theory.whisker_left F \u03b1 \u226b category_theory.whisker_left F \u03b2", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {D : Type u\u2082} [_inst_2 : category_theory.category D] {E : Type u\u2083} [_inst_3 : category_theory.category E] (F : C \u2964 D) {G H K : D \u2964 E} (\u03b1 : G \u27f6 H) (\u03b2 : H \u27f6 K), category_theory.whisker_left F (\u03b1 \u226b \u03b2) = category_theory.whisker_left F \u03b1 \u226b category_theory.whisker_left F \u03b2", "decl_nm": "category_theory.whisker_left_comp"}
{"formal_statement": "theorem proj_apply {R\u2081 : Type*} [comm_ring R\u2081] {n : Type*} (i j : n) (x : n \u2192 R\u2081) :\n\t\u21d1(quadratic_form.proj i j) x = x i * x j", "decl_tp": "\u2200 {R\u2081 : Type u_4} [_inst_3 : comm_ring R\u2081] {n : Type u_5} (i j : n) (x : n \u2192 R\u2081), \u21d1(quadratic_form.proj i j) x = x i * x j", "decl_nm": "quadratic_form.proj_apply"}
{"formal_statement": "theorem nat_trans_app {C : Type u\u2082} [category_theory.category C] {I : Type u\u2081}\n\t{F G : category_theory.discrete I \u2964 C} (f : \u03a0 (i : category_theory.discrete I), F.obj i \u27f6 G.obj i)\n\t(i : category_theory.discrete I) :\n\t(category_theory.discrete.nat_trans f).app i = f i", "decl_tp": "\u2200 {C : Type u\u2082} [_inst_1 : category_theory.category C] {I : Type u\u2081} {F G : category_theory.discrete I \u2964 C} (f : \u03a0 (i : category_theory.discrete I), F.obj i \u27f6 G.obj i) (i : category_theory.discrete I), (category_theory.discrete.nat_trans f).app i = f i", "decl_nm": "category_theory.discrete.nat_trans_app"}
{"formal_statement": "theorem mul_seq {\u03b1 \u03b2 : Type u} {f g : free_magma (\u03b1 \u2192 \u03b2)} {x : free_magma \u03b1} :\n\tf * g <*> x = (f <*> x) * (g <*> x)", "decl_tp": "\u2200 {\u03b1 \u03b2 : Type u} {f g : free_magma (\u03b1 \u2192 \u03b2)} {x : free_magma \u03b1}, f * g <*> x = (f <*> x) * (g <*> x)", "decl_nm": "free_magma.mul_seq"}
{"formal_statement": "theorem range_val_subtype {\u03b1 : Type*} {p : \u03b1 \u2192 Prop} :\n\tset.range subtype.val = {x : \u03b1 | p x}", "decl_tp": "\u2200 {\u03b1 : Type u_1} {p : \u03b1 \u2192 Prop}, set.range subtype.val = {x : \u03b1 | p x}", "decl_nm": "subtype.range_val_subtype"}
{"formal_statement": "theorem op_ring_equiv_apply_to_finsupp_to_fun (R : Type u) [semiring R]\n\t(\u1fb0 : (polynomial R)\u1d50\u1d52\u1d56) (\u1fb0_1 : \u2115) :\n\t\u21d1((\u21d1(polynomial.op_ring_equiv R) \u1fb0).to_finsupp) \u1fb0_1 = mul_opposite.op (\u21d1((mul_opposite.unop \u1fb0).to_finsupp) \u1fb0_1)", "decl_tp": "\u2200 (R : Type u) [_inst_1 : semiring R] (\u1fb0 : (polynomial R)\u1d50\u1d52\u1d56) (\u1fb0_1 : \u2115), \u21d1((\u21d1(polynomial.op_ring_equiv R) \u1fb0).to_finsupp) \u1fb0_1 = mul_opposite.op (\u21d1((mul_opposite.unop \u1fb0).to_finsupp) \u1fb0_1)", "decl_nm": "polynomial.op_ring_equiv_apply_to_finsupp_to_fun"}
{"formal_statement": "theorem monotone_map {M N : Type*} [add_zero_class M] [add_zero_class N]\n\t{f : M \u2192+ N} :\n\tmonotone (add_submonoid.map f)", "decl_tp": "\u2200 {M : Type u_1} {N : Type u_2} [_inst_1 : add_zero_class M] [_inst_2 : add_zero_class N] {f : M \u2192+ N}, monotone (add_submonoid.map f)", "decl_nm": "add_submonoid.monotone_map"}
{"formal_statement": "theorem hall_hard_inductive_step {\u03b9 : Type u} {\u03b1 : Type v} [fintype \u03b9]\n\t{t : \u03b9 \u2192 finset \u03b1} [decidable_eq \u03b1] {n : \u2115} (hn : fintype.card \u03b9 = n + 1) :\n\t(\u2200 (s : finset \u03b9), s.card \u2264 (s.bUnion t).card) \u2192 (\u2200 {\u03b9' : Type u} [fintype \u03b9']\n\t(t' : \u03b9' \u2192 finset \u03b1), fintype.card \u03b9' \u2264 n \u2192 (\u2200 (s' : finset \u03b9'), s'.card \u2264 (s'.bUnion t').card) \u2192 (\u2203 (f : \u03b9' \u2192 \u03b1), function.injective f \u2227 \u2200 (x : \u03b9'), f x \u2208 t' x)) \u2192 (\u2203 (f : \u03b9 \u2192 \u03b1), function.injective f \u2227 \u2200 (x : \u03b9), f x \u2208 t x)", "decl_tp": "\u2200 {\u03b9 : Type u} {\u03b1 : Type v} [_inst_1 : fintype \u03b9] {t : \u03b9 \u2192 finset \u03b1} [_inst_2 : decidable_eq \u03b1] {n : \u2115}, fintype.card \u03b9 = n + 1 \u2192 (\u2200 (s : finset \u03b9), s.card \u2264 (s.bUnion t).card) \u2192 (\u2200 {\u03b9' : Type u} [_inst_3 : fintype \u03b9'] (t' : \u03b9' \u2192 finset \u03b1), fintype.card \u03b9' \u2264 n \u2192 (\u2200 (s' : finset \u03b9'), s'.card \u2264 (s'.bUnion t').card) \u2192 (\u2203 (f : \u03b9' \u2192 \u03b1), function.injective f \u2227 \u2200 (x : \u03b9'), f x \u2208 t' x)) \u2192 (\u2203 (f : \u03b9 \u2192 \u03b1), function.injective f \u2227 \u2200 (x : \u03b9), f x \u2208 t x)", "decl_nm": "hall_marriage_theorem.hall_hard_inductive_step"}
{"formal_statement": "theorem count_strict_mono {p : \u2115 \u2192 Prop} [decidable_pred p] {m n : \u2115} (hm : p m)\n\t(hmn : m < n) :\n\tnat.count p m < nat.count p n", "decl_tp": "\u2200 {p : \u2115 \u2192 Prop} [_inst_1 : decidable_pred p] {m n : \u2115}, p m \u2192 m < n \u2192 nat.count p m < nat.count p n", "decl_nm": "nat.count_strict_mono"}
{"formal_statement": "theorem powerset_zero {\u03b1 : Type*} :\n\t0.powerset = {0}", "decl_tp": "\u2200 {\u03b1 : Type u_1}, 0.powerset = {0}", "decl_nm": "multiset.powerset_zero"}
{"formal_statement": "theorem map_sup_comap_of_surjective {L : first_order.language} {M N : Type*}\n\t[L.Structure M] [L.Structure N] {f : L.hom M N} (hf : function.surjective \u21d1f) :\n\t\u2200 (S T : L.substructure N), first_order.language.substructure.map f (first_order.language.substructure.comap f S \u2294 first_order.language.substructure.comap f T) = S \u2294 T", "decl_tp": "\u2200 {L : first_order.language} {M : Type u_3} {N : Type u_4} [_inst_1 : L.Structure M] [_inst_2 : L.Structure N] {f : L.hom M N}, function.surjective \u21d1f \u2192 \u2200 (S T : L.substructure N), first_order.language.substructure.map f (first_order.language.substructure.comap f S \u2294 first_order.language.substructure.comap f T) = S \u2294 T", "decl_nm": "first_order.language.substructure.map_sup_comap_of_surjective"}
{"formal_statement": "theorem lift_rel_nil {\u03b1 : Type u} {\u03b2 : Type v} (R : \u03b1 \u2192 \u03b2 \u2192 Prop) :\n\twseq.lift_rel R wseq.nil wseq.nil", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} (R : \u03b1 \u2192 \u03b2 \u2192 Prop), wseq.lift_rel R wseq.nil wseq.nil", "decl_nm": "wseq.lift_rel_nil"}
{"formal_statement": "theorem succ_pnat_coe (n : \u2115) :\n\t\u2191(n.succ_pnat) = n.succ", "decl_tp": "\u2200 (n : \u2115), \u2191(n.succ_pnat) = n.succ", "decl_nm": "nat.succ_pnat_coe"}
{"formal_statement": "theorem nil_union {\u03b1 : Type*} [decidable_eq \u03b1] (l : list \u03b1) :\n\tlist.nil \u222a l = l", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : decidable_eq \u03b1] (l : list \u03b1), list.nil \u222a l = l", "decl_nm": "list.nil_union"}
{"formal_statement": "theorem support_cycle_of_le {\u03b1 : Type*} [decidable_eq \u03b1] [fintype \u03b1] (f : equiv.perm \u03b1)\n\t(x : \u03b1) :\n\t(f.cycle_of x).support \u2264 f.support", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : decidable_eq \u03b1] [_inst_2 : fintype \u03b1] (f : equiv.perm \u03b1) (x : \u03b1), (f.cycle_of x).support \u2264 f.support", "decl_nm": "equiv.perm.support_cycle_of_le"}
{"formal_statement": "theorem not_or_eq (p q : Prop) :\n\t(\u00ac(p \u2228 q)) = (\u00acp \u2227 \u00acq)", "decl_tp": "\u2200 (p q : Prop), (\u00ac(p \u2228 q)) = (\u00acp \u2227 \u00acq)", "decl_nm": "push_neg.not_or_eq"}
{"formal_statement": "theorem fst_one {M N : Type*} [has_one M] [has_one N] :\n\t1.fst = 1", "decl_tp": "\u2200 {M : Type u_5} {N : Type u_6} [_inst_1 : has_one M] [_inst_2 : has_one N], 1.fst = 1", "decl_nm": "prod.fst_one"}
{"formal_statement": "theorem eq_get_iff_mem {\u03b1 : Type*} {o : part \u03b1} {a : \u03b1} (h : o.dom) :\n\ta = o.get h \u2194 a \u2208 o", "decl_tp": "\u2200 {\u03b1 : Type u_1} {o : part \u03b1} {a : \u03b1} (h : o.dom), a = o.get h \u2194 a \u2208 o", "decl_nm": "part.eq_get_iff_mem"}
{"formal_statement": "theorem smooth_at_one {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c] {E : Type*}\n\t[normed_group E] [normed_space \ud835\udd5c E] {H : Type*} [topological_space H]\n\t{I : model_with_corners \ud835\udd5c E H} {M : Type*} [topological_space M] [charted_space H M]\n\t{E' : Type*} [normed_group E'] [normed_space \ud835\udd5c E'] {H' : Type*} [topological_space H']\n\t{I' : model_with_corners \ud835\udd5c E' H'} {M' : Type*} [topological_space M']\n\t[charted_space H' M'] {x : M} [has_one M'] :\n\tsmooth_at I I' 1 x", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {H : Type u_3} [_inst_4 : topological_space H] {I : model_with_corners \ud835\udd5c E H} {M : Type u_4} [_inst_5 : topological_space M] [_inst_6 : charted_space H M] {E' : Type u_5} [_inst_7 : normed_group E'] [_inst_8 : normed_space \ud835\udd5c E'] {H' : Type u_6} [_inst_9 : topological_space H'] {I' : model_with_corners \ud835\udd5c E' H'} {M' : Type u_7} [_inst_10 : topological_space M'] [_inst_11 : charted_space H' M'] {x : M} [_inst_22 : has_one M'], smooth_at I I' 1 x", "decl_nm": "smooth_at_one"}
{"formal_statement": "theorem tensor_iso_inv {C : Type u} {X Y X' Y' : C} [category_theory.category C]\n\t[category_theory.monoidal_category C] (f : X \u2245 Y) (g : X' \u2245 Y') :\n\t(f \u2297 g).inv = f.inv \u2297 g.inv", "decl_tp": "\u2200 {C : Type u} {X Y X' Y' : C} [_inst_1 : category_theory.category C] [_inst_2 : category_theory.monoidal_category C] (f : X \u2245 Y) (g : X' \u2245 Y'), (f \u2297 g).inv = f.inv \u2297 g.inv", "decl_nm": "category_theory.tensor_iso_inv"}
{"formal_statement": "theorem Ici_eq_Icc {\u03b1 : Type*} [preorder \u03b1] [order_top \u03b1] [locally_finite_order \u03b1]\n\t(a : \u03b1) :\n\tfinset.Ici a = finset.Icc a \u22a4", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : preorder \u03b1] [_inst_2 : order_top \u03b1] [_inst_3 : locally_finite_order \u03b1] (a : \u03b1), finset.Ici a = finset.Icc a \u22a4", "decl_nm": "finset.Ici_eq_Icc"}
{"formal_statement": "theorem nndist_eq_nnnorm {E : Type*} [semi_normed_group E] (a b : E) :\n\thas_nndist.nndist a b = \u2225a - b\u2225\u208a", "decl_tp": "\u2200 {E : Type u_3} [_inst_1 : semi_normed_group E] (a b : E), has_nndist.nndist a b = \u2225a - b\u2225\u208a", "decl_nm": "nndist_eq_nnnorm"}
{"formal_statement": "theorem direction_top (k V P : Type*) [ring k] [add_comm_group V] [module k V]\n\t[S : add_torsor V P] :\n\t\u22a4.direction = \u22a4", "decl_tp": "\u2200 (k : Type u_1) (V : Type u_2) (P : Type u_3) [_inst_1 : ring k] [_inst_2 : add_comm_group V] [_inst_3 : module k V] [S : add_torsor V P], \u22a4.direction = \u22a4", "decl_nm": "affine_subspace.direction_top"}
{"formal_statement": "theorem condition_assoc {C : Type u} [category_theory.category C] {X Y : C}\n\t{f g : X \u27f6 Y} {Z : C} {\u03c0 : Y \u27f6 Z} (self : category_theory.is_split_coequalizer f g \u03c0) :\n\t\u2200 {X' : C} (f' : Z \u27f6 X'), f \u226b \u03c0 \u226b f' = g \u226b \u03c0 \u226b f'", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] {X Y : C} {f g : X \u27f6 Y} {Z : C} {\u03c0 : Y \u27f6 Z}, category_theory.is_split_coequalizer f g \u03c0 \u2192 \u2200 {X' : C} (f' : Z \u27f6 X'), f \u226b \u03c0 \u226b f' = g \u226b \u03c0 \u226b f'", "decl_nm": "category_theory.is_split_coequalizer.condition_assoc"}
{"formal_statement": "theorem sublists_perm_sublists' {\u03b1 : Type uu} (l : list \u03b1) :\n\tl.sublists ~ l.sublists'", "decl_tp": "\u2200 {\u03b1 : Type uu} (l : list \u03b1), l.sublists ~ l.sublists'", "decl_nm": "list.sublists_perm_sublists'"}
{"formal_statement": "theorem times_cont_diff_sin {n : with_top \u2115} :\n\ttimes_cont_diff \u211d n real.sin", "decl_tp": "\u2200 {n : with_top \u2115}, times_cont_diff \u211d n real.sin", "decl_nm": "real.times_cont_diff_sin"}
{"formal_statement": "theorem eq_of_associated_left {\u03b1 : Type*} [comm_monoid \u03b1] [decidable_rel has_dvd.dvd]\n\t{a b c : \u03b1} (h : associated a b) :\n\tmultiplicity b c = multiplicity a c", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : comm_monoid \u03b1] [_inst_2 : decidable_rel has_dvd.dvd] {a b c : \u03b1}, associated a b \u2192 multiplicity b c = multiplicity a c", "decl_nm": "multiplicity.eq_of_associated_left"}
{"formal_statement": "theorem fin_succ_equiv_zero {n : \u2115} :\n\t\u21d1(fin_succ_equiv n) 0 = option.none", "decl_tp": "\u2200 {n : \u2115}, \u21d1(fin_succ_equiv n) 0 = option.none", "decl_nm": "fin_succ_equiv_zero"}
{"formal_statement": "theorem minor_mul {l m n o : Type*} {\u03b1 : Type v} [fintype n] [fintype o]\n\t[semiring \u03b1] {p q : Type*} (M : matrix m n \u03b1) (N : matrix n p \u03b1) (e\u2081 : l \u2192 m)\n\t(e\u2082 : o \u2192 n) (e\u2083 : q \u2192 p) (he\u2082 : function.bijective e\u2082) :\n\t(M.mul N).minor e\u2081 e\u2083 = (M.minor e\u2081 e\u2082).mul (N.minor e\u2082 e\u2083)", "decl_tp": "\u2200 {l : Type u_1} {m : Type u_2} {n : Type u_3} {o : Type u_4} {\u03b1 : Type v} [_inst_1 : fintype n] [_inst_2 : fintype o] [_inst_3 : semiring \u03b1] {p : Type u_5} {q : Type u_6} (M : matrix m n \u03b1) (N : matrix n p \u03b1) (e\u2081 : l \u2192 m) (e\u2082 : o \u2192 n) (e\u2083 : q \u2192 p), function.bijective e\u2082 \u2192 (M.mul N).minor e\u2081 e\u2083 = (M.minor e\u2081 e\u2082).mul (N.minor e\u2082 e\u2083)", "decl_nm": "matrix.minor_mul"}
{"formal_statement": "theorem of_comp_finite {A B C : Type*} [comm_ring A] [comm_ring B] [comm_ring C]\n\t{f : A \u2192+* B} {g : B \u2192+* C} (h : (g.comp f).finite) :\n\tg.finite", "decl_tp": "\u2200 {A : Type u_1} {B : Type u_2} {C : Type u_3} [_inst_1 : comm_ring A] [_inst_2 : comm_ring B] [_inst_3 : comm_ring C] {f : A \u2192+* B} {g : B \u2192+* C}, (g.comp f).finite \u2192 g.finite", "decl_nm": "ring_hom.finite.of_comp_finite"}
{"formal_statement": "theorem mul_eq_mul_right {a b c : ennreal} :\n\tc \u2260 0 \u2192 c \u2260 \u22a4 \u2192 (a * c = b * c \u2194 a = b)", "decl_tp": "\u2200 {a b c : ennreal}, c \u2260 0 \u2192 c \u2260 \u22a4 \u2192 (a * c = b * c \u2194 a = b)", "decl_nm": "ennreal.mul_eq_mul_right"}
{"formal_statement": "theorem to_local_equiv {\u03b1 \u03b2 : Type*} [topological_space \u03b1] [topological_space \u03b2]\n\t{e : local_homeomorph \u03b1 \u03b2} {s : set \u03b1} {t : set \u03b2} (h : e.is_image s t) :\n\te.to_local_equiv.is_image s t", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : topological_space \u03b1] [_inst_2 : topological_space \u03b2] {e : local_homeomorph \u03b1 \u03b2} {s : set \u03b1} {t : set \u03b2}, e.is_image s t \u2192 e.to_local_equiv.is_image s t", "decl_nm": "local_homeomorph.is_image.to_local_equiv"}
{"formal_statement": "theorem dist_smul_pair {\u03b1 \u03b2 : Type*} [pseudo_metric_space \u03b1] [pseudo_metric_space \u03b2]\n\t[has_zero \u03b1] [has_zero \u03b2] [has_scalar \u03b1 \u03b2] [has_bounded_smul \u03b1 \u03b2] (x : \u03b1)\n\t(y\u2081 y\u2082 : \u03b2) :\n\thas_dist.dist (x \u2022 y\u2081) (x \u2022 y\u2082) \u2264 has_dist.dist x 0 * has_dist.dist y\u2081 y\u2082", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : pseudo_metric_space \u03b1] [_inst_2 : pseudo_metric_space \u03b2] [_inst_3 : has_zero \u03b1] [_inst_4 : has_zero \u03b2] [_inst_5 : has_scalar \u03b1 \u03b2] [_inst_6 : has_bounded_smul \u03b1 \u03b2] (x : \u03b1) (y\u2081 y\u2082 : \u03b2), has_dist.dist (x \u2022 y\u2081) (x \u2022 y\u2082) \u2264 has_dist.dist x 0 * has_dist.dist y\u2081 y\u2082", "decl_nm": "dist_smul_pair"}
{"formal_statement": "theorem of_fn_const {\u03b1 : Type u} (n : \u2115) (c : \u03b1) :\n\tlist.of_fn (\u03bb (i : fin n), c) = list.repeat c n", "decl_tp": "\u2200 {\u03b1 : Type u} (n : \u2115) (c : \u03b1), list.of_fn (\u03bb (i : fin n), c) = list.repeat c n", "decl_nm": "list.of_fn_const"}
{"formal_statement": "theorem card_map {\u03b1 \u03b2 : Type*} {s : finset \u03b1} (f : \u03b1 \u21aa \u03b2) :\n\t(finset.map f s).card = s.card", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {s : finset \u03b1} (f : \u03b1 \u21aa \u03b2), (finset.map f s).card = s.card", "decl_nm": "finset.card_map"}
{"formal_statement": "theorem measurable_embedding_mul_right\u2080 {G\u2080 : Type*} [measurable_space G\u2080]\n\t[group_with_zero G\u2080] [has_measurable_mul G\u2080] {g : G\u2080} (hg : g \u2260 0) :\n\tmeasurable_embedding (\u03bb (x : G\u2080), x * g)", "decl_tp": "\u2200 {G\u2080 : Type u_2} [_inst_2 : measurable_space G\u2080] [_inst_5 : group_with_zero G\u2080] [_inst_11 : has_measurable_mul G\u2080] {g : G\u2080}, g \u2260 0 \u2192 measurable_embedding (\u03bb (x : G\u2080), x * g)", "decl_nm": "measurable_embedding_mul_right\u2080"}
{"formal_statement": "theorem preimage_interior {\u03b1 \u03b2 : Type*} [topological_space \u03b1] [topological_space \u03b2]\n\t(e : local_homeomorph \u03b1 \u03b2) (s : set \u03b2) :\n\te.to_local_equiv.source \u2229 \u21d1e \u207b\u00b9' interior s = e.to_local_equiv.source \u2229 interior (\u21d1e \u207b\u00b9' s)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : topological_space \u03b1] [_inst_2 : topological_space \u03b2] (e : local_homeomorph \u03b1 \u03b2) (s : set \u03b2), e.to_local_equiv.source \u2229 \u21d1e \u207b\u00b9' interior s = e.to_local_equiv.source \u2229 interior (\u21d1e \u207b\u00b9' s)", "decl_nm": "local_homeomorph.preimage_interior"}
{"formal_statement": "theorem mem_inf {P : Type*} [semilattice_sup P] [order.ideal.ideal_inter_nonempty P]\n\t{x : P} {I J : order.ideal P} :\n\tx \u2208 I \u2293 J \u2194 x \u2208 I \u2227 x \u2208 J", "decl_tp": "\u2200 {P : Type u_1} [_inst_1 : semilattice_sup P] [_inst_2 : order.ideal.ideal_inter_nonempty P] {x : P} {I J : order.ideal P}, x \u2208 I \u2293 J \u2194 x \u2208 I \u2227 x \u2208 J", "decl_nm": "order.ideal.mem_inf"}
{"formal_statement": "theorem is_separated_def {\u03b1 : Type u} [uniform_space \u03b1] (s : set \u03b1) :\n\tis_separated s \u2194 \u2200 (x y : \u03b1), x \u2208 s \u2192 y \u2208 s \u2192 (x, y) \u2208 separation_rel \u03b1 \u2192 x = y", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : uniform_space \u03b1] (s : set \u03b1), is_separated s \u2194 \u2200 (x y : \u03b1), x \u2208 s \u2192 y \u2208 s \u2192 (x, y) \u2208 separation_rel \u03b1 \u2192 x = y", "decl_nm": "is_separated_def"}
{"formal_statement": "theorem is_O_id {\ud835\udd5c \ud835\udd5c\u2082 E F : Type*} [semi_normed_group E] [semi_normed_group F]\n\t[nondiscrete_normed_field \ud835\udd5c] [nondiscrete_normed_field \ud835\udd5c\u2082] [semi_normed_space \ud835\udd5c E]\n\t[semi_normed_space \ud835\udd5c\u2082 F] {\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082} [ring_hom_isometric \u03c3\u2081\u2082] (f : E \u2192SL[\u03c3\u2081\u2082] F)\n\t(l : filter E) :\n\tasymptotics.is_O \u21d1f (\u03bb (x : E), x) l", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} {\ud835\udd5c\u2082 : Type u_2} {E : Type u_4} {F : Type u_5} [_inst_1 : semi_normed_group E] [_inst_2 : semi_normed_group F] [_inst_6 : nondiscrete_normed_field \ud835\udd5c] [_inst_7 : nondiscrete_normed_field \ud835\udd5c\u2082] [_inst_9 : semi_normed_space \ud835\udd5c E] [_inst_10 : semi_normed_space \ud835\udd5c\u2082 F] {\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082} [_inst_15 : ring_hom_isometric \u03c3\u2081\u2082] (f : E \u2192SL[\u03c3\u2081\u2082] F) (l : filter E), asymptotics.is_O \u21d1f (\u03bb (x : E), x) l", "decl_nm": "continuous_linear_map.is_O_id"}
{"formal_statement": "theorem proj_map {C : Type u\u2081} [category_theory.category C] {D : Type u\u2082}\n\t[category_theory.category D] (S : D) (T : C \u2964 D) (_x _x_1 : category_theory.comma (category_theory.functor.from_punit S) T)\n\t(f : _x \u27f6 _x_1) :\n\t(category_theory.structured_arrow.proj S T).map f = f.right", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {D : Type u\u2082} [_inst_2 : category_theory.category D] (S : D) (T : C \u2964 D) (_x _x_1 : category_theory.comma (category_theory.functor.from_punit S) T) (f : _x \u27f6 _x_1), (category_theory.structured_arrow.proj S T).map f = f.right", "decl_nm": "category_theory.structured_arrow.proj_map"}
{"formal_statement": "theorem intermediate_value_interval {\u03b1 : Type u} [conditionally_complete_linear_order \u03b1]\n\t[topological_space \u03b1] [order_topology \u03b1] [densely_ordered \u03b1] {\u03b4 : Type*}\n\t[linear_order \u03b4] [topological_space \u03b4] [order_closed_topology \u03b4] {a b : \u03b1}\n\t{f : \u03b1 \u2192 \u03b4} (hf : continuous_on f (set.interval a b)) :\n\tset.interval (f a) (f b) \u2286 f '' set.interval a b", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : conditionally_complete_linear_order \u03b1] [_inst_2 : topological_space \u03b1] [_inst_3 : order_topology \u03b1] [_inst_8 : densely_ordered \u03b1] {\u03b4 : Type u_1} [_inst_9 : linear_order \u03b4] [_inst_10 : topological_space \u03b4] [_inst_11 : order_closed_topology \u03b4] {a b : \u03b1} {f : \u03b1 \u2192 \u03b4}, continuous_on f (set.interval a b) \u2192 set.interval (f a) (f b) \u2286 f '' set.interval a b", "decl_nm": "intermediate_value_interval"}
{"formal_statement": "theorem nat_abs_sign_of_nonzero {z : \u2124} (hz : z \u2260 0) :\n\tz.sign.nat_abs = 1", "decl_tp": "\u2200 {z : \u2124}, z \u2260 0 \u2192 z.sign.nat_abs = 1", "decl_nm": "int.nat_abs_sign_of_nonzero"}
{"formal_statement": "theorem unique_diff_on_Ico (a b : \u211d) :\n\tunique_diff_on \u211d (set.Ico a b)", "decl_tp": "\u2200 (a b : \u211d), unique_diff_on \u211d (set.Ico a b)", "decl_nm": "unique_diff_on_Ico"}
{"formal_statement": "theorem ord_le_ord {c\u2081 c\u2082 : cardinal} :\n\tc\u2081.ord \u2264 c\u2082.ord \u2194 c\u2081 \u2264 c\u2082", "decl_tp": "\u2200 {c\u2081 c\u2082 : cardinal}, c\u2081.ord \u2264 c\u2082.ord \u2194 c\u2081 \u2264 c\u2082", "decl_nm": "cardinal.ord_le_ord"}
{"formal_statement": "theorem mul_right_bijective_of_fintype\u2080 {M : Type*} [cancel_monoid_with_zero M]\n\t[fintype M] {a : M} (ha : a \u2260 0) :\n\tfunction.bijective (\u03bb (b : M), a * b)", "decl_tp": "\u2200 {M : Type u_1} [_inst_1 : cancel_monoid_with_zero M] [_inst_2 : fintype M] {a : M}, a \u2260 0 \u2192 function.bijective (\u03bb (b : M), a * b)", "decl_nm": "mul_right_bijective_of_fintype\u2080"}
{"formal_statement": "theorem equiv_fn_of_discrete_apply (\u03b1 \u03b2 : Type*) [topological_space \u03b1]\n\t[topological_space \u03b2] [discrete_topology \u03b1] (f : C(\u03b1, \u03b2)) (\u1fb0 : \u03b1) :\n\t\u21d1(continuous_map.equiv_fn_of_discrete \u03b1 \u03b2) f \u1fb0 = \u21d1f \u1fb0", "decl_tp": "\u2200 (\u03b1 : Type u_1) (\u03b2 : Type u_2) [_inst_1 : topological_space \u03b1] [_inst_2 : topological_space \u03b2] [_inst_4 : discrete_topology \u03b1] (f : C(\u03b1, \u03b2)) (\u1fb0 : \u03b1), \u21d1(continuous_map.equiv_fn_of_discrete \u03b1 \u03b2) f \u1fb0 = \u21d1f \u1fb0", "decl_nm": "continuous_map.equiv_fn_of_discrete_apply"}
{"formal_statement": "theorem comap_ker {G : Type*} [group G] {N P : Type*} [group N] [group P]\n\t(g : N \u2192* P) (f : G \u2192* N) :\n\tsubgroup.comap f g.ker = (g.comp f).ker", "decl_tp": "\u2200 {G : Type u_1} [_inst_1 : group G] {N : Type u_3} {P : Type u_4} [_inst_3 : group N] [_inst_4 : group P] (g : N \u2192* P) (f : G \u2192* N), subgroup.comap f g.ker = (g.comp f).ker", "decl_nm": "monoid_hom.comap_ker"}
{"formal_statement": "theorem image_prod {\u03b1 \u03b2 \u03b3 : Type*} {s : set \u03b1} {t : set \u03b2} (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) :\n\t(\u03bb (x : \u03b1 \u00d7 \u03b2), f x.fst x.snd) '' s.prod t = set.image2 f s t", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {\u03b3 : Type u_3} {s : set \u03b1} {t : set \u03b2} (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3), (\u03bb (x : \u03b1 \u00d7 \u03b2), f x.fst x.snd) '' s.prod t = set.image2 f s t", "decl_nm": "set.image_prod"}
{"formal_statement": "theorem choose_spec {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [decidable_pred p] (l : multiset \u03b1)\n\t(hp : \u2203! (a : \u03b1), a \u2208 l \u2227 p a) :\n\tmultiset.choose p l hp \u2208 l \u2227 p (multiset.choose p l hp)", "decl_tp": "\u2200 {\u03b1 : Type u_1} (p : \u03b1 \u2192 Prop) [_inst_1 : decidable_pred p] (l : multiset \u03b1) (hp : \u2203! (a : \u03b1), a \u2208 l \u2227 p a), multiset.choose p l hp \u2208 l \u2227 p (multiset.choose p l hp)", "decl_nm": "multiset.choose_spec"}
{"formal_statement": "theorem t1_space_antimono {\u03b1 : Type*} :\n\tantitone (t1_space \u03b1)", "decl_tp": "\u2200 {\u03b1 : Type u_1}, antitone (t1_space \u03b1)", "decl_nm": "t1_space_antimono"}
{"formal_statement": "theorem coe_ssubset_coe {A B : Type*} [i : set_like A B] {S T : A} :\n\t\u2191S \u2282 \u2191T \u2194 S < T", "decl_tp": "\u2200 {A : Type u_1} {B : Type u_2} [i : set_like A B] {S T : A}, \u2191S \u2282 \u2191T \u2194 S < T", "decl_nm": "set_like.coe_ssubset_coe"}
{"formal_statement": "theorem inter_distrib_right {\u03b1 : Type u} (s t u : set \u03b1) :\n\t(s \u222a t) \u2229 u = s \u2229 u \u222a t \u2229 u", "decl_tp": "\u2200 {\u03b1 : Type u} (s t u : set \u03b1), (s \u222a t) \u2229 u = s \u2229 u \u222a t \u2229 u", "decl_nm": "set.inter_distrib_right"}
{"formal_statement": "theorem map_nhds_within_preimage_eq {\u03b1 \u03b2 : Type*} [topological_space \u03b1]\n\t[topological_space \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : open_embedding f) :\n\t\u2200 (s : set \u03b2) (x : \u03b1), filter.map f (nhds_within x (f \u207b\u00b9' s)) = nhds_within (f x) s", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : topological_space \u03b1] [_inst_2 : topological_space \u03b2] {f : \u03b1 \u2192 \u03b2}, open_embedding f \u2192 \u2200 (s : set \u03b2) (x : \u03b1), filter.map f (nhds_within x (f \u207b\u00b9' s)) = nhds_within (f x) s", "decl_nm": "open_embedding.map_nhds_within_preimage_eq"}
{"formal_statement": "theorem symm_functor {C : Type u\u2081} [category_theory.category C] {D : Type u\u2082}\n\t[category_theory.category D] (e : C \u224c D) :\n\te.symm.functor = e.inverse", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {D : Type u\u2082} [_inst_2 : category_theory.category D] (e : C \u224c D), e.symm.functor = e.inverse", "decl_nm": "category_theory.equivalence.symm_functor"}
{"formal_statement": "theorem has_add_add_re {R : Type*} [comm_ring R] {c\u2081 c\u2082 : R} (a b : quaternion_algebra R c\u2081 c\u2082) :\n\t(a + b).re = a.re + b.re", "decl_tp": "\u2200 {R : Type u_1} [_inst_1 : comm_ring R] {c\u2081 c\u2082 : R} (a b : quaternion_algebra R c\u2081 c\u2082), (a + b).re = a.re + b.re", "decl_nm": "quaternion_algebra.has_add_add_re"}
{"formal_statement": "theorem augment_right {C : Type u} [category_theory.category C] (X : category_theory.simplicial_object C)\n\t(X\u2080 : C) (f : X.obj (opposite.op (simplex_category.mk 0)) \u27f6 X\u2080) (w : \u2200 (i : simplex_category)\n\t(g\u2081 g\u2082 : simplex_category.mk 0 \u27f6 i), X.map g\u2081.op \u226b f = X.map g\u2082.op \u226b f) :\n\t(X.augment X\u2080 f w).right = X\u2080", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] (X : category_theory.simplicial_object C) (X\u2080 : C) (f : X.obj (opposite.op (simplex_category.mk 0)) \u27f6 X\u2080) (w : \u2200 (i : simplex_category) (g\u2081 g\u2082 : simplex_category.mk 0 \u27f6 i), X.map g\u2081.op \u226b f = X.map g\u2082.op \u226b f), (X.augment X\u2080 f w).right = X\u2080", "decl_nm": "category_theory.simplicial_object.augment_right"}
{"formal_statement": "theorem extreme_points_subset {\ud835\udd5c E : Type*} [ordered_semiring \ud835\udd5c] [add_comm_monoid E]\n\t[has_scalar \ud835\udd5c E] {A : set E} :\n\tset.extreme_points \ud835\udd5c A \u2286 A", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} {E : Type u_2} [_inst_1 : ordered_semiring \ud835\udd5c] [_inst_2 : add_comm_monoid E] [_inst_3 : has_scalar \ud835\udd5c E] {A : set E}, set.extreme_points \ud835\udd5c A \u2286 A", "decl_nm": "extreme_points_subset"}
{"formal_statement": "theorem coinduced_le {\u03b1 \u03b2 : Type*} {t : topological_space \u03b1} {t' : topological_space \u03b2}\n\t{f : \u03b1 \u2192 \u03b2} (h : continuous f) :\n\ttopological_space.coinduced f t \u2264 t'", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {t : topological_space \u03b1} {t' : topological_space \u03b2} {f : \u03b1 \u2192 \u03b2}, continuous f \u2192 topological_space.coinduced f t \u2264 t'", "decl_nm": "continuous.coinduced_le"}
{"formal_statement": "theorem measurable_set_bUnion {\u03b1 \u03b2 : Type*} [measurable_space \u03b1] {f : \u03b2 \u2192 set \u03b1}\n\t{s : set \u03b2} (hs : s.finite) :\n\t(\u2200 (b : \u03b2), b \u2208 s \u2192 measurable_set (f b)) \u2192 measurable_set (\u22c3 (b : \u03b2)\n\t(H : b \u2208 s), f b)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : measurable_space \u03b1] {f : \u03b2 \u2192 set \u03b1} {s : set \u03b2}, s.finite \u2192 (\u2200 (b : \u03b2), b \u2208 s \u2192 measurable_set (f b)) \u2192 measurable_set (\u22c3 (b : \u03b2) (H : b \u2208 s), f b)", "decl_nm": "set.finite.measurable_set_bUnion"}
{"formal_statement": "theorem coe_center (M : Type*) [monoid M] :\n\t\u2191(submonoid.center M) = set.center M", "decl_tp": "\u2200 (M : Type u_1) [_inst_1 : monoid M], \u2191(submonoid.center M) = set.center M", "decl_nm": "submonoid.coe_center"}
{"formal_statement": "theorem noncomm_foldr_empty {\u03b1 \u03b2 : Type*} (f : \u03b1 \u2192 \u03b2 \u2192 \u03b2) (h : \u2200 (x : \u03b1), x \u2208 0 \u2192 \u2200 (y : \u03b1), y \u2208 0 \u2192 \u2200 (b : \u03b2), f x (f y b) = f y (f x b))\n\t(b : \u03b2) :\n\tmultiset.noncomm_foldr f 0 h b = b", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} (f : \u03b1 \u2192 \u03b2 \u2192 \u03b2) (h : \u2200 (x : \u03b1), x \u2208 0 \u2192 \u2200 (y : \u03b1), y \u2208 0 \u2192 \u2200 (b : \u03b2), f x (f y b) = f y (f x b)) (b : \u03b2), multiset.noncomm_foldr f 0 h b = b", "decl_nm": "multiset.noncomm_foldr_empty"}
{"formal_statement": "theorem image_preimage {\u03b1 \u03b2 : Type*} [has_le \u03b1] [has_le \u03b2] (e : \u03b1 \u2243o \u03b2)\n\t(s : set \u03b2) :\n\t\u21d1e '' (\u21d1e \u207b\u00b9' s) = s", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : has_le \u03b1] [_inst_2 : has_le \u03b2] (e : \u03b1 \u2243o \u03b2) (s : set \u03b2), \u21d1e '' (\u21d1e \u207b\u00b9' s) = s", "decl_nm": "order_iso.image_preimage"}
{"formal_statement": "theorem le_ker_iff {R : Type u} {L : Type v} {L' : Type w\u2082} [comm_ring R]\n\t[lie_ring L] [lie_algebra R L] [lie_ring L'] [lie_algebra R L'] (f : L \u2192\u2097\u2045R\u2046 L')\n\t(I : lie_ideal R L) :\n\tI \u2264 f.ker \u2194 \u2200 (x : L), x \u2208 I \u2192 \u21d1f x = 0", "decl_tp": "\u2200 {R : Type u} {L : Type v} {L' : Type w\u2082} [_inst_1 : comm_ring R] [_inst_2 : lie_ring L] [_inst_3 : lie_algebra R L] [_inst_4 : lie_ring L'] [_inst_5 : lie_algebra R L'] (f : L \u2192\u2097\u2045R\u2046 L') (I : lie_ideal R L), I \u2264 f.ker \u2194 \u2200 (x : L), x \u2208 I \u2192 \u21d1f x = 0", "decl_nm": "lie_hom.le_ker_iff"}
{"formal_statement": "theorem mul_support_mul_indicator_subset {\u03b1 M : Type*} [has_one M] {s : set \u03b1}\n\t{f : \u03b1 \u2192 M} :\n\tfunction.mul_support (s.mul_indicator f) \u2286 s", "decl_tp": "\u2200 {\u03b1 : Type u_1} {M : Type u_4} [_inst_1 : has_one M] {s : set \u03b1} {f : \u03b1 \u2192 M}, function.mul_support (s.mul_indicator f) \u2286 s", "decl_nm": "set.mul_support_mul_indicator_subset"}
{"formal_statement": "theorem trivial_to_Mon_ (C : Type u\u2081) [category_theory.category C] [category_theory.monoidal_category C]\n\t[category_theory.braided_category C] :\n\t(CommMon_.trivial C).to_Mon_ = Mon_.trivial C", "decl_tp": "\u2200 (C : Type u\u2081) [_inst_1 : category_theory.category C] [_inst_2 : category_theory.monoidal_category C] [_inst_3 : category_theory.braided_category C], (CommMon_.trivial C).to_Mon_ = Mon_.trivial C", "decl_nm": "CommMon_.trivial_to_Mon_"}
{"formal_statement": "theorem edist_le_mul {\u03b1 : Type u} {\u03b2 : Type v} [pseudo_emetric_space \u03b1]\n\t[pseudo_emetric_space \u03b2] {K : nnreal} {f : \u03b1 \u2192 \u03b2} (h : lipschitz_with K f) :\n\t\u2200 (x y : \u03b1), has_edist.edist (f x) (f y) \u2264 \u2191K * has_edist.edist x y", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : pseudo_emetric_space \u03b1] [_inst_2 : pseudo_emetric_space \u03b2] {K : nnreal} {f : \u03b1 \u2192 \u03b2}, lipschitz_with K f \u2192 \u2200 (x y : \u03b1), has_edist.edist (f x) (f y) \u2264 \u2191K * has_edist.edist x y", "decl_nm": "lipschitz_with.edist_le_mul"}
{"formal_statement": "theorem inv_eq_left_inv {n : Type u} [decidable_eq n] [fintype n] {\u03b1 : Type v}\n\t[comm_ring \u03b1] {A B : matrix n n \u03b1} (h : B.mul A = 1) :\n\tA\u207b\u00b9 = B", "decl_tp": "\u2200 {n : Type u} [_inst_1 : decidable_eq n] [_inst_2 : fintype n] {\u03b1 : Type v} [_inst_3 : comm_ring \u03b1] {A B : matrix n n \u03b1}, B.mul A = 1 \u2192 A\u207b\u00b9 = B", "decl_nm": "matrix.inv_eq_left_inv"}
{"formal_statement": "theorem zero_mul_eq_const {M\u2080 : Type*} [mul_zero_class M\u2080] :\n\thas_mul.mul 0 = function.const M\u2080 0", "decl_tp": "\u2200 {M\u2080 : Type u_1} [_inst_1 : mul_zero_class M\u2080], has_mul.mul 0 = function.const M\u2080 0", "decl_nm": "zero_mul_eq_const"}
{"formal_statement": "theorem finrank_R (\u03c3 K : Type u) [fintype \u03c3] [field K] [fintype K] :\n\tfinite_dimensional.finrank K (mv_polynomial.R \u03c3 K) = fintype.card (\u03c3 \u2192 K)", "decl_tp": "\u2200 (\u03c3 K : Type u) [_inst_1 : fintype \u03c3] [_inst_2 : field K] [_inst_3 : fintype K], finite_dimensional.finrank K (mv_polynomial.R \u03c3 K) = fintype.card (\u03c3 \u2192 K)", "decl_nm": "mv_polynomial.finrank_R"}
{"formal_statement": "theorem mk_add_move_left_inl {xl xr yl yr : Type*} {xL : xl \u2192 pgame} {xR : xr \u2192 pgame}\n\t{yL : yl \u2192 pgame} {yR : yr \u2192 pgame} {i : xl} :\n\t(pgame.mk xl xr xL xR + pgame.mk yl yr yL yR).move_left (sum.inl i) = (pgame.mk xl xr xL xR).move_left i + pgame.mk yl yr yL yR", "decl_tp": "\u2200 {xl xr yl yr : Type u_1} {xL : xl \u2192 pgame} {xR : xr \u2192 pgame} {yL : yl \u2192 pgame} {yR : yr \u2192 pgame} {i : xl}, (pgame.mk xl xr xL xR + pgame.mk yl yr yL yR).move_left (sum.inl i) = (pgame.mk xl xr xL xR).move_left i + pgame.mk yl yr yL yR", "decl_nm": "pgame.mk_add_move_left_inl"}
{"formal_statement": "theorem not_bdd_above_univ {\u03b1 : Type u} [preorder \u03b1] [no_top_order \u03b1] :\n\t\u00acbdd_above set.univ", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : preorder \u03b1] [_inst_3 : no_top_order \u03b1], \u00acbdd_above set.univ", "decl_nm": "not_bdd_above_univ"}
{"formal_statement": "theorem frobenius_mul {R : Type u} [comm_semiring R] (p : \u2115) [fact (nat.prime p)]\n\t[char_p R p] (x y : R) :\n\t\u21d1(frobenius R p) (x * y) = \u21d1(frobenius R p) x * \u21d1(frobenius R p) y", "decl_tp": "\u2200 {R : Type u} [_inst_1 : comm_semiring R] (p : \u2115) [_inst_3 : fact (nat.prime p)] [_inst_4 : char_p R p] (x y : R), \u21d1(frobenius R p) (x * y) = \u21d1(frobenius R p) x * \u21d1(frobenius R p) y", "decl_nm": "frobenius_mul"}
{"formal_statement": "theorem single_zero_alg_hom_apply {k : Type u\u2081} {G : Type u\u2082} {R : Type*}\n\t[comm_semiring R] [semiring k] [algebra R k] [add_monoid G] (\u1fb0 : k) :\n\t\u21d1add_monoid_algebra.single_zero_alg_hom \u1fb0 = add_monoid_algebra.single_zero_ring_hom.to_fun \u1fb0", "decl_tp": "\u2200 {k : Type u\u2081} {G : Type u\u2082} {R : Type u_1} [_inst_1 : comm_semiring R] [_inst_2 : semiring k] [_inst_3 : algebra R k] [_inst_4 : add_monoid G] (\u1fb0 : k), \u21d1add_monoid_algebra.single_zero_alg_hom \u1fb0 = add_monoid_algebra.single_zero_ring_hom.to_fun \u1fb0", "decl_nm": "add_monoid_algebra.single_zero_alg_hom_apply"}
{"formal_statement": "theorem encode_tt :\n\tencodable.encode bool.tt = 1", "decl_tp": "encodable.encode bool.tt = 1", "decl_nm": "encodable.encode_tt"}
{"formal_statement": "theorem corec_def {\u03b1 : Type u} {\u03b2 : Type v} (f : \u03b1 \u2192 \u03b2) (g : \u03b1 \u2192 \u03b1) (a : \u03b1) :\n\tstream.corec f g a = stream.map f (stream.iterate g a)", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} (f : \u03b1 \u2192 \u03b2) (g : \u03b1 \u2192 \u03b1) (a : \u03b1), stream.corec f g a = stream.map f (stream.iterate g a)", "decl_nm": "stream.corec_def"}
{"formal_statement": "theorem keys_nodup {\u03b1 : Type u} {\u03b2 : \u03b1 \u2192 Type v} (s : alist \u03b2) :\n\ts.keys.nodup", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : \u03b1 \u2192 Type v} (s : alist \u03b2), s.keys.nodup", "decl_nm": "alist.keys_nodup"}
{"formal_statement": "theorem image_norm_le_of_norm_deriv_right_lt_deriv_boundary' {E : Type*}\n\t[normed_group E] [normed_space \u211d E] {f : \u211d \u2192 E} {a b : \u211d} {f' : \u211d \u2192 E}\n\t(hf : continuous_on f (set.Icc a b)) (ha : \u2225f a\u2225 \u2264 B a) (hB : continuous_on B (set.Icc a b)) :\n\t(\u2200 (x : \u211d), x \u2208 set.Ico a b \u2192 has_deriv_within_at f (f' x) (set.Ici x) x) \u2192 \u2200 {B B' : \u211d \u2192 \u211d},   (\u2200 (x : \u211d), x \u2208 set.Ico a b \u2192 has_deriv_within_at B (B' x)\n\t(set.Ici x) x) \u2192 (\u2200 (x : \u211d), x \u2208 set.Ico a b \u2192 \u2225f x\u2225 = B x \u2192 \u2225f' x\u2225 < B' x) \u2192 \u2200 \u2983x : \u211d\u2984, x \u2208 set.Icc a b \u2192 \u2225f x\u2225 \u2264 B x", "decl_tp": "\u2200 {E : Type u_1} [_inst_1 : normed_group E] [_inst_2 : normed_space \u211d E] {f : \u211d \u2192 E} {a b : \u211d} {f' : \u211d \u2192 E}, continuous_on f (set.Icc a b) \u2192 (\u2200 (x : \u211d), x \u2208 set.Ico a b \u2192 has_deriv_within_at f (f' x) (set.Ici x) x) \u2192 \u2200 {B B' : \u211d \u2192 \u211d}, \u2225f a\u2225 \u2264 B a \u2192 continuous_on B (set.Icc a b) \u2192 (\u2200 (x : \u211d), x \u2208 set.Ico a b \u2192 has_deriv_within_at B (B' x) (set.Ici x) x) \u2192 (\u2200 (x : \u211d), x \u2208 set.Ico a b \u2192 \u2225f x\u2225 = B x \u2192 \u2225f' x\u2225 < B' x) \u2192 \u2200 \u2983x : \u211d\u2984, x \u2208 set.Icc a b \u2192 \u2225f x\u2225 \u2264 B x", "decl_nm": "image_norm_le_of_norm_deriv_right_lt_deriv_boundary'"}
{"formal_statement": "theorem to_perm_injective {\u03b1 : Type u} {\u03b2 : Type v} [group \u03b1] [mul_action \u03b1 \u03b2]\n\t[has_faithful_scalar \u03b1 \u03b2] :\n\tfunction.injective mul_action.to_perm", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : group \u03b1] [_inst_2 : mul_action \u03b1 \u03b2] [_inst_3 : has_faithful_scalar \u03b1 \u03b2], function.injective mul_action.to_perm", "decl_nm": "mul_action.to_perm_injective"}
{"formal_statement": "theorem coe_adj_sub {V : Type u} {G : simple_graph V} (G' : G.subgraph)\n\t(u v : \u21a5(G'.verts)) (h : G'.coe.adj u v) :\n\tG.adj \u2191u \u2191v", "decl_tp": "\u2200 {V : Type u} {G : simple_graph V} (G' : G.subgraph) (u v : \u21a5(G'.verts)), G'.coe.adj u v \u2192 G.adj \u2191u \u2191v", "decl_nm": "simple_graph.subgraph.coe_adj_sub"}
{"formal_statement": "theorem not_tendsto_nhds_of_tendsto_at_top {\u03b1 : Type u} {\u03b2 : Type v} [topological_space \u03b1]\n\t[linear_order \u03b1] [order_topology \u03b1] [no_top_order \u03b1] {F : filter \u03b2} [F.ne_bot]\n\t{f : \u03b2 \u2192 \u03b1} (hf : filter.tendsto f F filter.at_top) :\n\t\u2200 (x : \u03b1), \u00acfilter.tendsto f F (nhds x)", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : topological_space \u03b1] [_inst_2 : linear_order \u03b1] [_inst_3 : order_topology \u03b1] [_inst_4 : no_top_order \u03b1] {F : filter \u03b2} [_inst_5 : F.ne_bot] {f : \u03b2 \u2192 \u03b1}, filter.tendsto f F filter.at_top \u2192 \u2200 (x : \u03b1), \u00acfilter.tendsto f F (nhds x)", "decl_nm": "not_tendsto_nhds_of_tendsto_at_top"}
{"formal_statement": "theorem R_apply {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c] {H : Type*} [topological_space H]\n\t{E : Type*} [normed_group E] [normed_space \ud835\udd5c E] (I : model_with_corners \ud835\udd5c E H)\n\t{G : Type*} [has_mul G] [topological_space G] [charted_space H G] [has_smooth_mul I G]\n\t(g h : G) :\n\t\u21d1(smooth_right_mul I g) h = h * g", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {H : Type u_2} [_inst_2 : topological_space H] {E : Type u_3} [_inst_3 : normed_group E] [_inst_4 : normed_space \ud835\udd5c E] (I : model_with_corners \ud835\udd5c E H) {G : Type u_4} [_inst_5 : has_mul G] [_inst_6 : topological_space G] [_inst_7 : charted_space H G] [_inst_8 : has_smooth_mul I G] (g h : G), \u21d1(smooth_right_mul I g) h = h * g", "decl_nm": "R_apply"}
{"formal_statement": "theorem mk_le_mk {\u03b1 \u03b2 : Type*} [preorder \u03b1] [preorder \u03b2] {f g : \u03b1 \u2192 \u03b2}\n\t{hf : monotone f} {hg : monotone g} :\n\t{to_fun := f, monotone' := hf} \u2264 {to_fun := g, monotone' := hg} \u2194 f \u2264 g", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : preorder \u03b1] [_inst_2 : preorder \u03b2] {f g : \u03b1 \u2192 \u03b2} {hf : monotone f} {hg : monotone g}, {to_fun := f, monotone' := hf} \u2264 {to_fun := g, monotone' := hg} \u2194 f \u2264 g", "decl_nm": "order_hom.mk_le_mk"}
{"formal_statement": "theorem lift_top {\u03b1 \u03b2 : Type*} (g : set \u03b1 \u2192 filter \u03b2) :\n\t\u22a4.lift g = g set.univ", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} (g : set \u03b1 \u2192 filter \u03b2), \u22a4.lift g = g set.univ", "decl_nm": "filter.lift_top"}
{"formal_statement": "theorem norm_sub_norm_le {E : Type*} [semi_normed_group E] (g h : E) :\n\t\u2225g\u2225 - \u2225h\u2225 \u2264 \u2225g - h\u2225", "decl_tp": "\u2200 {E : Type u_3} [_inst_1 : semi_normed_group E] (g h : E), \u2225g\u2225 - \u2225h\u2225 \u2264 \u2225g - h\u2225", "decl_nm": "norm_sub_norm_le"}
{"formal_statement": "theorem tan_arctan (x : \u211d) :\n\treal.tan (real.arctan x) = x", "decl_tp": "\u2200 (x : \u211d), real.tan (real.arctan x) = x", "decl_nm": "real.tan_arctan"}
{"formal_statement": "theorem eta (z : \u2102) :\n\t{re := z.re, im := z.im} = z", "decl_tp": "\u2200 (z : \u2102), {re := z.re, im := z.im} = z", "decl_nm": "complex.eta"}
{"formal_statement": "theorem map_Sup {\u03b1 : Type u} {\u03b2 : Type v} [complete_lattice \u03b1] [complete_lattice \u03b2]\n\t{f : \u03b1 \u2192 \u03b2} (hf : left_ord_continuous f) :\n\t\u2200 (s : set \u03b1), f (has_Sup.Sup s) = \u2a06 (x : \u03b1) (H : x \u2208 s), f x", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : complete_lattice \u03b1] [_inst_2 : complete_lattice \u03b2] {f : \u03b1 \u2192 \u03b2}, left_ord_continuous f \u2192 \u2200 (s : set \u03b1), f (has_Sup.Sup s) = \u2a06 (x : \u03b1) (H : x \u2208 s), f x", "decl_nm": "left_ord_continuous.map_Sup"}
{"formal_statement": "theorem lt_iff_exists_nnreal_btwn {a b : ennreal} :\n\ta < b \u2194 \u2203 (r : nnreal), a < \u2191r \u2227 \u2191r < b", "decl_tp": "\u2200 {a b : ennreal}, a < b \u2194 \u2203 (r : nnreal), a < \u2191r \u2227 \u2191r < b", "decl_nm": "ennreal.lt_iff_exists_nnreal_btwn"}
{"formal_statement": "theorem eq_inverse_map (m : Type u \u2192 Type u) [monad m] [is_lawful_monad m]\n\t(X Y : category_theory.kleisli (category_theory.of_type_monad m)) (f : X \u27f6 Y)\n\t(\u1fb0 : X) :\n\t(category_theory.eq m).inverse.map f \u1fb0 = f \u1fb0", "decl_tp": "\u2200 (m : Type u \u2192 Type u) [_inst_1 : monad m] [_inst_2 : is_lawful_monad m] (X Y : category_theory.kleisli (category_theory.of_type_monad m)) (f : X \u27f6 Y) (\u1fb0 : X), (category_theory.eq m).inverse.map f \u1fb0 = f \u1fb0", "decl_nm": "category_theory.eq_inverse_map"}
{"formal_statement": "theorem infi_const {\u03b1 : Type*} {\u03b9 : Sort u_4} [complete_lattice \u03b1] [nonempty \u03b9]\n\t{a : \u03b1} :\n\t(\u2a05 (b : \u03b9), a) = a", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b9 : Sort u_4} [_inst_1 : complete_lattice \u03b1] [_inst_2 : nonempty \u03b9] {a : \u03b1}, (\u2a05 (b : \u03b9), a) = a", "decl_nm": "infi_const"}
{"formal_statement": "theorem open_segment_translate_image (\ud835\udd5c : Type*) {E : Type*} [ordered_ring \ud835\udd5c]\n\t[add_comm_group E] [module \ud835\udd5c E] (a b c : E) :\n\t(\u03bb (x : E), a + x) '' open_segment \ud835\udd5c b c = open_segment \ud835\udd5c (a + b) (a + c)", "decl_tp": "\u2200 (\ud835\udd5c : Type u_1) {E : Type u_2} [_inst_1 : ordered_ring \ud835\udd5c] [_inst_2 : add_comm_group E] [_inst_4 : module \ud835\udd5c E] (a b c : E), (\u03bb (x : E), a + x) '' open_segment \ud835\udd5c b c = open_segment \ud835\udd5c (a + b) (a + c)", "decl_nm": "open_segment_translate_image"}
{"formal_statement": "theorem fst {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c] {E : Type*} [normed_group E]\n\t[normed_space \ud835\udd5c E] {F : Type*} [normed_group F] [normed_space \ud835\udd5c F] {G : Type*}\n\t[normed_group G] [normed_space \ud835\udd5c G] {x : E} {f\u2082 : E \u2192 F \u00d7 G} {f\u2082' : E \u2192L[\ud835\udd5c] F \u00d7 G}\n\t(h : has_strict_fderiv_at f\u2082 f\u2082' x) :\n\thas_strict_fderiv_at (\u03bb (x : E), (f\u2082 x).fst) ((continuous_linear_map.fst \ud835\udd5c F G).comp f\u2082') x", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {F : Type u_3} [_inst_4 : normed_group F] [_inst_5 : normed_space \ud835\udd5c F] {G : Type u_4} [_inst_6 : normed_group G] [_inst_7 : normed_space \ud835\udd5c G] {x : E} {f\u2082 : E \u2192 F \u00d7 G} {f\u2082' : E \u2192L[\ud835\udd5c] F \u00d7 G}, has_strict_fderiv_at f\u2082 f\u2082' x \u2192 has_strict_fderiv_at (\u03bb (x : E), (f\u2082 x).fst) ((continuous_linear_map.fst \ud835\udd5c F G).comp f\u2082') x", "decl_nm": "has_strict_fderiv_at.fst"}
{"formal_statement": "theorem exists_infinite_fiber {\u03b2 \u03b1 : Type*} (f : \u03b2 \u2192 \u03b1) (w : cardinal.mk \u03b1 < cardinal.mk \u03b2)\n\t(w' : infinite \u03b1) :\n\t(\u2203 (a : \u03b1), infinite \u21a5(f \u207b\u00b9' {a}))", "decl_tp": "\u2200 {\u03b2 \u03b1 : Type u_1} (f : \u03b2 \u2192 \u03b1), cardinal.mk \u03b1 < cardinal.mk \u03b2 \u2192 infinite \u03b1 \u2192 (\u2203 (a : \u03b1), infinite \u21a5(f \u207b\u00b9' {a}))", "decl_nm": "cardinal.exists_infinite_fiber"}
{"formal_statement": "theorem comp_to_nat_trans {C : Type u\u2081} [category_theory.category C] [category_theory.monoidal_category C]\n\t[category_theory.braided_category C] {D : Type u\u2082} [category_theory.category D]\n\t[category_theory.monoidal_category D] [category_theory.braided_category D]\n\t{F G H : category_theory.braided_functor C D} {\u03b1 : F \u27f6 G} {\u03b2 : G \u27f6 H} :\n\t(\u03b1 \u226b \u03b2).to_nat_trans = \u03b1.to_nat_trans \u226b \u03b2.to_nat_trans", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] [_inst_2 : category_theory.monoidal_category C] [_inst_3 : category_theory.braided_category C] {D : Type u\u2082} [_inst_4 : category_theory.category D] [_inst_5 : category_theory.monoidal_category D] [_inst_6 : category_theory.braided_category D] {F G H : category_theory.braided_functor C D} {\u03b1 : F \u27f6 G} {\u03b2 : G \u27f6 H}, (\u03b1 \u226b \u03b2).to_nat_trans = \u03b1.to_nat_trans \u226b \u03b2.to_nat_trans", "decl_nm": "category_theory.braided_functor.comp_to_nat_trans"}
{"formal_statement": "theorem prod_coe_symm {\u03b1 \u03b2 \u03b3 \u03b4 : Type*} (e : local_equiv \u03b1 \u03b2) (e' : local_equiv \u03b3 \u03b4) :\n\t\u21d1((e.prod e').symm) = \u03bb (p : \u03b2 \u00d7 \u03b4), (\u21d1(e.symm) p.fst, \u21d1(e'.symm) p.snd)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {\u03b3 : Type u_3} {\u03b4 : Type u_4} (e : local_equiv \u03b1 \u03b2) (e' : local_equiv \u03b3 \u03b4), \u21d1((e.prod e').symm) = \u03bb (p : \u03b2 \u00d7 \u03b4), (\u21d1(e.symm) p.fst, \u21d1(e'.symm) p.snd)", "decl_nm": "local_equiv.prod_coe_symm"}
{"formal_statement": "theorem supr_sigma {\u03b1 \u03b2 : Type*} [complete_lattice \u03b1] {p : \u03b2 \u2192 Type*} {f : sigma p \u2192 \u03b1} :\n\t(\u2a06 (x : sigma p), f x) = \u2a06 (i : \u03b2) (h : p i), f \u27e8i, h\u27e9", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : complete_lattice \u03b1] {p : \u03b2 \u2192 Type u_3} {f : sigma p \u2192 \u03b1}, (\u2a06 (x : sigma p), f x) = \u2a06 (i : \u03b2) (h : p i), f \u27e8i, h\u27e9", "decl_nm": "supr_sigma"}
{"formal_statement": "theorem lt_inf_iff {\u03b1 : Type u} [semilattice_inf \u03b1] [is_total \u03b1 has_le.le]\n\t{a b c : \u03b1} :\n\ta < b \u2293 c \u2194 a < b \u2227 a < c", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : semilattice_inf \u03b1] [_inst_2 : is_total \u03b1 has_le.le] {a b c : \u03b1}, a < b \u2293 c \u2194 a < b \u2227 a < c", "decl_nm": "lt_inf_iff"}
{"formal_statement": "theorem dest_eq_dest' {n : \u2115} (P : mvpfunctor (n + 1)) {\u03b1 : typevec n}\n\t{x : P.last.M} {a : P.A} {f : P.last.B a \u2192 P.last.M} (h : x.dest = \u27e8a, f\u27e9)\n\t(f' : typevec.arrow (mvpfunctor.M.path P x) \u03b1) :\n\tmvpfunctor.M.dest P \u27e8x, f'\u27e9 = mvpfunctor.M.dest' P h f'", "decl_tp": "\u2200 {n : \u2115} (P : mvpfunctor (n + 1)) {\u03b1 : typevec n} {x : P.last.M} {a : P.A} {f : P.last.B a \u2192 P.last.M} (h : x.dest = \u27e8a, f\u27e9) (f' : typevec.arrow (mvpfunctor.M.path P x) \u03b1), mvpfunctor.M.dest P \u27e8x, f'\u27e9 = mvpfunctor.M.dest' P h f'", "decl_nm": "mvpfunctor.M.dest_eq_dest'"}
{"formal_statement": "theorem range_eq_univ {R R\u2082 E E\u2082 : Type*} [semiring R] [semiring R\u2082] {\u03c3\u2081\u2082 : R \u2192+* R\u2082}\n\t{\u03c3\u2082\u2081 : R\u2082 \u2192+* R} [ring_hom_inv_pair \u03c3\u2081\u2082 \u03c3\u2082\u2081] [ring_hom_inv_pair \u03c3\u2082\u2081 \u03c3\u2081\u2082]\n\t[semi_normed_group E] [semi_normed_group E\u2082] [module R E] [module R\u2082 E\u2082]\n\t(e : E \u2243\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082) :\n\tset.range \u21d1e = set.univ", "decl_tp": "\u2200 {R : Type u_1} {R\u2082 : Type u_2} {E : Type u_5} {E\u2082 : Type u_6} [_inst_1 : semiring R] [_inst_2 : semiring R\u2082] {\u03c3\u2081\u2082 : R \u2192+* R\u2082} {\u03c3\u2082\u2081 : R\u2082 \u2192+* R} [_inst_5 : ring_hom_inv_pair \u03c3\u2081\u2082 \u03c3\u2082\u2081] [_inst_6 : ring_hom_inv_pair \u03c3\u2082\u2081 \u03c3\u2081\u2082] [_inst_25 : semi_normed_group E] [_inst_26 : semi_normed_group E\u2082] [_inst_29 : module R E] [_inst_30 : module R\u2082 E\u2082] (e : E \u2243\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082), set.range \u21d1e = set.univ", "decl_nm": "linear_isometry_equiv.range_eq_univ"}
{"formal_statement": "theorem is_open_iff_forall_mem_open {\u03b1 : Type u} {s : set \u03b1} [topological_space \u03b1] :\n\tis_open s \u2194 \u2200 (x : \u03b1), x \u2208 s \u2192 (\u2203 (t : set \u03b1) (H : t \u2286 s), is_open t \u2227 x \u2208 t)", "decl_tp": "\u2200 {\u03b1 : Type u} {s : set \u03b1} [_inst_1 : topological_space \u03b1], is_open s \u2194 \u2200 (x : \u03b1), x \u2208 s \u2192 (\u2203 (t : set \u03b1) (H : t \u2286 s), is_open t \u2227 x \u2208 t)", "decl_nm": "is_open_iff_forall_mem_open"}
{"formal_statement": "theorem kronecker_tmul_add (R : Type*) {\u03b1 l m n : Type*0} {p : Type*1}\n\t[comm_semiring R] [add_comm_monoid \u03b1] [module R \u03b1] (A : matrix l m \u03b1)\n\t(B\u2081 B\u2082 : matrix n p \u03b1) :\n\tmatrix.kronecker_map (tensor_product.tmul R) A (B\u2081 + B\u2082) = matrix.kronecker_map (\u03bb (_x _y : \u03b1), _x \u2297\u209c[R] _y) A B\u2081 + matrix.kronecker_map (\u03bb (_x _y : \u03b1), _x \u2297\u209c[R] _y) A B\u2082", "decl_tp": "\u2200 (R : Type u_1) {\u03b1 : Type u_2} {l : Type u_8} {m : Type u_9} {n : Type u_10} {p : Type u_11} [_inst_1 : comm_semiring R] [_inst_2 : add_comm_monoid \u03b1] [_inst_5 : module R \u03b1] (A : matrix l m \u03b1) (B\u2081 B\u2082 : matrix n p \u03b1), matrix.kronecker_map (tensor_product.tmul R) A (B\u2081 + B\u2082) = matrix.kronecker_map (\u03bb (_x _y : \u03b1), _x \u2297\u209c[R] _y) A B\u2081 + matrix.kronecker_map (\u03bb (_x _y : \u03b1), _x \u2297\u209c[R] _y) A B\u2082", "decl_nm": "matrix.kronecker_tmul_add"}
{"formal_statement": "theorem is_pi_system_measurable_set {\u03b1 : Type*} [measurable_space \u03b1] :\n\tis_pi_system {s : set \u03b1 | measurable_set s}", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : measurable_space \u03b1], is_pi_system {s : set \u03b1 | measurable_set s}", "decl_nm": "measurable_space.is_pi_system_measurable_set"}
{"formal_statement": "theorem local_homeomorph_subtype_coe_source {\u03b1 : Type*} [topological_space \u03b1]\n\t(s : topological_space.opens \u03b1) [nonempty \u21a5s] :\n\ts.local_homeomorph_subtype_coe.to_local_equiv.source = set.univ", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : topological_space \u03b1] (s : topological_space.opens \u03b1) [_inst_5 : nonempty \u21a5s], s.local_homeomorph_subtype_coe.to_local_equiv.source = set.univ", "decl_nm": "topological_space.opens.local_homeomorph_subtype_coe_source"}
{"formal_statement": "theorem empty_or_exists_mem {\u03b1 : Type*} (s : multiset \u03b1) :\n\ts = 0 \u2228 \u2203 (a : \u03b1), a \u2208 s", "decl_tp": "\u2200 {\u03b1 : Type u_1} (s : multiset \u03b1), s = 0 \u2228 \u2203 (a : \u03b1), a \u2208 s", "decl_nm": "multiset.empty_or_exists_mem"}
{"formal_statement": "theorem zero_power {a : ordinal} (a0 : a \u2260 0) :\n\t0 ^ a = 0", "decl_tp": "\u2200 {a : ordinal}, a \u2260 0 \u2192 0 ^ a = 0", "decl_nm": "ordinal.zero_power"}
{"formal_statement": "theorem coe_range {G : Type*} [add_group G] {N : Type*} [add_group N] (f : G \u2192+ N) :\n\t\u2191(f.range) = set.range \u21d1f", "decl_tp": "\u2200 {G : Type u_1} [_inst_1 : add_group G] {N : Type u_3} [_inst_3 : add_group N] (f : G \u2192+ N), \u2191(f.range) = set.range \u21d1f", "decl_nm": "add_monoid_hom.coe_range"}
{"formal_statement": "theorem mk_factors_iff {C : Type u\u2081} [category_theory.category C] {X Y Z : C}\n\t(f : Y \u27f6 X) [category_theory.mono f] (g : Z \u27f6 X) :\n\t(category_theory.subobject.mk f).factors g \u2194 (category_theory.mono_over.mk' f).factors g", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {X Y Z : C} (f : Y \u27f6 X) [_inst_3 : category_theory.mono f] (g : Z \u27f6 X), (category_theory.subobject.mk f).factors g \u2194 (category_theory.mono_over.mk' f).factors g", "decl_nm": "category_theory.subobject.mk_factors_iff"}
{"formal_statement": "theorem div {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c] {H : Type*} [topological_space H]\n\t{E : Type*} [normed_group E] [normed_space \ud835\udd5c E] {I : model_with_corners \ud835\udd5c E H}\n\t{G : Type*} [topological_space G] [charted_space H G] [group G] [lie_group I G]\n\t{E' : Type*} [normed_group E'] [normed_space \ud835\udd5c E'] {H' : Type*} [topological_space H']\n\t{I' : model_with_corners \ud835\udd5c E' H'} {M : Type*} [topological_space M] [charted_space H' M]\n\t{f g : M \u2192 G} (hf : smooth I' I f) (hg : smooth I' I g) :\n\tsmooth I' I (f / g)", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {H : Type u_2} [_inst_2 : topological_space H] {E : Type u_3} [_inst_3 : normed_group E] [_inst_4 : normed_space \ud835\udd5c E] {I : model_with_corners \ud835\udd5c E H} {G : Type u_5} [_inst_7 : topological_space G] [_inst_8 : charted_space H G] [_inst_9 : group G] [_inst_10 : lie_group I G] {E' : Type u_6} [_inst_11 : normed_group E'] [_inst_12 : normed_space \ud835\udd5c E'] {H' : Type u_7} [_inst_13 : topological_space H'] {I' : model_with_corners \ud835\udd5c E' H'} {M : Type u_8} [_inst_14 : topological_space M] [_inst_15 : charted_space H' M] {f g : M \u2192 G}, smooth I' I f \u2192 smooth I' I g \u2192 smooth I' I (f / g)", "decl_nm": "smooth.div"}
{"formal_statement": "theorem cast_bit0 {\u03b1 : Type*} [ring \u03b1] (n : \u2124) :\n\t\u2191(bit0 n) = bit0 \u2191n", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : ring \u03b1] (n : \u2124), \u2191(bit0 n) = bit0 \u2191n", "decl_nm": "int.cast_bit0"}
{"formal_statement": "theorem not_mem_of_not_mem_closure {R : Type u} [ring R] {s : set R} {P : R}\n\t(hP : P \u2209 subring.closure s) :\n\tP \u2209 s", "decl_tp": "\u2200 {R : Type u} [_inst_1 : ring R] {s : set R} {P : R}, P \u2209 subring.closure s \u2192 P \u2209 s", "decl_nm": "subring.not_mem_of_not_mem_closure"}
{"formal_statement": "theorem cycles_functor_map {\u03b9 : Type*} (V : Type u) [category_theory.category V]\n\t[category_theory.limits.has_zero_morphisms V] (c : complex_shape \u03b9) [category_theory.limits.has_zero_object V]\n\t[category_theory.limits.has_kernels V] (i : \u03b9) (C\u2081 C\u2082 : homological_complex V c)\n\t(f : C\u2081 \u27f6 C\u2082) :\n\t(cycles_functor V c i).map f = cycles_map f i", "decl_tp": "\u2200 {\u03b9 : Type u_1} (V : Type u) [_inst_1 : category_theory.category V] [_inst_2 : category_theory.limits.has_zero_morphisms V] (c : complex_shape \u03b9) [_inst_3 : category_theory.limits.has_zero_object V] [_inst_4 : category_theory.limits.has_kernels V] (i : \u03b9) (C\u2081 C\u2082 : homological_complex V c) (f : C\u2081 \u27f6 C\u2082), (cycles_functor V c i).map f = cycles_map f i", "decl_nm": "cycles_functor_map"}
{"formal_statement": "theorem le_iterate_of_le {\u03b1 : Type*} [preorder \u03b1] {f g : \u03b1 \u2192 \u03b1} (hg : monotone g)\n\t(h : f \u2264 g) :\n\t\u2200 (n : \u2115), f^[n] \u2264 (g^[n])", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : preorder \u03b1] {f g : \u03b1 \u2192 \u03b1}, monotone g \u2192 f \u2264 g \u2192 \u2200 (n : \u2115), f^[n] \u2264 (g^[n])", "decl_nm": "monotone.le_iterate_of_le"}
{"formal_statement": "theorem perm_insertion_sort {\u03b1 : Type uu} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [decidable_rel r]\n\t(l : list \u03b1) :\n\tlist.insertion_sort r l ~ l", "decl_tp": "\u2200 {\u03b1 : Type uu} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [_inst_1 : decidable_rel r] (l : list \u03b1), list.insertion_sort r l ~ l", "decl_nm": "list.perm_insertion_sort"}
{"formal_statement": "theorem sum_def {R : Type u} {\u03c3 : Type*} [comm_semiring R] {A : Type*}\n\t[add_comm_monoid A] {p : mv_polynomial \u03c3 R} {b : (\u03c3 \u2192\u2080 \u2115) \u2192 R \u2192 A} :\n\tfinsupp.sum p b = p.support.sum (\u03bb (m : \u03c3 \u2192\u2080 \u2115), b m (mv_polynomial.coeff m p))", "decl_tp": "\u2200 {R : Type u} {\u03c3 : Type u_1} [_inst_1 : comm_semiring R] {A : Type u_2} [_inst_3 : add_comm_monoid A] {p : mv_polynomial \u03c3 R} {b : (\u03c3 \u2192\u2080 \u2115) \u2192 R \u2192 A}, finsupp.sum p b = p.support.sum (\u03bb (m : \u03c3 \u2192\u2080 \u2115), b m (mv_polynomial.coeff m p))", "decl_nm": "mv_polynomial.sum_def"}
{"formal_statement": "theorem topological_ring_of_smooth {\ud835\udd5c R E H : Type*} [topological_space R]\n\t[topological_space H] [nondiscrete_normed_field \ud835\udd5c] [normed_group E] [normed_space \ud835\udd5c E]\n\t[charted_space H R] (I : model_with_corners \ud835\udd5c E H) [semiring R] [smooth_ring I R] :\n\ttopological_ring R", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} {R : Type u_2} {E : Type u_3} {H : Type u_4} [_inst_1 : topological_space R] [_inst_2 : topological_space H] [_inst_3 : nondiscrete_normed_field \ud835\udd5c] [_inst_4 : normed_group E] [_inst_5 : normed_space \ud835\udd5c E] [_inst_6 : charted_space H R] (I : model_with_corners \ud835\udd5c E H) [_inst_7 : semiring R] [_inst_8 : smooth_ring I R], topological_ring R", "decl_nm": "topological_ring_of_smooth"}
{"formal_statement": "theorem map_nhds_eq {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c] {E : Type*}\n\t[normed_group E] [normed_space \ud835\udd5c E] {H : Type*} [topological_space H]\n\t(I : model_with_corners \ud835\udd5c E H) (x : H) :\n\tfilter.map \u21d1I (nhds x) = nhds_within (\u21d1I x) (set.range \u21d1I)", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {H : Type u_3} [_inst_4 : topological_space H] (I : model_with_corners \ud835\udd5c E H) (x : H), filter.map \u21d1I (nhds x) = nhds_within (\u21d1I x) (set.range \u21d1I)", "decl_nm": "model_with_corners.map_nhds_eq"}
{"formal_statement": "theorem ne_zero_of_pos {\u03b1 : Type*} [ordered_add_comm_group \u03b1] (a : \u03b1) :\n\t0 < a \u2192 a \u2260 0", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : ordered_add_comm_group \u03b1] (a : \u03b1), 0 < a \u2192 a \u2260 0", "decl_nm": "norm_num.ne_zero_of_pos"}
{"formal_statement": "theorem coe_finset_basis_index (K : Type u) (V : Type v) [division_ring K]\n\t[add_comm_group V] [module K V] [is_noetherian_ring K] [is_noetherian K V] :\n\t\u2191(is_noetherian.finset_basis_index K V) = basis.of_vector_space_index K V", "decl_tp": "\u2200 (K : Type u) (V : Type v) [_inst_1 : division_ring K] [_inst_2 : add_comm_group V] [_inst_3 : module K V] [_inst_4 : is_noetherian_ring K] [_inst_5 : is_noetherian K V], \u2191(is_noetherian.finset_basis_index K V) = basis.of_vector_space_index K V", "decl_nm": "is_noetherian.coe_finset_basis_index"}
{"formal_statement": "theorem fold_mfoldr {\u03b1 \u03b2 : Type u} (m : Type u \u2192 Type u) [monad m] [is_lawful_monad m]\n\t(f : \u03b1 \u2192 \u03b2 \u2192 m \u03b2) :\n\tis_monoid_hom (monoid.mfoldr.of_free_monoid f)", "decl_tp": "\u2200 {\u03b1 \u03b2 : Type u} (m : Type u \u2192 Type u) [_inst_1 : monad m] [_inst_2 : is_lawful_monad m] (f : \u03b1 \u2192 \u03b2 \u2192 m \u03b2), is_monoid_hom (monoid.mfoldr.of_free_monoid f)", "decl_nm": "traversable.fold_mfoldr"}
{"formal_statement": "theorem floor_lt_ceil_of_lt {\u03b1 : Type*} [linear_ordered_ring \u03b1] [floor_ring \u03b1]\n\t{a b : \u03b1} (h : a < b) :\n\t\u230aa\u230b < \u2308b\u2309", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : linear_ordered_ring \u03b1] [_inst_2 : floor_ring \u03b1] {a b : \u03b1}, a < b \u2192 \u230aa\u230b < \u2308b\u2309", "decl_nm": "int.floor_lt_ceil_of_lt"}
{"formal_statement": "theorem algebra_map_eq {R : Type*} [comm_ring R] {c\u2081 c\u2082 : R} (r : R) :\n\t\u21d1(algebra_map R (quaternion_algebra R c\u2081 c\u2082)) r = {re := r, im_i := 0, im_j := 0, im_k := 0}", "decl_tp": "\u2200 {R : Type u_1} [_inst_1 : comm_ring R] {c\u2081 c\u2082 : R} (r : R), \u21d1(algebra_map R (quaternion_algebra R c\u2081 c\u2082)) r = {re := r, im_i := 0, im_j := 0, im_k := 0}", "decl_nm": "quaternion_algebra.algebra_map_eq"}
{"formal_statement": "theorem cocone_points_iso_of_equivalence_hom {J : Type u\u2081} [category_theory.category J]\n\t{K : Type u\u2082} [category_theory.category K] {C : Type u\u2083} [category_theory.category C]\n\t{F : J \u2964 C} {s : category_theory.limits.cocone F} {G : K \u2964 C} {t : category_theory.limits.cocone G}\n\t(P : category_theory.limits.is_colimit s) (Q : category_theory.limits.is_colimit t)\n\t(e : J \u224c K) (w : e.functor \u22d9 G \u2245 F) :\n\t(P.cocone_points_iso_of_equivalence Q e w).hom = P.desc ((category_theory.limits.cocones.equivalence_of_reindexing e w).functor.obj t)", "decl_tp": "\u2200 {J : Type u\u2081} [_inst_1 : category_theory.category J] {K : Type u\u2082} [_inst_2 : category_theory.category K] {C : Type u\u2083} [_inst_3 : category_theory.category C] {F : J \u2964 C} {s : category_theory.limits.cocone F} {G : K \u2964 C} {t : category_theory.limits.cocone G} (P : category_theory.limits.is_colimit s) (Q : category_theory.limits.is_colimit t) (e : J \u224c K) (w : e.functor \u22d9 G \u2245 F), (P.cocone_points_iso_of_equivalence Q e w).hom = P.desc ((category_theory.limits.cocones.equivalence_of_reindexing e w).functor.obj t)", "decl_nm": "category_theory.limits.is_colimit.cocone_points_iso_of_equivalence_hom"}
{"formal_statement": "theorem tensor_eq_tensor {C : Type u} {X Y : category_theory.free_monoidal_category C} :\n\tX.tensor Y = X \u2297 Y", "decl_tp": "\u2200 {C : Type u} {X Y : category_theory.free_monoidal_category C}, X.tensor Y = X \u2297 Y", "decl_nm": "category_theory.free_monoidal_category.tensor_eq_tensor"}
{"formal_statement": "theorem linear_map_apply (R : Type u) (A : Type w) [comm_semiring R] [semiring A]\n\t[algebra R A] (r : R) :\n\t\u21d1(algebra.linear_map R A) r = \u21d1(algebra_map R A) r", "decl_tp": "\u2200 (R : Type u) (A : Type w) [_inst_1 : comm_semiring R] [_inst_3 : semiring A] [_inst_4 : algebra R A] (r : R), \u21d1(algebra.linear_map R A) r = \u21d1(algebra_map R A) r", "decl_nm": "algebra.linear_map_apply"}
{"formal_statement": "theorem map_top' {\u03b1 \u03b2 : Type*} [has_le \u03b1] [partial_order \u03b2] (f : \u03b1 \u2243o \u03b2)\n\t{x : \u03b1} {y : \u03b2} :\n\t(\u2200 (x' : \u03b1), x' \u2264 x) \u2192 (\u2200 (y' : \u03b2), y' \u2264 y) \u2192 \u21d1f x = y", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : has_le \u03b1] [_inst_2 : partial_order \u03b2] (f : \u03b1 \u2243o \u03b2) {x : \u03b1} {y : \u03b2}, (\u2200 (x' : \u03b1), x' \u2264 x) \u2192 (\u2200 (y' : \u03b2), y' \u2264 y) \u2192 \u21d1f x = y", "decl_nm": "order_iso.map_top'"}
{"formal_statement": "theorem inf_eq_right {\u03b1 : Type u} [semilattice_inf \u03b1] {a b : \u03b1} :\n\ta \u2293 b = b \u2194 b \u2264 a", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : semilattice_inf \u03b1] {a b : \u03b1}, a \u2293 b = b \u2194 b \u2264 a", "decl_nm": "inf_eq_right"}
{"formal_statement": "theorem union_inter_cancel_left {\u03b1 : Type u} {s t : set \u03b1} :\n\t(s \u222a t) \u2229 s = s", "decl_tp": "\u2200 {\u03b1 : Type u} {s t : set \u03b1}, (s \u222a t) \u2229 s = s", "decl_nm": "set.union_inter_cancel_left"}
{"formal_statement": "theorem eq_sqrt' {n q : \u2115} :\n\tq = nat.sqrt n \u2194 q ^ 2 \u2264 n \u2227 n < (q + 1) ^ 2", "decl_tp": "\u2200 {n q : \u2115}, q = nat.sqrt n \u2194 q ^ 2 \u2264 n \u2227 n < (q + 1) ^ 2", "decl_nm": "nat.eq_sqrt'"}
{"formal_statement": "theorem is_glb_Ioi {\u03b3 : Type w} [linear_order \u03b3] [densely_ordered \u03b3] {a : \u03b3} :\n\tis_glb (set.Ioi a) a", "decl_tp": "\u2200 {\u03b3 : Type w} [_inst_3 : linear_order \u03b3] [_inst_4 : densely_ordered \u03b3] {a : \u03b3}, is_glb (set.Ioi a) a", "decl_nm": "is_glb_Ioi"}
{"formal_statement": "theorem eventually_eq {X Y : Type*} [topological_space X] {f : X \u2192 Y} (hf : is_locally_constant f) :\n\t\u2200 (x : X), \u2200\u1da0 (y : X) in nhds x, f y = f x", "decl_tp": "\u2200 {X : Type u_1} {Y : Type u_2} [_inst_1 : topological_space X] {f : X \u2192 Y}, is_locally_constant f \u2192 \u2200 (x : X), \u2200\u1da0 (y : X) in nhds x, f y = f x", "decl_nm": "is_locally_constant.eventually_eq"}
{"formal_statement": "theorem ones_blocks_fun (n : \u2115) (i : fin (composition.ones n).length) :\n\t(composition.ones n).blocks_fun i = 1", "decl_tp": "\u2200 (n : \u2115) (i : fin (composition.ones n).length), (composition.ones n).blocks_fun i = 1", "decl_nm": "composition.ones_blocks_fun"}
{"formal_statement": "theorem neg_symm_apply (\u03b1 : Type u) [add_group \u03b1] [has_le \u03b1] [covariant_class \u03b1 \u03b1 has_add.add has_le.le]\n\t[covariant_class \u03b1 \u03b1 (function.swap has_add.add) has_le.le] (\u1fb0 : order_dual \u03b1) :\n\t\u21d1(rel_iso.symm (order_iso.neg \u03b1)) \u1fb0 = -\u21d1order_dual.of_dual \u1fb0", "decl_tp": "\u2200 (\u03b1 : Type u) [_inst_1 : add_group \u03b1] [_inst_2 : has_le \u03b1] [_inst_3 : covariant_class \u03b1 \u03b1 has_add.add has_le.le] [_inst_4 : covariant_class \u03b1 \u03b1 (function.swap has_add.add) has_le.le] (\u1fb0 : order_dual \u03b1), \u21d1(rel_iso.symm (order_iso.neg \u03b1)) \u1fb0 = -\u21d1order_dual.of_dual \u1fb0", "decl_nm": "order_iso.neg_symm_apply"}
{"formal_statement": "theorem one_to_real :\n\t1.to_real = 1", "decl_tp": "1.to_real = 1", "decl_nm": "ennreal.one_to_real"}
{"formal_statement": "theorem convex_independent {\ud835\udd5c E \u03b9 : Type*} [ordered_semiring \ud835\udd5c] [add_comm_group E]\n\t[module \ud835\udd5c E] [subsingleton \u03b9] (p : \u03b9 \u2192 E) :\n\tconvex_independent \ud835\udd5c p", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} {E : Type u_2} {\u03b9 : Type u_3} [_inst_1 : ordered_semiring \ud835\udd5c] [_inst_2 : add_comm_group E] [_inst_3 : module \ud835\udd5c E] [_inst_4 : subsingleton \u03b9] (p : \u03b9 \u2192 E), convex_independent \ud835\udd5c p", "decl_nm": "subsingleton.convex_independent"}
{"formal_statement": "theorem mul_empty {\u03b1 : Type u} {m' n' : Type*} [semiring \u03b1] [fintype n']\n\t(A : matrix m' n' \u03b1) (B : matrix n' (fin 0) \u03b1) :\n\tA.mul B = \u03bb (_x : m'), matrix.vec_empty", "decl_tp": "\u2200 {\u03b1 : Type u} {m' : Type u_1} {n' : Type u_2} [_inst_1 : semiring \u03b1] [_inst_2 : fintype n'] (A : matrix m' n' \u03b1) (B : matrix n' (fin 0) \u03b1), A.mul B = \u03bb (_x : m'), matrix.vec_empty", "decl_nm": "matrix.mul_empty"}
{"formal_statement": "theorem to_topological_space_inf {\u03b1 : Type u} [group \u03b1] (x y : group_topology \u03b1) :\n\t(x \u2293 y).to_topological_space = x.to_topological_space \u2293 y.to_topological_space", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : group \u03b1] (x y : group_topology \u03b1), (x \u2293 y).to_topological_space = x.to_topological_space \u2293 y.to_topological_space", "decl_nm": "group_topology.to_topological_space_inf"}
{"formal_statement": "theorem land_zero (n : \u2115) :\n\tn.land 0 = 0", "decl_tp": "\u2200 (n : \u2115), n.land 0 = 0", "decl_nm": "nat.land_zero"}
{"formal_statement": "theorem map_mul {M : Type*} [monoid M] {R : Type*1} [semiring R] [mul_semiring_action M R]\n\t{S : Type*3} [semiring S] [mul_semiring_action M S] (f : R \u2192+*[M] S) (x y : R) :\n\t\u21d1f (x * y) = \u21d1f x * \u21d1f y", "decl_tp": "\u2200 {M : Type u_5} [_inst_4 : monoid M] {R : Type u_11} [_inst_15 : semiring R] [_inst_16 : mul_semiring_action M R] {S : Type u_13} [_inst_19 : semiring S] [_inst_20 : mul_semiring_action M S] (f : R \u2192+*[M] S) (x y : R), \u21d1f (x * y) = \u21d1f x * \u21d1f y", "decl_nm": "mul_semiring_action_hom.map_mul"}
{"formal_statement": "theorem map_eq_some {\u03b1 \u03b2 : Type*} {x : option \u03b1} {f : \u03b1 \u2192 \u03b2} {b : \u03b2} :\n\tf <$> x = option.some b \u2194 \u2203 (a : \u03b1), x = option.some a \u2227 f a = b", "decl_tp": "\u2200 {\u03b1 \u03b2 : Type u_1} {x : option \u03b1} {f : \u03b1 \u2192 \u03b2} {b : \u03b2}, f <$> x = option.some b \u2194 \u2203 (a : \u03b1), x = option.some a \u2227 f a = b", "decl_nm": "option.map_eq_some"}
{"formal_statement": "theorem small_type :\n\tsmall (Type u)", "decl_tp": "small (Type u)", "decl_nm": "small_type"}
{"formal_statement": "theorem unop_injective {\u03b1 : Sort u} :\n\tfunction.injective opposite.unop", "decl_tp": "\u2200 {\u03b1 : Sort u}, function.injective opposite.unop", "decl_nm": "opposite.unop_injective"}
{"formal_statement": "theorem add_left_cancel' {n a b : \u2115} (c : \u2115) (h : c + a \u2261 c + b [MOD n]) :\n\ta \u2261 b [MOD n]", "decl_tp": "\u2200 {n a b : \u2115} (c : \u2115), c + a \u2261 c + b [MOD n] \u2192 a \u2261 b [MOD n]", "decl_nm": "nat.modeq.add_left_cancel'"}
{"formal_statement": "theorem rat_sub (q : \u211a) {x : \u211d} (h : irrational x) :\n\tirrational (\u2191q - x)", "decl_tp": "\u2200 (q : \u211a) {x : \u211d}, irrational x \u2192 irrational (\u2191q - x)", "decl_nm": "irrational.rat_sub"}
{"formal_statement": "theorem taylor_apply {R : Type*} [semiring R] (r : R) (f : polynomial R) :\n\t\u21d1(polynomial.taylor r) f = f.comp (polynomial.X + \u21d1polynomial.C r)", "decl_tp": "\u2200 {R : Type u_1} [_inst_1 : semiring R] (r : R) (f : polynomial R), \u21d1(polynomial.taylor r) f = f.comp (polynomial.X + \u21d1polynomial.C r)", "decl_nm": "polynomial.taylor_apply"}
{"formal_statement": "theorem superpolynomial_decay_mul_param_iff {\u03b1 \u03b2 : Type*} {l : filter \u03b1}\n\t{k : \u03b1 \u2192 \u03b2} (f : \u03b1 \u2192 \u03b2) [topological_space \u03b2] [linear_ordered_field \u03b2]\n\t[order_topology \u03b2] (hk : filter.tendsto k l filter.at_top) :\n\t(asymptotics.superpolynomial_decay l k (f * k) \u2194 asymptotics.superpolynomial_decay l k f)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {l : filter \u03b1} {k : \u03b1 \u2192 \u03b2} (f : \u03b1 \u2192 \u03b2) [_inst_1 : topological_space \u03b2] [_inst_2 : linear_ordered_field \u03b2] [_inst_3 : order_topology \u03b2], filter.tendsto k l filter.at_top \u2192 (asymptotics.superpolynomial_decay l k (f * k) \u2194 asymptotics.superpolynomial_decay l k f)", "decl_nm": "asymptotics.superpolynomial_decay_mul_param_iff"}
{"formal_statement": "theorem eq_of_bot_eq_bot_of_top_eq_top_of_length_eq_zero {X : Type u} [lattice X]\n\t[jordan_holder_lattice X] {s\u2081 s\u2082 : composition_series X} (hb : s\u2081.bot = s\u2082.bot)\n\t(ht : s\u2081.top = s\u2082.top) (hs\u20810 : s\u2081.length = 0) :\n\ts\u2081 = s\u2082", "decl_tp": "\u2200 {X : Type u} [_inst_1 : lattice X] [_inst_2 : jordan_holder_lattice X] {s\u2081 s\u2082 : composition_series X}, s\u2081.bot = s\u2082.bot \u2192 s\u2081.top = s\u2082.top \u2192 s\u2081.length = 0 \u2192 s\u2081 = s\u2082", "decl_nm": "composition_series.eq_of_bot_eq_bot_of_top_eq_top_of_length_eq_zero"}
{"formal_statement": "theorem sum_mono {\u03b9 M : Type*} [fintype \u03b9] [ordered_add_comm_monoid M] :\n\tmonotone (\u03bb (f : \u03b9 \u2192 M), finset.univ.sum (\u03bb (i : \u03b9), f i))", "decl_tp": "\u2200 {\u03b9 : Type u_1} {M : Type u_4} [_inst_1 : fintype \u03b9] [_inst_2 : ordered_add_comm_monoid M], monotone (\u03bb (f : \u03b9 \u2192 M), finset.univ.sum (\u03bb (i : \u03b9), f i))", "decl_nm": "fintype.sum_mono"}
{"formal_statement": "theorem op_op_equivalence_functor (C : Type u\u2081) [category_theory.category C] :\n\t(category_theory.op_op_equivalence C).functor = category_theory.op_op C", "decl_tp": "\u2200 (C : Type u\u2081) [_inst_1 : category_theory.category C], (category_theory.op_op_equivalence C).functor = category_theory.op_op C", "decl_nm": "category_theory.op_op_equivalence_functor"}
{"formal_statement": "theorem measurable_set_generate_from {\u03b1 : Type*} {s : set (set \u03b1)} {t : set \u03b1}\n\t(ht : t \u2208 s) :\n\t(measurable_space.generate_from s).measurable_set' t", "decl_tp": "\u2200 {\u03b1 : Type u_1} {s : set (set \u03b1)} {t : set \u03b1}, t \u2208 s \u2192 (measurable_space.generate_from s).measurable_set' t", "decl_nm": "measurable_space.measurable_set_generate_from"}
{"formal_statement": "theorem all_node' {\u03b1 : Type*} {P : \u03b1 \u2192 Prop} {l : ordnode \u03b1} {x : \u03b1} {r : ordnode \u03b1} :\n\tordnode.all P (l.node' x r) \u2194 ordnode.all P l \u2227 P x \u2227 ordnode.all P r", "decl_tp": "\u2200 {\u03b1 : Type u_1} {P : \u03b1 \u2192 Prop} {l : ordnode \u03b1} {x : \u03b1} {r : ordnode \u03b1}, ordnode.all P (l.node' x r) \u2194 ordnode.all P l \u2227 P x \u2227 ordnode.all P r", "decl_nm": "ordnode.all_node'"}
{"formal_statement": "theorem comp_diag {C : Type u} [category_theory.category C] {X Y : C} [category_theory.limits.has_binary_product Y Y]\n\t(f : X \u27f6 Y) :\n\tf \u226b category_theory.limits.diag Y = category_theory.limits.prod.lift f f", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] {X Y : C} [_inst_2 : category_theory.limits.has_binary_product Y Y] (f : X \u27f6 Y), f \u226b category_theory.limits.diag Y = category_theory.limits.prod.lift f f", "decl_nm": "category_theory.limits.prod.comp_diag"}
{"formal_statement": "theorem fin_curry\u2081 {\u03b1 \u03c3 : Type*} [primcodable \u03b1] [primcodable \u03c3] {n : \u2115}\n\t{f : fin n \u2192 \u03b1 \u2192 \u03c3} :\n\tprimrec\u2082 f \u2194 \u2200 (i : fin n), primrec (f i)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03c3 : Type u_4} [_inst_1 : primcodable \u03b1] [_inst_4 : primcodable \u03c3] {n : \u2115} {f : fin n \u2192 \u03b1 \u2192 \u03c3}, primrec\u2082 f \u2194 \u2200 (i : fin n), primrec (f i)", "decl_nm": "primrec.fin_curry\u2081"}
{"formal_statement": "theorem zero_add (x : game) :\n\t0 + x = x", "decl_tp": "\u2200 (x : game), 0 + x = x", "decl_nm": "game.zero_add"}
{"formal_statement": "theorem dual {\u03b9 \u03b1 \u03b2 : Type*} [preorder \u03b1] [preorder \u03b2] {f : \u03b9 \u2192 \u03b1} {g : \u03b9 \u2192 \u03b2}\n\t(h : monovary f g) :\n\tmonovary (\u21d1order_dual.to_dual \u2218 f) (\u21d1order_dual.to_dual \u2218 g)", "decl_tp": "\u2200 {\u03b9 : Type u_1} {\u03b1 : Type u_3} {\u03b2 : Type u_4} [_inst_1 : preorder \u03b1] [_inst_2 : preorder \u03b2] {f : \u03b9 \u2192 \u03b1} {g : \u03b9 \u2192 \u03b2}, monovary f g \u2192 monovary (\u21d1order_dual.to_dual \u2218 f) (\u21d1order_dual.to_dual \u2218 g)", "decl_nm": "monovary.dual"}
{"formal_statement": "theorem mul_lt_mul_iff_right {\u03b1 : Type*} [has_mul \u03b1] [has_lt \u03b1] [covariant_class \u03b1 \u03b1 (function.swap has_mul.mul) has_lt.lt]\n\t[contravariant_class \u03b1 \u03b1 (function.swap has_mul.mul) has_lt.lt] (a : \u03b1)\n\t{b c : \u03b1} :\n\tb * a < c * a \u2194 b < c", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : has_mul \u03b1] [_inst_2 : has_lt \u03b1] [_inst_3 : covariant_class \u03b1 \u03b1 (function.swap has_mul.mul) has_lt.lt] [_inst_4 : contravariant_class \u03b1 \u03b1 (function.swap has_mul.mul) has_lt.lt] (a : \u03b1) {b c : \u03b1}, b * a < c * a \u2194 b < c", "decl_nm": "mul_lt_mul_iff_right"}
{"formal_statement": "theorem abs_eq_max_neg {\u03b1 : Type u} [has_neg \u03b1] [linear_order \u03b1] {a : \u03b1} :\n\t|a| = linear_order.max a (-a)", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : has_neg \u03b1] [_inst_2 : linear_order \u03b1] {a : \u03b1}, |a| = linear_order.max a (-a)", "decl_nm": "abs_eq_max_neg"}
{"formal_statement": "theorem is_least_Icc {\u03b1 : Type u} [preorder \u03b1] {a b : \u03b1} (h : a \u2264 b) :\n\tis_least (set.Icc a b) a", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : preorder \u03b1] {a b : \u03b1}, a \u2264 b \u2192 is_least (set.Icc a b) a", "decl_nm": "is_least_Icc"}
{"formal_statement": "theorem is_image_source_target {\u03b1 \u03b2 : Type*} [topological_space \u03b1] [topological_space \u03b2]\n\t(e : local_homeomorph \u03b1 \u03b2) :\n\te.is_image e.to_local_equiv.source e.to_local_equiv.target", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : topological_space \u03b1] [_inst_2 : topological_space \u03b2] (e : local_homeomorph \u03b1 \u03b2), e.is_image e.to_local_equiv.source e.to_local_equiv.target", "decl_nm": "local_homeomorph.is_image_source_target"}
{"formal_statement": "theorem comp {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} [pseudo_emetric_space \u03b1]\n\t[pseudo_emetric_space \u03b2] [pseudo_emetric_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n\t(hg : isometry g) (hf : isometry f) :\n\tisometry (g \u2218 f)", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} [_inst_1 : pseudo_emetric_space \u03b1] [_inst_2 : pseudo_emetric_space \u03b2] [_inst_3 : pseudo_emetric_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}, isometry g \u2192 isometry f \u2192 isometry (g \u2218 f)", "decl_nm": "isometry.comp"}
{"formal_statement": "theorem over_to_coalgebra_obj_a {C : Type u} [category_theory.category C]\n\t(X : C) [category_theory.limits.has_binary_products C] (f : category_theory.over X) :\n\t((category_theory.over_to_coalgebra X).obj f).a = category_theory.limits.prod.lift f.hom (\ud835\udfd9 f.left)", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] (X : C) [_inst_2 : category_theory.limits.has_binary_products C] (f : category_theory.over X), ((category_theory.over_to_coalgebra X).obj f).a = category_theory.limits.prod.lift f.hom (\ud835\udfd9 f.left)", "decl_nm": "category_theory.over_to_coalgebra_obj_a"}
{"formal_statement": "theorem digits_add_two_add_one (b n : \u2115) :\n\t(b + 2).digits (n + 1) = (n + 1) % (b + 2) :: (b + 2).digits ((n + 1) / (b + 2))", "decl_tp": "\u2200 (b n : \u2115), (b + 2).digits (n + 1) = (n + 1) % (b + 2) :: (b + 2).digits ((n + 1) / (b + 2))", "decl_nm": "nat.digits_add_two_add_one"}
{"formal_statement": "theorem uniform_continuous_const {\u03b1 \u03b2 : Type*} [uniform_space \u03b1] [uniform_space \u03b2]\n\t{b : \u03b2} :\n\tuniform_continuous (\u03bb (a : \u03b1), b)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : uniform_space \u03b1] [_inst_2 : uniform_space \u03b2] {b : \u03b2}, uniform_continuous (\u03bb (a : \u03b1), b)", "decl_nm": "uniform_continuous_const"}
{"formal_statement": "theorem finite_mul_iff {\u03b1 : Type*} [cancel_comm_monoid_with_zero \u03b1] {p a b : \u03b1}\n\t(hp : prime p) :\n\t(multiplicity.finite p (a * b) \u2194 multiplicity.finite p a \u2227 multiplicity.finite p b)", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : cancel_comm_monoid_with_zero \u03b1] {p a b : \u03b1}, prime p \u2192 (multiplicity.finite p (a * b) \u2194 multiplicity.finite p a \u2227 multiplicity.finite p b)", "decl_nm": "multiplicity.finite_mul_iff"}
{"formal_statement": "theorem ball_eq_ball' {\u03b1 : Type u} [pseudo_metric_space \u03b1] (\u03b5 : \u211d) (x : \u03b1) :\n\tuniform_space.ball x {p : \u03b1 \u00d7 \u03b1 | has_dist.dist p.fst p.snd < \u03b5} = metric.ball x \u03b5", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : pseudo_metric_space \u03b1] (\u03b5 : \u211d) (x : \u03b1), uniform_space.ball x {p : \u03b1 \u00d7 \u03b1 | has_dist.dist p.fst p.snd < \u03b5} = metric.ball x \u03b5", "decl_nm": "metric.ball_eq_ball'"}
{"formal_statement": "theorem bot_eq_zero {\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} [\u03a0 (i : \u03b9), canonically_ordered_add_monoid (\u03b1 i)] :\n\t\u22a5 = 0", "decl_tp": "\u2200 {\u03b9 : Type u_1} {\u03b1 : \u03b9 \u2192 Type u_2} [_inst_1 : \u03a0 (i : \u03b9), canonically_ordered_add_monoid (\u03b1 i)], \u22a5 = 0", "decl_nm": "dfinsupp.bot_eq_zero"}
{"formal_statement": "theorem inf {\u03b1 : Type u} {\u03b2 : Type v} [semilattice_inf \u03b2] {f g : \u03b1 \u2192 \u03b2}\n\t{a : \u03b1} {s : set \u03b1} (hf : is_min_on f s a) (hg : is_min_on g s a) :\n\tis_min_on (\u03bb (x : \u03b1), f x \u2293 g x) s a", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : semilattice_inf \u03b2] {f g : \u03b1 \u2192 \u03b2} {a : \u03b1} {s : set \u03b1}, is_min_on f s a \u2192 is_min_on g s a \u2192 is_min_on (\u03bb (x : \u03b1), f x \u2293 g x) s a", "decl_nm": "is_min_on.inf"}
{"formal_statement": "theorem attach_zero {\u03b1 : Type*} :\n\t0.attach = 0", "decl_tp": "\u2200 {\u03b1 : Type u_1}, 0.attach = 0", "decl_nm": "multiset.attach_zero"}
{"formal_statement": "theorem card_eq {\u03b1 \u03b2 : Type*} [F : fintype \u03b1] [G : fintype \u03b2] :\n\tfintype.card \u03b1 = fintype.card \u03b2 \u2194 nonempty (\u03b1 \u2243 \u03b2)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [F : fintype \u03b1] [G : fintype \u03b2], fintype.card \u03b1 = fintype.card \u03b2 \u2194 nonempty (\u03b1 \u2243 \u03b2)", "decl_nm": "fintype.card_eq"}
{"formal_statement": "theorem mono {\u03b1 \u03b2 \u03b3 : Type*} {m : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1}\n\t[normed_group \u03b2] [normed_group \u03b3] {f : \u03b1 \u2192 \u03b2} {g : \u03b1 \u2192 \u03b3} (hg : measure_theory.has_finite_integral g \u03bc) :\n\t(\u2200\u1d50 (a : \u03b1) \u2202\u03bc, \u2225f a\u2225 \u2264 \u2225g a\u2225) \u2192 measure_theory.has_finite_integral f \u03bc", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {\u03b3 : Type u_3} {m : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} [_inst_1 : normed_group \u03b2] [_inst_2 : normed_group \u03b3] {f : \u03b1 \u2192 \u03b2} {g : \u03b1 \u2192 \u03b3}, measure_theory.has_finite_integral g \u03bc \u2192 (\u2200\u1d50 (a : \u03b1) \u2202\u03bc, \u2225f a\u2225 \u2264 \u2225g a\u2225) \u2192 measure_theory.has_finite_integral f \u03bc", "decl_nm": "measure_theory.has_finite_integral.mono"}
{"formal_statement": "theorem obj_mem_ess_image {C : Type u\u2081} {D : Type u\u2082} [category_theory.category C]\n\t[category_theory.category D] (F : D \u2964 C) (Y : D) :\n\tF.obj Y \u2208 F.ess_image", "decl_tp": "\u2200 {C : Type u\u2081} {D : Type u\u2082} [_inst_1 : category_theory.category C] [_inst_2 : category_theory.category D] (F : D \u2964 C) (Y : D), F.obj Y \u2208 F.ess_image", "decl_nm": "category_theory.functor.obj_mem_ess_image"}
{"formal_statement": "theorem sum_mem_bsupr {R M : Type*} [semiring R] [add_comm_monoid M] [module R M]\n\t{\u03b9 : Type*} {s : finset \u03b9} {f : \u03b9 \u2192 M} {p : \u03b9 \u2192 submodule R M} :\n\t(\u2200 (i : \u03b9), i \u2208 s \u2192 f i \u2208 p i) \u2192 (s.sum (\u03bb (i : \u03b9), f i) \u2208 \u2a06 (i : \u03b9) (H : i \u2208 s), p i)", "decl_tp": "\u2200 {R : Type u_1} {M : Type u_3} [_inst_1 : semiring R] [_inst_3 : add_comm_monoid M] [_inst_4 : module R M] {\u03b9 : Type u_2} {s : finset \u03b9} {f : \u03b9 \u2192 M} {p : \u03b9 \u2192 submodule R M}, (\u2200 (i : \u03b9), i \u2208 s \u2192 f i \u2208 p i) \u2192 (s.sum (\u03bb (i : \u03b9), f i) \u2208 \u2a06 (i : \u03b9) (H : i \u2208 s), p i)", "decl_nm": "submodule.sum_mem_bsupr"}
{"formal_statement": "theorem smul_orbit_subset {\u03b1 : Type u} {\u03b2 : Type v} [monoid \u03b1] [mul_action \u03b1 \u03b2]\n\t(a : \u03b1) (b : \u03b2) :\n\ta \u2022 mul_action.orbit \u03b1 b \u2286 mul_action.orbit \u03b1 b", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : monoid \u03b1] [_inst_2 : mul_action \u03b1 \u03b2] (a : \u03b1) (b : \u03b2), a \u2022 mul_action.orbit \u03b1 b \u2286 mul_action.orbit \u03b1 b", "decl_nm": "mul_action.smul_orbit_subset"}
{"formal_statement": "theorem find_insert_of_ne {\u03b1 : Type u} {\u03b2 : Type v} {lt : \u03b1 \u2192 \u03b1 \u2192 Prop}\n\t[decidable_rel lt] [is_strict_total_order \u03b1 lt] {k\u2081 k\u2082 : \u03b1} (m : rbmap \u03b1 \u03b2 lt)\n\t(v : \u03b2) (h : k\u2081 \u2260 k\u2082) :\n\t(m.insert k\u2081 v).find k\u2082 = m.find k\u2082", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {lt : \u03b1 \u2192 \u03b1 \u2192 Prop} [_inst_1 : decidable_rel lt] [_inst_2 : is_strict_total_order \u03b1 lt] {k\u2081 k\u2082 : \u03b1} (m : rbmap \u03b1 \u03b2 lt) (v : \u03b2), k\u2081 \u2260 k\u2082 \u2192 (m.insert k\u2081 v).find k\u2082 = m.find k\u2082", "decl_nm": "rbmap.find_insert_of_ne"}
{"formal_statement": "theorem mul_assoc {l m n o : Type*} {\u03b1 : Type v} [non_unital_semiring \u03b1]\n\t[fintype m] [fintype n] (L : matrix l m \u03b1) (M : matrix m n \u03b1) (N : matrix n o \u03b1) :\n\t(L.mul M).mul N = L.mul (M.mul N)", "decl_tp": "\u2200 {l : Type u_1} {m : Type u_2} {n : Type u_3} {o : Type u_4} {\u03b1 : Type v} [_inst_1 : non_unital_semiring \u03b1] [_inst_2 : fintype m] [_inst_3 : fintype n] (L : matrix l m \u03b1) (M : matrix m n \u03b1) (N : matrix n o \u03b1), (L.mul M).mul N = L.mul (M.mul N)", "decl_nm": "matrix.mul_assoc"}
{"formal_statement": "theorem values_discrete (p : \u2115) {q : \u211a} (hq : q \u2260 0) :\n\t(\u2203 (z : \u2124), padic_norm p q = \u2191p ^ -z)", "decl_tp": "\u2200 (p : \u2115) {q : \u211a}, q \u2260 0 \u2192 (\u2203 (z : \u2124), padic_norm p q = \u2191p ^ -z)", "decl_nm": "padic_norm.values_discrete"}
{"formal_statement": "theorem epsilon_eq_inv_omega :\n\thyperreal.epsilon = hyperreal.omega\u207b\u00b9", "decl_tp": "hyperreal.epsilon = hyperreal.omega\u207b\u00b9", "decl_nm": "hyperreal.epsilon_eq_inv_omega"}
{"formal_statement": "theorem comp_linear_map_apply {R : Type u} {\u03b9 : Type u'} {M\u2081 : \u03b9 \u2192 Type v\u2081}\n\t{M\u2082 : Type v\u2082} [decidable_eq \u03b9] [semiring R] [\u03a0 (i : \u03b9), add_comm_monoid (M\u2081 i)]\n\t[add_comm_monoid M\u2082] [\u03a0 (i : \u03b9), module R (M\u2081 i)] [module R M\u2082] {M\u2081' : \u03b9 \u2192 Type*}\n\t[\u03a0 (i : \u03b9), add_comm_monoid (M\u2081' i)] [\u03a0 (i : \u03b9), module R (M\u2081' i)] (g : multilinear_map R M\u2081' M\u2082)\n\t(f : \u03a0 (i : \u03b9), M\u2081 i \u2192\u2097[R] M\u2081' i) (m : \u03a0 (i : \u03b9), M\u2081 i) :\n\t\u21d1(g.comp_linear_map f) m = \u21d1g (\u03bb (i : \u03b9), \u21d1(f i) (m i))", "decl_tp": "\u2200 {R : Type u} {\u03b9 : Type u'} {M\u2081 : \u03b9 \u2192 Type v\u2081} {M\u2082 : Type v\u2082} [_inst_1 : decidable_eq \u03b9] [_inst_2 : semiring R] [_inst_4 : \u03a0 (i : \u03b9), add_comm_monoid (M\u2081 i)] [_inst_5 : add_comm_monoid M\u2082] [_inst_9 : \u03a0 (i : \u03b9), module R (M\u2081 i)] [_inst_10 : module R M\u2082] {M\u2081' : \u03b9 \u2192 Type u_1} [_inst_13 : \u03a0 (i : \u03b9), add_comm_monoid (M\u2081' i)] [_inst_14 : \u03a0 (i : \u03b9), module R (M\u2081' i)] (g : multilinear_map R M\u2081' M\u2082) (f : \u03a0 (i : \u03b9), M\u2081 i \u2192\u2097[R] M\u2081' i) (m : \u03a0 (i : \u03b9), M\u2081 i), \u21d1(g.comp_linear_map f) m = \u21d1g (\u03bb (i : \u03b9), \u21d1(f i) (m i))", "decl_nm": "multilinear_map.comp_linear_map_apply"}
{"formal_statement": "theorem mul_indicator_apply_le' {\u03b1 M : Type*} [has_one M] [preorder M]\n\t{s : set \u03b1} {f : \u03b1 \u2192 M} {a : \u03b1} {y : M} :\n\t(a \u2208 s \u2192 f a \u2264 y) \u2192 (a \u2209 s \u2192 1 \u2264 y) \u2192 s.mul_indicator f a \u2264 y", "decl_tp": "\u2200 {\u03b1 : Type u_1} {M : Type u_4} [_inst_1 : has_one M] [_inst_2 : preorder M] {s : set \u03b1} {f : \u03b1 \u2192 M} {a : \u03b1} {y : M}, (a \u2208 s \u2192 f a \u2264 y) \u2192 (a \u2209 s \u2192 1 \u2264 y) \u2192 s.mul_indicator f a \u2264 y", "decl_nm": "set.mul_indicator_apply_le'"}
{"formal_statement": "theorem union_eq_Union {\u03b1 : Type*} {s\u2081 s\u2082 : set \u03b1} :\n\ts\u2081 \u222a s\u2082 = \u22c3 (b : bool), cond b s\u2081 s\u2082", "decl_tp": "\u2200 {\u03b1 : Type u_1} {s\u2081 s\u2082 : set \u03b1}, s\u2081 \u222a s\u2082 = \u22c3 (b : bool), cond b s\u2081 s\u2082", "decl_nm": "set.union_eq_Union"}
{"formal_statement": "theorem const_comp_tendsto {\u03b1 \u03b2 \u03b3 : Type*} {l : filter \u03b1} (b : \u03b2) {lc : filter \u03b3}\n\t{g : \u03b3 \u2192 \u03b1} (hg : filter.tendsto g lc l) :\n\t\u2191b.comp_tendsto g hg = \u2191b", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {\u03b3 : Type u_3} {l : filter \u03b1} (b : \u03b2) {lc : filter \u03b3} {g : \u03b3 \u2192 \u03b1} (hg : filter.tendsto g lc l), \u2191b.comp_tendsto g hg = \u2191b", "decl_nm": "filter.germ.const_comp_tendsto"}
{"formal_statement": "theorem restrict_apply {R M : Type*} [semiring R] [add_comm_monoid M] [module R M]\n\t{f : M \u2192\u2097[R] M} {p : submodule R M} (hf : \u2200 (x : M), x \u2208 p \u2192 \u21d1f x \u2208 p)\n\t(x : \u21a5p) :\n\t\u21d1(f.restrict hf) x = \u27e8\u21d1f \u2191x, _\u27e9", "decl_tp": "\u2200 {R : Type u_1} {M : Type u_9} [_inst_1 : semiring R] [_inst_5 : add_comm_monoid M] [_inst_10 : module R M] {f : M \u2192\u2097[R] M} {p : submodule R M} (hf : \u2200 (x : M), x \u2208 p \u2192 \u21d1f x \u2208 p) (x : \u21a5p), \u21d1(f.restrict hf) x = \u27e8\u21d1f \u2191x, _\u27e9", "decl_nm": "linear_map.restrict_apply"}
{"formal_statement": "theorem yoneda_sections_small_hom {C : Type u\u2081} [category_theory.small_category C]\n\t(X : C) (F : C\u1d52\u1d56 \u2964 Type u\u2081) (f : category_theory.yoneda.obj X \u27f6 F) :\n\t(category_theory.yoneda_sections_small X F).hom f = f.app (opposite.op X)\n\t(\ud835\udfd9 (opposite.unop (opposite.op X)))", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_2 : category_theory.small_category C] (X : C) (F : C\u1d52\u1d56 \u2964 Type u\u2081) (f : category_theory.yoneda.obj X \u27f6 F), (category_theory.yoneda_sections_small X F).hom f = f.app (opposite.op X) (\ud835\udfd9 (opposite.unop (opposite.op X)))", "decl_nm": "category_theory.yoneda_sections_small_hom"}
{"formal_statement": "theorem all {S : Type*} [comm_semigroup S] (a b : S) :\n\tcommute a b", "decl_tp": "\u2200 {S : Type u_1} [_inst_1 : comm_semigroup S] (a b : S), commute a b", "decl_nm": "commute.all"}
{"formal_statement": "theorem sub_mem_Icc_iff_left {\u03b1 : Type*} [ordered_add_comm_group \u03b1] {a b c d : \u03b1} :\n\ta - b \u2208 set.Icc c d \u2194 a \u2208 set.Icc (c + b) (d + b)", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : ordered_add_comm_group \u03b1] {a b c d : \u03b1}, a - b \u2208 set.Icc c d \u2194 a \u2208 set.Icc (c + b) (d + b)", "decl_nm": "set.sub_mem_Icc_iff_left"}
{"formal_statement": "theorem arg_local_equiv_source :\n\tcircle.arg_local_equiv.source = set.univ", "decl_tp": "circle.arg_local_equiv.source = set.univ", "decl_nm": "circle.arg_local_equiv_source"}
{"formal_statement": "theorem Icc_coe_top (\u03b1 : Type*) [partial_order \u03b1] [order_top \u03b1] [locally_finite_order \u03b1]\n\t(a : \u03b1) :\n\tfinset.Icc \u2191a \u22a4 = \u21d1finset.insert_none (finset.Ici a)", "decl_tp": "\u2200 (\u03b1 : Type u_1) [_inst_1 : partial_order \u03b1] [_inst_2 : order_top \u03b1] [_inst_3 : locally_finite_order \u03b1] (a : \u03b1), finset.Icc \u2191a \u22a4 = \u21d1finset.insert_none (finset.Ici a)", "decl_nm": "with_top.Icc_coe_top"}
{"formal_statement": "theorem factor_dvd_of_degree_ne_zero {K : Type v} [field K] {f : polynomial K}\n\t(hf : f.degree \u2260 0) :\n\tf.factor \u2223 f", "decl_tp": "\u2200 {K : Type v} [_inst_1 : field K] {f : polynomial K}, f.degree \u2260 0 \u2192 f.factor \u2223 f", "decl_nm": "polynomial.factor_dvd_of_degree_ne_zero"}
{"formal_statement": "theorem tendsto_inv_at_top_zero' {\u03b1 : Type u} [linear_ordered_field \u03b1]\n\t[topological_space \u03b1] [order_topology \u03b1] :\n\tfilter.tendsto (\u03bb (r : \u03b1), r\u207b\u00b9) filter.at_top (nhds_within 0 (set.Ioi 0))", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : linear_ordered_field \u03b1] [_inst_2 : topological_space \u03b1] [_inst_3 : order_topology \u03b1], filter.tendsto (\u03bb (r : \u03b1), r\u207b\u00b9) filter.at_top (nhds_within 0 (set.Ioi 0))", "decl_nm": "tendsto_inv_at_top_zero'"}
{"formal_statement": "theorem coimage_strong_epi_mono_factorisation_to_mono_factorisation_e {C : Type u}\n\t[category_theory.category C] [category_theory.abelian C] {P Q : C} (f : P \u27f6 Q) :\n\t(category_theory.abelian.coimages.coimage_strong_epi_mono_factorisation f).to_mono_factorisation.e = category_theory.abelian.coimages.coimage.\u03c0 f", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] [_inst_2 : category_theory.abelian C] {P Q : C} (f : P \u27f6 Q), (category_theory.abelian.coimages.coimage_strong_epi_mono_factorisation f).to_mono_factorisation.e = category_theory.abelian.coimages.coimage.\u03c0 f", "decl_nm": "category_theory.abelian.coimages.coimage_strong_epi_mono_factorisation_to_mono_factorisation_e"}
{"formal_statement": "theorem Icc_ssubset_Icc_right {\u03b1 : Type u} [preorder \u03b1] {a\u2081 a\u2082 b\u2081 b\u2082 : \u03b1}\n\t(hI : a\u2082 \u2264 b\u2082) (ha : a\u2082 \u2264 a\u2081) (hb : b\u2081 < b\u2082) :\n\tset.Icc a\u2081 b\u2081 \u2282 set.Icc a\u2082 b\u2082", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : preorder \u03b1] {a\u2081 a\u2082 b\u2081 b\u2082 : \u03b1}, a\u2082 \u2264 b\u2082 \u2192 a\u2082 \u2264 a\u2081 \u2192 b\u2081 < b\u2082 \u2192 set.Icc a\u2081 b\u2081 \u2282 set.Icc a\u2082 b\u2082", "decl_nm": "set.Icc_ssubset_Icc_right"}
{"formal_statement": "theorem coe_coe {B F Z : Type*} [topological_space B] [topological_space F]\n\t{proj : Z \u2192 B} (e : topological_fiber_bundle.pretrivialization F proj) :\n\t\u21d1(e.to_local_equiv) = \u21d1e", "decl_tp": "\u2200 {B : Type u_2} {F : Type u_3} {Z : Type u_4} [_inst_1 : topological_space B] [_inst_2 : topological_space F] {proj : Z \u2192 B} (e : topological_fiber_bundle.pretrivialization F proj), \u21d1(e.to_local_equiv) = \u21d1e", "decl_nm": "topological_fiber_bundle.pretrivialization.coe_coe"}
{"formal_statement": "theorem times_cont_mdiff_at_fst {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c]\n\t{E : Type*} [normed_group E] [normed_space \ud835\udd5c E] {H : Type*} [topological_space H]\n\t{I : model_with_corners \ud835\udd5c E H} {M : Type*} [topological_space M] [charted_space H M]\n\t{F : Type*} [normed_group F] [normed_space \ud835\udd5c F] {G : Type*} [topological_space G]\n\t{J : model_with_corners \ud835\udd5c F G} {N : Type*0} [topological_space N] [charted_space G N]\n\t{n : with_top \u2115} {p : M \u00d7 N} :\n\ttimes_cont_mdiff_at (I.prod J) I n prod.fst p", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {H : Type u_3} [_inst_4 : topological_space H] {I : model_with_corners \ud835\udd5c E H} {M : Type u_4} [_inst_5 : topological_space M] [_inst_6 : charted_space H M] {F : Type u_8} [_inst_12 : normed_group F] [_inst_13 : normed_space \ud835\udd5c F] {G : Type u_9} [_inst_14 : topological_space G] {J : model_with_corners \ud835\udd5c F G} {N : Type u_10} [_inst_15 : topological_space N] [_inst_16 : charted_space G N] {n : with_top \u2115} {p : M \u00d7 N}, times_cont_mdiff_at (I.prod J) I n prod.fst p", "decl_nm": "times_cont_mdiff_at_fst"}
{"formal_statement": "theorem proj_Icc_surjective {\u03b1 : Type*} [linear_order \u03b1] {a b : \u03b1} (h : a \u2264 b) :\n\tfunction.surjective (set.proj_Icc a b h)", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : linear_order \u03b1] {a b : \u03b1} (h : a \u2264 b), function.surjective (set.proj_Icc a b h)", "decl_nm": "set.proj_Icc_surjective"}
{"formal_statement": "theorem equiv_of_fully_faithful_symm_apply {C : Type u\u2081} [category_theory.category C]\n\t{D : Type u\u2082} [category_theory.category D] (F : C \u2964 D) [category_theory.full F]\n\t[category_theory.faithful F] {X Y : C} (f : F.obj X \u27f6 F.obj Y) :\n\t\u21d1((category_theory.equiv_of_fully_faithful F).symm) f = F.preimage f", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {D : Type u\u2082} [_inst_2 : category_theory.category D] (F : C \u2964 D) [_inst_3 : category_theory.full F] [_inst_4 : category_theory.faithful F] {X Y : C} (f : F.obj X \u27f6 F.obj Y), \u21d1((category_theory.equiv_of_fully_faithful F).symm) f = F.preimage f", "decl_nm": "category_theory.equiv_of_fully_faithful_symm_apply"}
{"formal_statement": "theorem symm_apply_apply {M N : Type*} [has_mul M] [has_mul N] (e : M \u2243* N)\n\t(x : M) :\n\t\u21d1(e.symm) (\u21d1e x) = x", "decl_tp": "\u2200 {M : Type u_3} {N : Type u_4} [_inst_1 : has_mul M] [_inst_2 : has_mul N] (e : M \u2243* N) (x : M), \u21d1(e.symm) (\u21d1e x) = x", "decl_nm": "mul_equiv.symm_apply_apply"}
{"formal_statement": "theorem mk_surjective {R : Type u} [comm_ring R] {g : polynomial R} [nontrivial R]\n\t(hg : g.monic) :\n\tfunction.surjective \u21d1(adjoin_root.mk g)", "decl_tp": "\u2200 {R : Type u} [_inst_1 : comm_ring R] {g : polynomial R} [_inst_2 : nontrivial R], g.monic \u2192 function.surjective \u21d1(adjoin_root.mk g)", "decl_nm": "adjoin_root.mk_surjective"}
{"formal_statement": "theorem le_sup {\u03b1 : Type*} [semilattice_sup \u03b1] [order_bot \u03b1] {s : multiset \u03b1}\n\t{a : \u03b1} (h : a \u2208 s) :\n\ta \u2264 s.sup", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : semilattice_sup \u03b1] [_inst_2 : order_bot \u03b1] {s : multiset \u03b1} {a : \u03b1}, a \u2208 s \u2192 a \u2264 s.sup", "decl_nm": "multiset.le_sup"}
{"formal_statement": "theorem coe_map {M N : Type*} [add_zero_class M] [add_zero_class N] (f : M \u2192+ N)\n\t(S : add_submonoid M) :\n\t\u2191(add_submonoid.map f S) = \u21d1f '' \u2191S", "decl_tp": "\u2200 {M : Type u_1} {N : Type u_2} [_inst_1 : add_zero_class M] [_inst_2 : add_zero_class N] (f : M \u2192+ N) (S : add_submonoid M), \u2191(add_submonoid.map f S) = \u21d1f '' \u2191S", "decl_nm": "add_submonoid.coe_map"}
{"formal_statement": "theorem of_add_equiv_of_localizations_eq {M : Type*} [add_comm_monoid M]\n\t{S : add_submonoid M} {N : Type*} [add_comm_monoid N] {P : Type*} [add_comm_monoid P]\n\t(f : S.localization_map N) {k : N \u2243+ P} :\n\t(f.of_add_equiv_of_localizations k).to_map = k.to_add_monoid_hom.comp f.to_map", "decl_tp": "\u2200 {M : Type u_1} [_inst_1 : add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [_inst_2 : add_comm_monoid N] {P : Type u_3} [_inst_3 : add_comm_monoid P] (f : S.localization_map N) {k : N \u2243+ P}, (f.of_add_equiv_of_localizations k).to_map = k.to_add_monoid_hom.comp f.to_map", "decl_nm": "add_submonoid.localization_map.of_add_equiv_of_localizations_eq"}
{"formal_statement": "theorem coe_mul_left {R : Type*} [non_unital_non_assoc_semiring R] (r : R) :\n\t\u21d1(add_monoid_hom.mul_left r) = has_mul.mul r", "decl_tp": "\u2200 {R : Type u_1} [_inst_1 : non_unital_non_assoc_semiring R] (r : R), \u21d1(add_monoid_hom.mul_left r) = has_mul.mul r", "decl_nm": "add_monoid_hom.coe_mul_left"}
{"formal_statement": "theorem inf_nndist {\u03b1 \u03b2 : Type*} [metric_space \u03b1] [measurable_space \u03b1]\n\t[opens_measurable_space \u03b1] [measurable_space \u03b2] {f : \u03b2 \u2192 \u03b1} (hf : measurable f) :\n\t\u2200 {s : set \u03b1}, measurable (\u03bb (x : \u03b2), metric.inf_nndist (f x) s)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : metric_space \u03b1] [_inst_2 : measurable_space \u03b1] [_inst_3 : opens_measurable_space \u03b1] [_inst_4 : measurable_space \u03b2] {f : \u03b2 \u2192 \u03b1}, measurable f \u2192 \u2200 {s : set \u03b1}, measurable (\u03bb (x : \u03b2), metric.inf_nndist (f x) s)", "decl_nm": "measurable.inf_nndist"}
{"formal_statement": "theorem size_le_size {m n : \u2115} (h : m \u2264 n) :\n\tm.size \u2264 n.size", "decl_tp": "\u2200 {m n : \u2115}, m \u2264 n \u2192 m.size \u2264 n.size", "decl_nm": "nat.size_le_size"}
{"formal_statement": "theorem abs_integral_mono_interval {\u03b1 : Type*} [linear_order \u03b1] [measurable_space \u03b1]\n\t{f : \u03b1 \u2192 \u211d} {a b : \u03b1} {\u03bc : measure_theory.measure \u03b1} {c d : \u03b1} (h : set.interval_oc a b \u2286 set.interval_oc c d)\n\t(hf : 0 \u2264\u1d50[\u03bc.restrict (set.interval_oc c d)] f) (hfi : interval_integrable f \u03bc c d) :\n\t|\u222b (x : \u03b1) in a..b, f x \u2202\u03bc| \u2264 |\u222b (x : \u03b1) in c..d, f x \u2202\u03bc|", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : linear_order \u03b1] [_inst_2 : measurable_space \u03b1] {f : \u03b1 \u2192 \u211d} {a b : \u03b1} {\u03bc : measure_theory.measure \u03b1} {c d : \u03b1}, set.interval_oc a b \u2286 set.interval_oc c d \u2192 0 \u2264\u1d50[\u03bc.restrict (set.interval_oc c d)] f \u2192 interval_integrable f \u03bc c d \u2192 |\u222b (x : \u03b1) in a..b, f x \u2202\u03bc| \u2264 |\u222b (x : \u03b1) in c..d, f x \u2202\u03bc|", "decl_nm": "interval_integral.abs_integral_mono_interval"}
{"formal_statement": "theorem unop_eq_zero_iff {\u03b1 : Type*} [has_zero \u03b1] (a : \u03b1\u1d50\u1d52\u1d56) :\n\tmul_opposite.unop a = 0 \u2194 a = 0", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : has_zero \u03b1] (a : \u03b1\u1d50\u1d52\u1d56), mul_opposite.unop a = 0 \u2194 a = 0", "decl_nm": "mul_opposite.unop_eq_zero_iff"}
{"formal_statement": "theorem min_lt_iff {\u03b1 : Type u} [linear_order \u03b1] {a b c : \u03b1} :\n\tlinear_order.min a b < c \u2194 a < c \u2228 b < c", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : linear_order \u03b1] {a b c : \u03b1}, linear_order.min a b < c \u2194 a < c \u2228 b < c", "decl_nm": "min_lt_iff"}
{"formal_statement": "theorem closure_eq_of_le {M : Type*} [add_zero_class M] {s : set M} {S : add_submonoid M}\n\t(h\u2081 : s \u2286 \u2191S) (h\u2082 : S \u2264 add_submonoid.closure s) :\n\tadd_submonoid.closure s = S", "decl_tp": "\u2200 {M : Type u_1} [_inst_1 : add_zero_class M] {s : set M} {S : add_submonoid M}, s \u2286 \u2191S \u2192 S \u2264 add_submonoid.closure s \u2192 add_submonoid.closure s = S", "decl_nm": "add_submonoid.closure_eq_of_le"}
{"formal_statement": "theorem iterate_right {\u03b1 : Type u} {f g : \u03b1 \u2192 \u03b1} (h : function.commute f g) :\n\t\u2200 (n : \u2115), function.commute f g^[n]", "decl_tp": "\u2200 {\u03b1 : Type u} {f g : \u03b1 \u2192 \u03b1}, function.commute f g \u2192 \u2200 (n : \u2115), function.commute f g^[n]", "decl_nm": "function.commute.iterate_right"}
{"formal_statement": "theorem all_ae_tendsto_of_real_norm {\u03b1 \u03b2 : Type*} {m : measurable_space \u03b1}\n\t{\u03bc : measure_theory.measure \u03b1} [normed_group \u03b2] {F : \u2115 \u2192 \u03b1 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2} :\n\t(\u2200\u1d50 (a : \u03b1) \u2202\u03bc, filter.tendsto (\u03bb (n : \u2115), F n a) filter.at_top (nhds (f a))) \u2192 (\u2200\u1d50 (a : \u03b1) \u2202\u03bc, filter.tendsto (\u03bb (n : \u2115), ennreal.of_real \u2225F n a\u2225) filter.at_top (nhds (ennreal.of_real \u2225f a\u2225)))", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {m : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} [_inst_1 : normed_group \u03b2] {F : \u2115 \u2192 \u03b1 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2}, (\u2200\u1d50 (a : \u03b1) \u2202\u03bc, filter.tendsto (\u03bb (n : \u2115), F n a) filter.at_top (nhds (f a))) \u2192 (\u2200\u1d50 (a : \u03b1) \u2202\u03bc, filter.tendsto (\u03bb (n : \u2115), ennreal.of_real \u2225F n a\u2225) filter.at_top (nhds (ennreal.of_real \u2225f a\u2225)))", "decl_nm": "measure_theory.all_ae_tendsto_of_real_norm"}
{"formal_statement": "theorem evaluation_left_adjoint_obj_obj {C : Type u\u2081} [category_theory.category C]\n\t(D : Type u\u2082) [category_theory.category D] [\u2200 (a b : C), category_theory.limits.has_coproducts_of_shape (a \u27f6 b) D]\n\t(c : C) (d : D) (t : C) :\n\t((category_theory.evaluation_left_adjoint D c).obj d).obj t = \u2210 \u03bb (i : c \u27f6 t), d", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] (D : Type u\u2082) [_inst_2 : category_theory.category D] [_inst_3 : \u2200 (a b : C), category_theory.limits.has_coproducts_of_shape (a \u27f6 b) D] (c : C) (d : D) (t : C), ((category_theory.evaluation_left_adjoint D c).obj d).obj t = \u2210 \u03bb (i : c \u27f6 t), d", "decl_nm": "category_theory.evaluation_left_adjoint_obj_obj"}
{"formal_statement": "theorem clog {\u03b1 : Type*} [topological_space \u03b1] {f : \u03b1 \u2192 \u2102} {s : set \u03b1}\n\t(h\u2081 : continuous_on f s) (hx : x \u2208 s) :\n\t(\u2200 (x : \u03b1),  0 < (f x).re \u2228 (f x).im \u2260 0) \u2192 continuous_on (\u03bb (t : \u03b1), complex.log (f t)) s", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : topological_space \u03b1] {f : \u03b1 \u2192 \u2102} {s : set \u03b1}, continuous_on f s \u2192 (\u2200 (x : \u03b1), x \u2208 s \u2192 0 < (f x).re \u2228 (f x).im \u2260 0) \u2192 continuous_on (\u03bb (t : \u03b1), complex.log (f t)) s", "decl_nm": "continuous_on.clog"}
{"formal_statement": "theorem map_comap_map {M N : Type*} [mul_one_class M] [mul_one_class N]\n\t(S : submonoid M) {f : M \u2192* N} :\n\tsubmonoid.map f (submonoid.comap f (submonoid.map f S)) = submonoid.map f S", "decl_tp": "\u2200 {M : Type u_1} {N : Type u_2} [_inst_1 : mul_one_class M] [_inst_2 : mul_one_class N] (S : submonoid M) {f : M \u2192* N}, submonoid.map f (submonoid.comap f (submonoid.map f S)) = submonoid.map f S", "decl_nm": "submonoid.map_comap_map"}
{"formal_statement": "theorem map_iso_refl {X Y : Top} (f : X \u27f6 Y) (h : f = f) :\n\ttopological_space.opens.map_iso f f h = category_theory.iso.refl (topological_space.opens.map f)", "decl_tp": "\u2200 {X Y : Top} (f : X \u27f6 Y) (h : f = f), topological_space.opens.map_iso f f h = category_theory.iso.refl (topological_space.opens.map f)", "decl_nm": "topological_space.opens.map_iso_refl"}
{"formal_statement": "theorem lt_top {\u03b1 \u03b2 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} (f : principal_seg r s)\n\t(a : \u03b1) :\n\ts (\u21d1f a) f.top", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} (f : principal_seg r s) (a : \u03b1), s (\u21d1f a) f.top", "decl_nm": "principal_seg.lt_top"}
{"formal_statement": "theorem to_homeomorph_to_equiv {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c]\n\t{E : Type*} [normed_group E] [normed_space \ud835\udd5c E] {F : Type*} [normed_group F]\n\t[normed_space \ud835\udd5c F] {H : Type*} [topological_space H] {G : Type*} [topological_space G]\n\t{I : model_with_corners \ud835\udd5c E H} {J : model_with_corners \ud835\udd5c F G} {M : Type*}\n\t[topological_space M] [charted_space H M] {N : Type*0} [topological_space N]\n\t[charted_space G N] {n : with_top \u2115} (h : diffeomorph I J M N n) :\n\th.to_homeomorph.to_equiv = h.to_equiv", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {F : Type u_4} [_inst_6 : normed_group F] [_inst_7 : normed_space \ud835\udd5c F] {H : Type u_5} [_inst_8 : topological_space H] {G : Type u_7} [_inst_10 : topological_space G] {I : model_with_corners \ud835\udd5c E H} {J : model_with_corners \ud835\udd5c F G} {M : Type u_8} [_inst_11 : topological_space M] [_inst_12 : charted_space H M] {N : Type u_10} [_inst_15 : topological_space N] [_inst_16 : charted_space G N] {n : with_top \u2115} (h : diffeomorph I J M N n), h.to_homeomorph.to_equiv = h.to_equiv", "decl_nm": "diffeomorph.to_homeomorph_to_equiv"}
{"formal_statement": "theorem add_subset_add_left {\u03b1 : Type*} {s t\u2081 t\u2082 : set \u03b1} [has_add \u03b1] (h : t\u2081 \u2286 t\u2082) :\n\ts + t\u2081 \u2286 s + t\u2082", "decl_tp": "\u2200 {\u03b1 : Type u_1} {s t\u2081 t\u2082 : set \u03b1} [_inst_1 : has_add \u03b1], t\u2081 \u2286 t\u2082 \u2192 s + t\u2081 \u2286 s + t\u2082", "decl_nm": "set.add_subset_add_left"}
{"formal_statement": "theorem frontier_closed_ball_subset_sphere {\u03b1 : Type u} [pseudo_metric_space \u03b1]\n\t{x : \u03b1} {\u03b5 : \u211d} :\n\tfrontier (metric.closed_ball x \u03b5) \u2286 metric.sphere x \u03b5", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : pseudo_metric_space \u03b1] {x : \u03b1} {\u03b5 : \u211d}, frontier (metric.closed_ball x \u03b5) \u2286 metric.sphere x \u03b5", "decl_nm": "metric.frontier_closed_ball_subset_sphere"}
{"formal_statement": "theorem conj_transpose_list_prod {m : Type*} {\u03b1 : Type v} [comm_semiring \u03b1]\n\t[star_ring \u03b1] [fintype m] [decidable_eq m] (l : list (matrix m m \u03b1)) :\n\tl.prod.conj_transpose = (list.map matrix.conj_transpose l).reverse.prod", "decl_tp": "\u2200 {m : Type u_2} {\u03b1 : Type v} [_inst_1 : comm_semiring \u03b1] [_inst_2 : star_ring \u03b1] [_inst_3 : fintype m] [_inst_4 : decidable_eq m] (l : list (matrix m m \u03b1)), l.prod.conj_transpose = (list.map matrix.conj_transpose l).reverse.prod", "decl_nm": "matrix.conj_transpose_list_prod"}
{"formal_statement": "theorem measure_Ioc (f : stieltjes_function) (a b : \u211d) :\n\t\u21d1(f.measure) (set.Ioc a b) = ennreal.of_real (\u21d1f b - \u21d1f a)", "decl_tp": "\u2200 (f : stieltjes_function) (a b : \u211d), \u21d1(f.measure) (set.Ioc a b) = ennreal.of_real (\u21d1f b - \u21d1f a)", "decl_nm": "stieltjes_function.measure_Ioc"}
{"formal_statement": "theorem div_le_iff_le_mul' {\u03b1 : Type u} [comm_group \u03b1] [has_le \u03b1] [covariant_class \u03b1 \u03b1 has_mul.mul has_le.le]\n\t{a b c : \u03b1} :\n\ta / b \u2264 c \u2194 a \u2264 b * c", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : comm_group \u03b1] [_inst_2 : has_le \u03b1] [_inst_3 : covariant_class \u03b1 \u03b1 has_mul.mul has_le.le] {a b c : \u03b1}, a / b \u2264 c \u2194 a \u2264 b * c", "decl_nm": "div_le_iff_le_mul'"}
{"formal_statement": "theorem disjoint_coe_of_mem {\u03b9 : Type*} {I J\u2081 J\u2082 : box_integral.box \u03b9}\n\t(\u03c0 : box_integral.prepartition I) (h\u2081 : J\u2081 \u2208 \u03c0) (h\u2082 : J\u2082 \u2208 \u03c0) (h : J\u2081 \u2260 J\u2082) :\n\tdisjoint \u2191J\u2081 \u2191J\u2082", "decl_tp": "\u2200 {\u03b9 : Type u_1} {I J\u2081 J\u2082 : box_integral.box \u03b9} (\u03c0 : box_integral.prepartition I), J\u2081 \u2208 \u03c0 \u2192 J\u2082 \u2208 \u03c0 \u2192 J\u2081 \u2260 J\u2082 \u2192 disjoint \u2191J\u2081 \u2191J\u2082", "decl_nm": "box_integral.prepartition.disjoint_coe_of_mem"}
{"formal_statement": "theorem diam_eq_zero_iff {\u03b3 : Type w} [emetric_space \u03b3] {s : set \u03b3} :\n\temetric.diam s = 0 \u2194 s.subsingleton", "decl_tp": "\u2200 {\u03b3 : Type w} [_inst_2 : emetric_space \u03b3] {s : set \u03b3}, emetric.diam s = 0 \u2194 s.subsingleton", "decl_nm": "emetric.diam_eq_zero_iff"}
{"formal_statement": "theorem is_unit_one {M : Type*} [monoid M] :\n\tis_unit 1", "decl_tp": "\u2200 {M : Type u_1} [_inst_1 : monoid M], is_unit 1", "decl_nm": "is_unit_one"}
{"formal_statement": "theorem comap_eval_ne_bot {\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} [\u2200 (j : \u03b9), nonempty (\u03b1 j)]\n\t(i : \u03b9) (f : filter (\u03b1 i)) [f.ne_bot] :\n\t(filter.comap (function.eval i) f).ne_bot", "decl_tp": "\u2200 {\u03b9 : Type u_1} {\u03b1 : \u03b9 \u2192 Type u_2} [_inst_1 : \u2200 (j : \u03b9), nonempty (\u03b1 j)] (i : \u03b9) (f : filter (\u03b1 i)) [_inst_2 : f.ne_bot], (filter.comap (function.eval i) f).ne_bot", "decl_nm": "filter.comap_eval_ne_bot"}
{"formal_statement": "theorem mul_mem_mul {R : Type*} [comm_ring R] {S : submonoid R} {P : Type*}\n\t[comm_ring P] [algebra R P] {I J : fractional_ideal S P} {i j : P} (hi : i \u2208 I)\n\t(hj : j \u2208 J) :\n\ti * j \u2208 I * J", "decl_tp": "\u2200 {R : Type u_1} [_inst_1 : comm_ring R] {S : submonoid R} {P : Type u_2} [_inst_2 : comm_ring P] [_inst_3 : algebra R P] {I J : fractional_ideal S P} {i j : P}, i \u2208 I \u2192 j \u2208 J \u2192 i * j \u2208 I * J", "decl_nm": "fractional_ideal.mul_mem_mul"}
{"formal_statement": "theorem num_X {K : Type u} [hfield : field K] :\n\tratfunc.X.num = polynomial.X", "decl_tp": "\u2200 {K : Type u} [hfield : field K], ratfunc.X.num = polynomial.X", "decl_nm": "ratfunc.num_X"}
{"formal_statement": "theorem modeq_digits_sum (b b' : \u2115) (h : b' % b = 1) :\n\t\u2200 (n : \u2115), n \u2261 (b'.digits n).sum [MOD b]", "decl_tp": "\u2200 (b b' : \u2115), b' % b = 1 \u2192 \u2200 (n : \u2115), n \u2261 (b'.digits n).sum [MOD b]", "decl_nm": "nat.modeq_digits_sum"}
{"formal_statement": "theorem zsmul_lt_zsmul' {A : Type y} [ordered_add_comm_group A] {n : \u2124}\n\t(hn : 0 < n) (h : a\u2081 < a\u2082) :\n\t\u2200 {a\u2081 a\u2082 : A},  n \u2022 a\u2081 < n \u2022 a\u2082", "decl_tp": "\u2200 {A : Type y} [_inst_1 : ordered_add_comm_group A] {n : \u2124}, 0 < n \u2192 \u2200 {a\u2081 a\u2082 : A}, a\u2081 < a\u2082 \u2192 n \u2022 a\u2081 < n \u2022 a\u2082", "decl_nm": "zsmul_lt_zsmul'"}
{"formal_statement": "theorem ker_def {\u03b1 \u03b2 : Type*} {f : \u03b1 \u2192 \u03b2} {x y : \u03b1} :\n\t(setoid.ker f).rel x y \u2194 f x = f y", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {f : \u03b1 \u2192 \u03b2} {x y : \u03b1}, (setoid.ker f).rel x y \u2194 f x = f y", "decl_nm": "setoid.ker_def"}
{"formal_statement": "theorem flatten_equiv {\u03b1 : Type u} {c : computation (wseq \u03b1)} {s : wseq \u03b1}\n\t(h : s \u2208 c) :\n\twseq.flatten c ~ s", "decl_tp": "\u2200 {\u03b1 : Type u} {c : computation (wseq \u03b1)} {s : wseq \u03b1}, s \u2208 c \u2192 wseq.flatten c ~ s", "decl_nm": "wseq.flatten_equiv"}
{"formal_statement": "theorem bij_on_Union_of_directed {\u03b1 \u03b2 : Type*} {\u03b9 : Sort u_4} {s : \u03b9 \u2192 set \u03b1}\n\t(hs : directed has_subset.subset s) :\n\t\u2200 {t : \u03b9 \u2192 set \u03b2} {f : \u03b1 \u2192 \u03b2}, (\u2200 (i : \u03b9), set.bij_on f (s i) (t i)) \u2192 set.bij_on f (\u22c3 (i : \u03b9), s i)\n\t(\u22c3 (i : \u03b9), t i)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {\u03b9 : Sort u_4} {s : \u03b9 \u2192 set \u03b1}, directed has_subset.subset s \u2192 \u2200 {t : \u03b9 \u2192 set \u03b2} {f : \u03b1 \u2192 \u03b2}, (\u2200 (i : \u03b9), set.bij_on f (s i) (t i)) \u2192 set.bij_on f (\u22c3 (i : \u03b9), s i) (\u22c3 (i : \u03b9), t i)", "decl_nm": "set.bij_on_Union_of_directed"}
{"formal_statement": "theorem one_min {\u03b1 : Type u} [canonically_linear_ordered_monoid \u03b1] (a : \u03b1) :\n\tlinear_order.min 1 a = 1", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : canonically_linear_ordered_monoid \u03b1] (a : \u03b1), linear_order.min 1 a = 1", "decl_nm": "one_min"}
{"formal_statement": "theorem common_neighbors_symm {V : Type u} (G : simple_graph V) (v w : V) :\n\tG.common_neighbors v w = G.common_neighbors w v", "decl_tp": "\u2200 {V : Type u} (G : simple_graph V) (v w : V), G.common_neighbors v w = G.common_neighbors w v", "decl_nm": "simple_graph.common_neighbors_symm"}
{"formal_statement": "theorem odd_add {m n : \u2124} :\n\todd (m + n) \u2194 (odd m \u2194 even n)", "decl_tp": "\u2200 {m n : \u2124}, odd (m + n) \u2194 (odd m \u2194 even n)", "decl_nm": "int.odd_add"}
{"formal_statement": "theorem neg {\u03b1 \u03b2 : Type*} [add_group \u03b1] [add_comm_group \u03b2] {f : \u03b1 \u2192 \u03b2}\n\t(hf : is_add_group_hom f) :\n\tis_add_group_hom (\u03bb (a : \u03b1), -f a)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_3 : add_group \u03b1] [_inst_4 : add_comm_group \u03b2] {f : \u03b1 \u2192 \u03b2}, is_add_group_hom f \u2192 is_add_group_hom (\u03bb (a : \u03b1), -f a)", "decl_nm": "is_add_group_hom.neg"}
{"formal_statement": "theorem presheaf_to_Types_obj (X : Top) {T : \u21a5X \u2192 Type v} {U : (topological_space.opens \u21a5X)\u1d52\u1d56} :\n\t(X.presheaf_to_Types T).obj U = \u03a0 (x : \u21a5(opposite.unop U)), T \u2191x", "decl_tp": "\u2200 (X : Top) {T : \u21a5X \u2192 Type v} {U : (topological_space.opens \u21a5X)\u1d52\u1d56}, (X.presheaf_to_Types T).obj U = \u03a0 (x : \u21a5(opposite.unop U)), T \u2191x", "decl_nm": "Top.presheaf_to_Types_obj"}
{"formal_statement": "theorem ext {p : \u2115} [fact (nat.prime p)] {x y : \u2124_[p]} :\n\t\u2191x = \u2191y \u2192 x = y", "decl_tp": "\u2200 {p : \u2115} [_inst_1 : fact (nat.prime p)] {x y : \u2124_[p]}, \u2191x = \u2191y \u2192 x = y", "decl_nm": "padic_int.ext"}
{"formal_statement": "theorem lt_of_mul_lt_mul_right {\u03b1 : Type u} [linear_ordered_semiring \u03b1]\n\t{a b c : \u03b1} (h : a * c < b * c) (hc : 0 \u2264 c) :\n\ta < b", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : linear_ordered_semiring \u03b1] {a b c : \u03b1}, a * c < b * c \u2192 0 \u2264 c \u2192 a < b", "decl_nm": "lt_of_mul_lt_mul_right"}
{"formal_statement": "theorem to_add_submonoid_injective {R : Type u} [non_assoc_semiring R] :\n\tfunction.injective subsemiring.to_add_submonoid", "decl_tp": "\u2200 {R : Type u} [_inst_1 : non_assoc_semiring R], function.injective subsemiring.to_add_submonoid", "decl_nm": "subsemiring.to_add_submonoid_injective"}
{"formal_statement": "theorem flip {\u03b1 \u03b2 : Type*} {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {a : list \u03b1} {b : list \u03b2}\n\t(\u1fb0 : list.forall\u2082 (flip r) b a) :\n\tlist.forall\u2082 r a b", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {a : list \u03b1} {b : list \u03b2}, list.forall\u2082 (flip r) b a \u2192 list.forall\u2082 r a b", "decl_nm": "list.forall\u2082.flip"}
{"formal_statement": "theorem coe_comap {R : Type u} {S : Type v} [non_assoc_semiring R] [non_assoc_semiring S]\n\t(s : subsemiring S) (f : R \u2192+* S) :\n\t\u2191(subsemiring.comap f s) = \u21d1f \u207b\u00b9' \u2191s", "decl_tp": "\u2200 {R : Type u} {S : Type v} [_inst_1 : non_assoc_semiring R] [_inst_2 : non_assoc_semiring S] (s : subsemiring S) (f : R \u2192+* S), \u2191(subsemiring.comap f s) = \u21d1f \u207b\u00b9' \u2191s", "decl_nm": "subsemiring.coe_comap"}
{"formal_statement": "theorem inf_mono {\u03b1 : Type*} [semilattice_inf \u03b1] [order_top \u03b1] {s\u2081 s\u2082 : multiset \u03b1}\n\t(h : s\u2081 \u2286 s\u2082) :\n\ts\u2082.inf \u2264 s\u2081.inf", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : semilattice_inf \u03b1] [_inst_2 : order_top \u03b1] {s\u2081 s\u2082 : multiset \u03b1}, s\u2081 \u2286 s\u2082 \u2192 s\u2082.inf \u2264 s\u2081.inf", "decl_nm": "multiset.inf_mono"}
{"formal_statement": "theorem comp {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} [preorder \u03b1] [preorder \u03b2]\n\t[preorder \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2} (hg : monotone g) (hf : monotone f) :\n\tmonotone (g \u2218 f)", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} [_inst_1 : preorder \u03b1] [_inst_2 : preorder \u03b2] [_inst_3 : preorder \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}, monotone g \u2192 monotone f \u2192 monotone (g \u2218 f)", "decl_nm": "monotone.comp"}
{"formal_statement": "theorem Icc_eq_filter_powerset {\u03b1 : Type*} [decidable_eq \u03b1] (s t : finset \u03b1) :\n\tfinset.Icc s t = finset.filter (has_subset.subset s) t.powerset", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : decidable_eq \u03b1] (s t : finset \u03b1), finset.Icc s t = finset.filter (has_subset.subset s) t.powerset", "decl_nm": "finset.Icc_eq_filter_powerset"}
{"formal_statement": "theorem card_eq_zero {\u03b1 : Type*} {s : multiset \u03b1} :\n\t\u21d1multiset.card s = 0 \u2194 s = 0", "decl_tp": "\u2200 {\u03b1 : Type u_1} {s : multiset \u03b1}, \u21d1multiset.card s = 0 \u2194 s = 0", "decl_nm": "multiset.card_eq_zero"}
{"formal_statement": "theorem costructured_arrow_yoneda_equivalence_functor_obj_left {C : Type u}\n\t[category_theory.category C] (F : C\u1d52\u1d56 \u2964 Type v) (X : (F.elements)\u1d52\u1d56) :\n\t((category_theory.category_of_elements.costructured_arrow_yoneda_equivalence F).functor.obj X).left = opposite.unop (opposite.unop X).fst", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] (F : C\u1d52\u1d56 \u2964 Type v) (X : (F.elements)\u1d52\u1d56), ((category_theory.category_of_elements.costructured_arrow_yoneda_equivalence F).functor.obj X).left = opposite.unop (opposite.unop X).fst", "decl_nm": "category_theory.category_of_elements.costructured_arrow_yoneda_equivalence_functor_obj_left"}
{"formal_statement": "theorem bernoulli_apply {p : nnreal} (h : p \u2264 1) (b : bool) :\n\t\u21d1(pmf.bernoulli p h) b = cond b p (1 - p)", "decl_tp": "\u2200 {p : nnreal} (h : p \u2264 1) (b : bool), \u21d1(pmf.bernoulli p h) b = cond b p (1 - p)", "decl_nm": "pmf.bernoulli_apply"}
{"formal_statement": "theorem ae_sum_iff' {\u03b1 \u03b9 : Type*} {m0 : measurable_space \u03b1} {\u03bc : \u03b9 \u2192 measure_theory.measure \u03b1}\n\t{p : \u03b1 \u2192 Prop} (h : measurable_set {x : \u03b1 | p x}) :\n\t((\u2200\u1d50 (x : \u03b1) \u2202measure_theory.measure.sum \u03bc, p x) \u2194 \u2200 (i : \u03b9), \u2200\u1d50 (x : \u03b1) \u2202\u03bc i, p x)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b9 : Type u_5} {m0 : measurable_space \u03b1} {\u03bc : \u03b9 \u2192 measure_theory.measure \u03b1} {p : \u03b1 \u2192 Prop}, measurable_set {x : \u03b1 | p x} \u2192 ((\u2200\u1d50 (x : \u03b1) \u2202measure_theory.measure.sum \u03bc, p x) \u2194 \u2200 (i : \u03b9), \u2200\u1d50 (x : \u03b1) \u2202\u03bc i, p x)", "decl_nm": "measure_theory.measure.ae_sum_iff'"}
{"formal_statement": "theorem bdd_above_Icc {\u03b1 : Type u} [preorder \u03b1] {a b : \u03b1} :\n\tbdd_above (set.Icc a b)", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : preorder \u03b1] {a b : \u03b1}, bdd_above (set.Icc a b)", "decl_nm": "bdd_above_Icc"}
{"formal_statement": "theorem continuous_add_left {M : Type*} [add_semigroup M] (V : ultrafilter M) :\n\tcontinuous (\u03bb (_x : ultrafilter M), _x + V)", "decl_tp": "\u2200 {M : Type u_1} [_inst_1 : add_semigroup M] (V : ultrafilter M), continuous (\u03bb (_x : ultrafilter M), _x + V)", "decl_nm": "ultrafilter.continuous_add_left"}
{"formal_statement": "theorem mono_left {\u03b1 : Type*} [preorder \u03b1] {x y : \u03b1} (xy : x \u2264 y) (\u1fb0 : t.bounded \u2191y o) :\n\t\u2200 {t : ordnode \u03b1} {o : with_top \u03b1},  t.bounded \u2191x o", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : preorder \u03b1] {x y : \u03b1}, x \u2264 y \u2192 \u2200 {t : ordnode \u03b1} {o : with_top \u03b1}, t.bounded \u2191y o \u2192 t.bounded \u2191x o", "decl_nm": "ordnode.bounded.mono_left"}
{"formal_statement": "theorem mul_indicator_preimage {\u03b1 M : Type*} [has_one M] (s : set \u03b1) (f : \u03b1 \u2192 M)\n\t(B : set M) :\n\ts.mul_indicator f \u207b\u00b9' B = s.ite (f \u207b\u00b9' B) (1 \u207b\u00b9' B)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {M : Type u_4} [_inst_1 : has_one M] (s : set \u03b1) (f : \u03b1 \u2192 M) (B : set M), s.mul_indicator f \u207b\u00b9' B = s.ite (f \u207b\u00b9' B) (1 \u207b\u00b9' B)", "decl_nm": "set.mul_indicator_preimage"}
{"formal_statement": "theorem minor_diagonal_equiv {l m : Type*} {\u03b1 : Type v} [has_zero \u03b1] [decidable_eq m]\n\t[decidable_eq l] (d : m \u2192 \u03b1) (e : l \u2243 m) :\n\t(matrix.diagonal d).minor \u21d1e \u21d1e = matrix.diagonal (d \u2218 \u21d1e)", "decl_tp": "\u2200 {l : Type u_1} {m : Type u_2} {\u03b1 : Type v} [_inst_1 : has_zero \u03b1] [_inst_2 : decidable_eq m] [_inst_3 : decidable_eq l] (d : m \u2192 \u03b1) (e : l \u2243 m), (matrix.diagonal d).minor \u21d1e \u21d1e = matrix.diagonal (d \u2218 \u21d1e)", "decl_nm": "matrix.minor_diagonal_equiv"}
{"formal_statement": "theorem coe_inl {R : Type u} {M : Type v} {M\u2082 : Type w} [semiring R] [add_comm_monoid M]\n\t[add_comm_monoid M\u2082] [module R M] [module R M\u2082] :\n\t\u21d1(linear_map.inl R M M\u2082) = \u03bb (x : M), (x, 0)", "decl_tp": "\u2200 {R : Type u} {M : Type v} {M\u2082 : Type w} [_inst_1 : semiring R] [_inst_3 : add_comm_monoid M] [_inst_4 : add_comm_monoid M\u2082] [_inst_7 : module R M] [_inst_8 : module R M\u2082], \u21d1(linear_map.inl R M M\u2082) = \u03bb (x : M), (x, 0)", "decl_nm": "linear_map.coe_inl"}
{"formal_statement": "theorem out_mk {\u03b1 : Sort u_1} (a : \u03b1) :\n\t(erased.mk a).out = a", "decl_tp": "\u2200 {\u03b1 : Sort u_1} (a : \u03b1), (erased.mk a).out = a", "decl_nm": "erased.out_mk"}
{"formal_statement": "theorem nat_degree_eq_of_degree_eq {R : Type u} {S : Type v} [semiring R]\n\t{p : polynomial R} [semiring S] {q : polynomial S} (h : p.degree = q.degree) :\n\tp.nat_degree = q.nat_degree", "decl_tp": "\u2200 {R : Type u} {S : Type v} [_inst_1 : semiring R] {p : polynomial R} [_inst_2 : semiring S] {q : polynomial S}, p.degree = q.degree \u2192 p.nat_degree = q.nat_degree", "decl_nm": "polynomial.nat_degree_eq_of_degree_eq"}
{"formal_statement": "theorem not_exists {\u03b1 : Sort u_1} {p : \u03b1 \u2192 Prop} :\n\t(\u00ac\u2203 (x : \u03b1), p x) \u2194 \u2200 (x : \u03b1), \u00acp x", "decl_tp": "\u2200 {\u03b1 : Sort u_1} {p : \u03b1 \u2192 Prop}, (\u00ac\u2203 (x : \u03b1), p x) \u2194 \u2200 (x : \u03b1), \u00acp x", "decl_nm": "not_exists"}
{"formal_statement": "theorem factors_left_of_inf_factors {C : Type u\u2081} [category_theory.category C]\n\t[category_theory.limits.has_pullbacks C] {A B : C} {X Y : category_theory.subobject B}\n\t{f : A \u27f6 B} (h : (X \u2293 Y).factors f) :\n\tX.factors f", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] [_inst_3 : category_theory.limits.has_pullbacks C] {A B : C} {X Y : category_theory.subobject B} {f : A \u27f6 B}, (X \u2293 Y).factors f \u2192 X.factors f", "decl_nm": "category_theory.subobject.factors_left_of_inf_factors"}
{"formal_statement": "theorem null_measurable_set_singleton {\u03b1 : Type*} {m0 : measurable_space \u03b1}\n\t{\u03bc : measure_theory.measure \u03b1} [measurable_singleton_class (measure_theory.null_measurable_space \u03b1 \u03bc)]\n\t(x : \u03b1) :\n\tmeasure_theory.null_measurable_set {x} \u03bc", "decl_tp": "\u2200 {\u03b1 : Type u_2} {m0 : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} [_inst_1 : measurable_singleton_class (measure_theory.null_measurable_space \u03b1 \u03bc)] (x : \u03b1), measure_theory.null_measurable_set {x} \u03bc", "decl_nm": "measure_theory.null_measurable_set_singleton"}
{"formal_statement": "theorem not_mem_Ico_of_ge {\u03b1 : Type u} [linear_order \u03b1] {a b c : \u03b1} (hb : b \u2264 c) :\n\tc \u2209 set.Ico a b", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : linear_order \u03b1] {a b c : \u03b1}, b \u2264 c \u2192 c \u2209 set.Ico a b", "decl_nm": "set.not_mem_Ico_of_ge"}
{"formal_statement": "theorem comp_tendsto {\u03b1 \u03b2 E F : Type*} [has_norm E] [has_norm F] {f : \u03b1 \u2192 E}\n\t{g : \u03b1 \u2192 F} {l : filter \u03b1} (hfg : asymptotics.is_O f g l) (hk : filter.tendsto k l' l) :\n\t\u2200 {k : \u03b2 \u2192 \u03b1} {l' : filter \u03b2},  asymptotics.is_O (f \u2218 k) (g \u2218 k) l'", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {E : Type u_3} {F : Type u_4} [_inst_1 : has_norm E] [_inst_2 : has_norm F] {f : \u03b1 \u2192 E} {g : \u03b1 \u2192 F} {l : filter \u03b1}, asymptotics.is_O f g l \u2192 \u2200 {k : \u03b2 \u2192 \u03b1} {l' : filter \u03b2}, filter.tendsto k l' l \u2192 asymptotics.is_O (f \u2218 k) (g \u2218 k) l'", "decl_nm": "asymptotics.is_O.comp_tendsto"}
{"formal_statement": "theorem range_algebra_map_subset (F : Type*) [field F] {E : Type*} [field E]\n\t[algebra F E] (S : set E) :\n\tset.range \u21d1(algebra_map F E) \u2286 \u2191(intermediate_field.adjoin F S)", "decl_tp": "\u2200 (F : Type u_1) [_inst_1 : field F] {E : Type u_2} [_inst_2 : field E] [_inst_3 : algebra F E] (S : set E), set.range \u21d1(algebra_map F E) \u2286 \u2191(intermediate_field.adjoin F S)", "decl_nm": "intermediate_field.adjoin.range_algebra_map_subset"}
{"formal_statement": "theorem le_count_apply {\u03b1 : Type*} {s : set \u03b1} [measurable_space \u03b1] :\n\t\u2211' (i : \u21a5s), 1 \u2264 \u21d1measure_theory.measure.count s", "decl_tp": "\u2200 {\u03b1 : Type u_1} {s : set \u03b1} [_inst_3 : measurable_space \u03b1], \u2211' (i : \u21a5s), 1 \u2264 \u21d1measure_theory.measure.count s", "decl_nm": "measure_theory.measure.le_count_apply"}
{"formal_statement": "theorem coe_id (V : SemiNormedGroup) :\n\t\u21d1(\ud835\udfd9 V) = id", "decl_tp": "\u2200 (V : SemiNormedGroup), \u21d1(\ud835\udfd9 V) = id", "decl_nm": "SemiNormedGroup.coe_id"}
{"formal_statement": "theorem descending_central_series_ge_lower {G : Type*} [group G] (H : \u2115 \u2192 subgroup G)\n\t(hH : is_descending_central_series H) :\n\t\u2200 (n : \u2115), lower_central_series G n \u2264 H n", "decl_tp": "\u2200 {G : Type u_1} [_inst_1 : group G] (H : \u2115 \u2192 subgroup G), is_descending_central_series H \u2192 \u2200 (n : \u2115), lower_central_series G n \u2264 H n", "decl_nm": "descending_central_series_ge_lower"}
{"formal_statement": "theorem nhds_within_Ici_self_ne_bot {\u03b1 : Type u} [topological_space \u03b1]\n\t[preorder \u03b1] (a : \u03b1) :\n\t(nhds_within a (set.Ici a)).ne_bot", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : topological_space \u03b1] [_inst_2 : preorder \u03b1] (a : \u03b1), (nhds_within a (set.Ici a)).ne_bot", "decl_nm": "nhds_within_Ici_self_ne_bot"}
{"formal_statement": "theorem integral_exp {a b : \u211d} :\n\t\u222b (x : \u211d) in a..b, real.exp x = real.exp b - real.exp a", "decl_tp": "\u2200 {a b : \u211d}, \u222b (x : \u211d) in a..b, real.exp x = real.exp b - real.exp a", "decl_nm": "integral_exp"}
{"formal_statement": "theorem sum_to_list {\u03b1 : Type*} [add_comm_monoid \u03b1] (s : multiset \u03b1) :\n\ts.to_list.sum = s.sum", "decl_tp": "\u2200 {\u03b1 : Type u_2} [_inst_1 : add_comm_monoid \u03b1] (s : multiset \u03b1), s.to_list.sum = s.sum", "decl_nm": "multiset.sum_to_list"}
{"formal_statement": "theorem lt_or_eq_apply_right {\u03b1 \u03b2 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop}\n\t[is_well_order \u03b2 s] (f : initial_seg r s) (g : r \u2243r s) (a : \u03b1) :\n\t\u21d1g a = \u21d1f a", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} [_inst_1 : is_well_order \u03b2 s] (f : initial_seg r s) (g : r \u2243r s) (a : \u03b1), \u21d1g a = \u21d1f a", "decl_nm": "initial_seg.lt_or_eq_apply_right"}
{"formal_statement": "theorem dom_inv {\u03b1 \u03b2 : Type*} (r : rel \u03b1 \u03b2) :\n\tr.inv.dom = r.codom", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} (r : rel \u03b1 \u03b2), r.inv.dom = r.codom", "decl_nm": "rel.dom_inv"}
{"formal_statement": "theorem bor_inl {a b : bool} (H : \u21a5a) :\n\t\u21a5(a || b)", "decl_tp": "\u2200 {a b : bool}, \u21a5a \u2192 \u21a5(a || b)", "decl_nm": "bool.bor_inl"}
{"formal_statement": "theorem induction_on\u2082 {\u03b1 : Sort u_1} {\u03b2 : Sort u_2} {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\n\t{s : \u03b2 \u2192 \u03b2 \u2192 Prop} {\u03b4 : quot r \u2192 quot s \u2192 Prop} (q\u2081 : quot r) (q\u2082 : quot s) :\n\t(\u2200 (a : \u03b1) (b : \u03b2), \u03b4 (quot.mk r a) (quot.mk s b)) \u2192 \u03b4 q\u2081 q\u2082", "decl_tp": "\u2200 {\u03b1 : Sort u_1} {\u03b2 : Sort u_2} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {\u03b4 : quot r \u2192 quot s \u2192 Prop} (q\u2081 : quot r) (q\u2082 : quot s), (\u2200 (a : \u03b1) (b : \u03b2), \u03b4 (quot.mk r a) (quot.mk s b)) \u2192 \u03b4 q\u2081 q\u2082", "decl_nm": "quot.induction_on\u2082"}
{"formal_statement": "theorem of_digits_one (L : list \u2115) :\n\tnat.of_digits 1 L = L.sum", "decl_tp": "\u2200 (L : list \u2115), nat.of_digits 1 L = L.sum", "decl_nm": "nat.of_digits_one"}
{"formal_statement": "theorem inv {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c] {E : Type*} [normed_group E]\n\t[normed_space \ud835\udd5c E] {\ud835\udd5c' : Type*} [normed_field \ud835\udd5c'] [normed_algebra \ud835\udd5c \ud835\udd5c']\n\t[complete_space \ud835\udd5c'] {f : E \u2192 \ud835\udd5c'} {n : with_top \u2115} (hf : times_cont_diff \ud835\udd5c n f) :\n\t(\u2200 (x : E), f x \u2260 0) \u2192 times_cont_diff \ud835\udd5c n (\u03bb (x : E), (f x)\u207b\u00b9)", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {\ud835\udd5c' : Type u_6} [_inst_10 : normed_field \ud835\udd5c'] [_inst_11 : normed_algebra \ud835\udd5c \ud835\udd5c'] [_inst_12 : complete_space \ud835\udd5c'] {f : E \u2192 \ud835\udd5c'} {n : with_top \u2115}, times_cont_diff \ud835\udd5c n f \u2192 (\u2200 (x : E), f x \u2260 0) \u2192 times_cont_diff \ud835\udd5c n (\u03bb (x : E), (f x)\u207b\u00b9)", "decl_nm": "times_cont_diff.inv"}
{"formal_statement": "theorem volume_pi_ball {\u03b9 : Type*} [fintype \u03b9] (a : \u03b9 \u2192 \u211d) {r : \u211d} (hr : 0 < r) :\n\t\u21d1measure_theory.measure_space.volume (metric.ball a r) = ennreal.of_real ((2 * r) ^ fintype.card \u03b9)", "decl_tp": "\u2200 {\u03b9 : Type u_1} [_inst_1 : fintype \u03b9] (a : \u03b9 \u2192 \u211d) {r : \u211d}, 0 < r \u2192 \u21d1measure_theory.measure_space.volume (metric.ball a r) = ennreal.of_real ((2 * r) ^ fintype.card \u03b9)", "decl_nm": "real.volume_pi_ball"}
{"formal_statement": "theorem mk_psum (\u03b1 : Type u) (\u03b2 : Type v) :\n\tcardinal.mk (psum \u03b1 \u03b2) = (cardinal.mk \u03b1).lift + (cardinal.mk \u03b2).lift", "decl_tp": "\u2200 (\u03b1 : Type u) (\u03b2 : Type v), cardinal.mk (psum \u03b1 \u03b2) = (cardinal.mk \u03b1).lift + (cardinal.mk \u03b2).lift", "decl_nm": "cardinal.mk_psum"}
{"formal_statement": "theorem is_maximal_iff {P : Type*} [preorder P] (I : order.ideal P) :\n\tI.is_maximal \u2194 I.is_proper \u2227 \u2200 \u2983J : order.ideal P\u2984, I < J \u2192 \u2191J = set.univ", "decl_tp": "\u2200 {P : Type u_1} [_inst_1 : preorder P] (I : order.ideal P), I.is_maximal \u2194 I.is_proper \u2227 \u2200 \u2983J : order.ideal P\u2984, I < J \u2192 \u2191J = set.univ", "decl_nm": "order.ideal.is_maximal_iff"}
{"formal_statement": "theorem arcsin_mem_Icc (x : \u211d) :\n\treal.arcsin x \u2208 set.Icc (-(real.pi / 2)) (real.pi / 2)", "decl_tp": "\u2200 (x : \u211d), real.arcsin x \u2208 set.Icc (-(real.pi / 2)) (real.pi / 2)", "decl_nm": "real.arcsin_mem_Icc"}
{"formal_statement": "theorem dvd_abs {\u03b1 : Type u} [ring \u03b1] [linear_order \u03b1] (a b : \u03b1) :\n\ta \u2223 |b| \u2194 a \u2223 b", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : ring \u03b1] [_inst_2 : linear_order \u03b1] (a b : \u03b1), a \u2223 |b| \u2194 a \u2223 b", "decl_nm": "dvd_abs"}
{"formal_statement": "theorem map_lift_eq2 {\u03b1 \u03b2 \u03b3 : Type*} {f : filter \u03b1} {g : set \u03b2 \u2192 filter \u03b3}\n\t{m : \u03b1 \u2192 \u03b2} (hg : monotone g) :\n\t(filter.map m f).lift g = f.lift (g \u2218 set.image m)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {\u03b3 : Type u_3} {f : filter \u03b1} {g : set \u03b2 \u2192 filter \u03b3} {m : \u03b1 \u2192 \u03b2}, monotone g \u2192 (filter.map m f).lift g = f.lift (g \u2218 set.image m)", "decl_nm": "filter.map_lift_eq2"}
{"formal_statement": "theorem mem_ball {\ud835\udd5c E : Type*} [semi_normed_ring \ud835\udd5c] [add_comm_group E]\n\t[has_scalar \ud835\udd5c E] (p : seminorm \ud835\udd5c E) {x y : E} {r : \u211d} :\n\ty \u2208 p.ball x r \u2194 \u21d1p (y - x) < r", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} {E : Type u_2} [_inst_1 : semi_normed_ring \ud835\udd5c] [_inst_2 : add_comm_group E] [_inst_3 : has_scalar \ud835\udd5c E] (p : seminorm \ud835\udd5c E) {x y : E} {r : \u211d}, y \u2208 p.ball x r \u2194 \u21d1p (y - x) < r", "decl_nm": "seminorm.mem_ball"}
{"formal_statement": "theorem mono_comp {\u03b1 : Type u} {\u03b2 : Type v} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) {\u03b9 : Sort u_1}\n\t{rb : \u03b2 \u2192 \u03b2 \u2192 Prop} {g : \u03b1 \u2192 \u03b2} {f : \u03b9 \u2192 \u03b1} (hf : directed r f) :\n\t(\u2200 \u2983x y : \u03b1\u2984, r x y \u2192 rb (g x) (g y)) \u2192  directed rb (g \u2218 f)", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) {\u03b9 : Sort u_1} {rb : \u03b2 \u2192 \u03b2 \u2192 Prop} {g : \u03b1 \u2192 \u03b2} {f : \u03b9 \u2192 \u03b1}, (\u2200 \u2983x y : \u03b1\u2984, r x y \u2192 rb (g x) (g y)) \u2192 directed r f \u2192 directed rb (g \u2218 f)", "decl_nm": "directed.mono_comp"}
{"formal_statement": "theorem nat_lt_subst {n1 n2 : \u2115} {z1 z2 : \u2124} (hn : n1 < n2) (h1 : \u2191n1 = z1)\n\t(h2 : \u2191n2 = z2) :\n\tz1 < z2", "decl_tp": "\u2200 {n1 n2 : \u2115} {z1 z2 : \u2124}, n1 < n2 \u2192 \u2191n1 = z1 \u2192 \u2191n2 = z2 \u2192 z1 < z2", "decl_nm": "linarith.nat_lt_subst"}
{"formal_statement": "theorem append_mk {\u0393 : Type*} [inhabited \u0393] (l\u2081 l\u2082 : list \u0393) :\n\tturing.list_blank.append l\u2081 (turing.list_blank.mk l\u2082) = turing.list_blank.mk (l\u2081 ++ l\u2082)", "decl_tp": "\u2200 {\u0393 : Type u_1} [_inst_1 : inhabited \u0393] (l\u2081 l\u2082 : list \u0393), turing.list_blank.append l\u2081 (turing.list_blank.mk l\u2082) = turing.list_blank.mk (l\u2081 ++ l\u2082)", "decl_nm": "turing.list_blank.append_mk"}
{"formal_statement": "theorem lt_div_iff {a b r : nnreal} (hr : r \u2260 0) :\n\t(a < b / r \u2194 a * r < b)", "decl_tp": "\u2200 {a b r : nnreal}, r \u2260 0 \u2192 (a < b / r \u2194 a * r < b)", "decl_nm": "nnreal.lt_div_iff"}
{"formal_statement": "theorem restrict_empty {\u03b1 : Type*} (m : measure_theory.outer_measure \u03b1) :\n\t\u21d1(measure_theory.outer_measure.restrict \u2205) m = 0", "decl_tp": "\u2200 {\u03b1 : Type u_1} (m : measure_theory.outer_measure \u03b1), \u21d1(measure_theory.outer_measure.restrict \u2205) m = 0", "decl_nm": "measure_theory.outer_measure.restrict_empty"}
{"formal_statement": "theorem continuous {R\u2081 R\u2082 : Type*} [semiring R\u2081] [semiring R\u2082] {\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082}\n\t{\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081} [ring_hom_inv_pair \u03c3\u2081\u2082 \u03c3\u2082\u2081] [ring_hom_inv_pair \u03c3\u2082\u2081 \u03c3\u2081\u2082]\n\t{M\u2081 : Type*} [topological_space M\u2081] [add_comm_monoid M\u2081] {M\u2082 : Type*}\n\t[topological_space M\u2082] [add_comm_monoid M\u2082] [module R\u2081 M\u2081] [module R\u2082 M\u2082]\n\t(e : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) :\n\tcontinuous \u21d1e", "decl_tp": "\u2200 {R\u2081 : Type u_1} {R\u2082 : Type u_2} [_inst_1 : semiring R\u2081] [_inst_2 : semiring R\u2082] {\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082} {\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081} [_inst_4 : ring_hom_inv_pair \u03c3\u2081\u2082 \u03c3\u2082\u2081] [_inst_5 : ring_hom_inv_pair \u03c3\u2082\u2081 \u03c3\u2081\u2082] {M\u2081 : Type u_4} [_inst_12 : topological_space M\u2081] [_inst_13 : add_comm_monoid M\u2081] {M\u2082 : Type u_6} [_inst_16 : topological_space M\u2082] [_inst_17 : add_comm_monoid M\u2082] [_inst_22 : module R\u2081 M\u2081] [_inst_24 : module R\u2082 M\u2082] (e : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082), continuous \u21d1e", "decl_nm": "continuous_linear_equiv.continuous"}
{"formal_statement": "theorem inl_pushout_left_pushout_inr_iso_inv {C : Type u} [category_theory.category C]\n\t{W X Y Z : C} (f : X \u27f6 Y) (g : X \u27f6 Z) (g' : Z \u27f6 W) [category_theory.limits.has_pushout f g]\n\t[category_theory.limits.has_pushout category_theory.limits.pushout.inr g']\n\t[category_theory.limits.has_pushout f (g \u226b g')] :\n\tcategory_theory.limits.pushout.inl \u226b (category_theory.limits.pushout_left_pushout_inr_iso f g g').inv = category_theory.limits.pushout.inl \u226b category_theory.limits.pushout.inl", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] {W X Y Z : C} (f : X \u27f6 Y) (g : X \u27f6 Z) (g' : Z \u27f6 W) [_inst_2 : category_theory.limits.has_pushout f g] [_inst_3 : category_theory.limits.has_pushout category_theory.limits.pushout.inr g'] [_inst_4 : category_theory.limits.has_pushout f (g \u226b g')], category_theory.limits.pushout.inl \u226b (category_theory.limits.pushout_left_pushout_inr_iso f g g').inv = category_theory.limits.pushout.inl \u226b category_theory.limits.pushout.inl", "decl_nm": "category_theory.limits.inl_pushout_left_pushout_inr_iso_inv"}
{"formal_statement": "theorem subset_univ {\u03b1 : Type*} [fintype \u03b1] (s : finset \u03b1) :\n\ts \u2286 finset.univ", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : fintype \u03b1] (s : finset \u03b1), s \u2286 finset.univ", "decl_nm": "finset.subset_univ"}
{"formal_statement": "theorem to_quotient_map {\u03b1 \u03b2 : Type*} [topological_space \u03b1] [topological_space \u03b2]\n\t{f : \u03b1 \u2192 \u03b2} (open_map : is_open_map f) (cont : continuous f) (surj : function.surjective f) :\n\tquotient_map f", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : topological_space \u03b1] [_inst_2 : topological_space \u03b2] {f : \u03b1 \u2192 \u03b2}, is_open_map f \u2192 continuous f \u2192 function.surjective f \u2192 quotient_map f", "decl_nm": "is_open_map.to_quotient_map"}
{"formal_statement": "theorem filter_zero {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [decidable_pred p] :\n\tmultiset.filter p 0 = 0", "decl_tp": "\u2200 {\u03b1 : Type u_1} (p : \u03b1 \u2192 Prop) [_inst_1 : decidable_pred p], multiset.filter p 0 = 0", "decl_nm": "multiset.filter_zero"}
{"formal_statement": "theorem add_pow_char (R : Type u) [comm_semiring R] {p : \u2115} [fact (nat.prime p)]\n\t[char_p R p] (x y : R) :\n\t(x + y) ^ p = x ^ p + y ^ p", "decl_tp": "\u2200 (R : Type u) [_inst_1 : comm_semiring R] {p : \u2115} [_inst_2 : fact (nat.prime p)] [_inst_3 : char_p R p] (x y : R), (x + y) ^ p = x ^ p + y ^ p", "decl_nm": "add_pow_char"}
{"formal_statement": "theorem eq_empty_of_not_terminates {\u03b1 : Type u} {s : computation \u03b1} (H : \u00acs.terminates) :\n\ts = computation.empty \u03b1", "decl_tp": "\u2200 {\u03b1 : Type u} {s : computation \u03b1}, \u00acs.terminates \u2192 s = computation.empty \u03b1", "decl_nm": "computation.eq_empty_of_not_terminates"}
{"formal_statement": "theorem head_cons {\u03b1 : Type u} (a : \u03b1) (s : stream \u03b1) :\n\t(a::s).head = a", "decl_tp": "\u2200 {\u03b1 : Type u} (a : \u03b1) (s : stream \u03b1), (a::s).head = a", "decl_nm": "stream.head_cons"}
{"formal_statement": "theorem whiskering_obj_obj_obj (C : Type u) [category_theory.category C]\n\t{n : \u2115} (D : Type*) [category_theory.category D] (H : C \u2964 D) (F : (simplex_category.truncated n)\u1d52\u1d56 \u2964 C)\n\t(X : (simplex_category.truncated n)\u1d52\u1d56) :\n\t(((category_theory.simplicial_object.truncated.whiskering C D).obj H).obj F).obj X = H.obj (F.obj X)", "decl_tp": "\u2200 (C : Type u) [_inst_1 : category_theory.category C] {n : \u2115} (D : Type u_1) [_inst_2 : category_theory.category D] (H : C \u2964 D) (F : (simplex_category.truncated n)\u1d52\u1d56 \u2964 C) (X : (simplex_category.truncated n)\u1d52\u1d56), (((category_theory.simplicial_object.truncated.whiskering C D).obj H).obj F).obj X = H.obj (F.obj X)", "decl_nm": "category_theory.simplicial_object.truncated.whiskering_obj_obj_obj"}
{"formal_statement": "theorem map_mul_right {M : Type*} [comm_monoid M] {S : submonoid M} {N : Type*}\n\t[comm_monoid N] {P : Type*} [comm_monoid P] (f : S.localization_map N)\n\t{g : M \u2192* P} {T : submonoid P} (hy : \u2200 (y : \u21a5S), \u21d1g \u2191y \u2208 T) {Q : Type*}\n\t[comm_monoid Q] {k : T.localization_map Q} (z : N) :\n\t\u21d1(f.map hy k) z * \u21d1(k.to_map) (\u21d1g \u2191((f.sec z).snd)) = \u21d1(k.to_map) (\u21d1g (f.sec z).fst)", "decl_tp": "\u2200 {M : Type u_1} [_inst_1 : comm_monoid M] {S : submonoid M} {N : Type u_2} [_inst_2 : comm_monoid N] {P : Type u_3} [_inst_3 : comm_monoid P] (f : S.localization_map N) {g : M \u2192* P} {T : submonoid P} (hy : \u2200 (y : \u21a5S), \u21d1g \u2191y \u2208 T) {Q : Type u_4} [_inst_4 : comm_monoid Q] {k : T.localization_map Q} (z : N), \u21d1(f.map hy k) z * \u21d1(k.to_map) (\u21d1g \u2191((f.sec z).snd)) = \u21d1(k.to_map) (\u21d1g (f.sec z).fst)", "decl_nm": "submonoid.localization_map.map_mul_right"}
{"formal_statement": "theorem is_glb_univ {\u03b3 : Type w} [preorder \u03b3] [order_bot \u03b3] :\n\tis_glb set.univ \u22a5", "decl_tp": "\u2200 {\u03b3 : Type w} [_inst_3 : preorder \u03b3] [_inst_4 : order_bot \u03b3], is_glb set.univ \u22a5", "decl_nm": "is_glb_univ"}
{"formal_statement": "theorem add_measure {\u03b1 \u03b2 : Type*} {m : measurable_space \u03b1} {\u03bc \u03bd : measure_theory.measure \u03b1}\n\t[normed_group \u03b2] [measurable_space \u03b2] {f : \u03b1 \u2192 \u03b2} (h\u03bc : measure_theory.integrable f \u03bc)\n\t(h\u03bd : measure_theory.integrable f \u03bd) :\n\tmeasure_theory.integrable f (\u03bc + \u03bd)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {m : measurable_space \u03b1} {\u03bc \u03bd : measure_theory.measure \u03b1} [_inst_1 : normed_group \u03b2] [_inst_3 : measurable_space \u03b2] {f : \u03b1 \u2192 \u03b2}, measure_theory.integrable f \u03bc \u2192 measure_theory.integrable f \u03bd \u2192 measure_theory.integrable f (\u03bc + \u03bd)", "decl_nm": "measure_theory.integrable.add_measure"}
{"formal_statement": "theorem bit1_re (z : \u2102) :\n\t(bit1 z).re = bit1 z.re", "decl_tp": "\u2200 (z : \u2102), (bit1 z).re = bit1 z.re", "decl_nm": "complex.bit1_re"}
{"formal_statement": "theorem card_pow_degree_zero {Fq : Type*} [field Fq] [fintype Fq] :\n\t\u21d1polynomial.card_pow_degree 0 = 0", "decl_tp": "\u2200 {Fq : Type u_1} [_inst_1 : field Fq] [_inst_2 : fintype Fq], \u21d1polynomial.card_pow_degree 0 = 0", "decl_nm": "polynomial.card_pow_degree_zero"}
{"formal_statement": "theorem mem_vsub {G P : Type*} [add_group G] [T : add_torsor G P] {s t : set P}\n\t(g : G) :\n\tg \u2208 s -\u1d65 t \u2194 \u2203 (x y : P), x \u2208 s \u2227 y \u2208 t \u2227 x -\u1d65 y = g", "decl_tp": "\u2200 {G : Type u_1} {P : Type u_2} [_inst_1 : add_group G] [T : add_torsor G P] {s t : set P} (g : G), g \u2208 s -\u1d65 t \u2194 \u2203 (x y : P), x \u2208 s \u2227 y \u2208 t \u2227 x -\u1d65 y = g", "decl_nm": "set.mem_vsub"}
{"formal_statement": "theorem pow_comp {\u03b1 \u03b2 \u03b3 : Type*} [topological_space \u03b1] [topological_space \u03b2]\n\t[topological_space \u03b3] [monoid \u03b3] [has_continuous_mul \u03b3] (f : C(\u03b2, \u03b3))\n\t(n : \u2115) (g : C(\u03b1, \u03b2)) :\n\t(f ^ n).comp g = f.comp g ^ n", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {\u03b3 : Type u_3} [_inst_1 : topological_space \u03b1] [_inst_2 : topological_space \u03b2] [_inst_3 : topological_space \u03b3] [_inst_4 : monoid \u03b3] [_inst_5 : has_continuous_mul \u03b3] (f : C(\u03b2, \u03b3)) (n : \u2115) (g : C(\u03b1, \u03b2)), (f ^ n).comp g = f.comp g ^ n", "decl_nm": "continuous_map.pow_comp"}
{"formal_statement": "theorem map_nhds_eq {R\u2081 R\u2082 : Type*} [semiring R\u2081] [semiring R\u2082] {\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082}\n\t{\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081} [ring_hom_inv_pair \u03c3\u2081\u2082 \u03c3\u2082\u2081] [ring_hom_inv_pair \u03c3\u2082\u2081 \u03c3\u2081\u2082]\n\t{M\u2081 : Type*} [topological_space M\u2081] [add_comm_monoid M\u2081] {M\u2082 : Type*}\n\t[topological_space M\u2082] [add_comm_monoid M\u2082] [module R\u2081 M\u2081] [module R\u2082 M\u2082]\n\t(e : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) (x : M\u2081) :\n\tfilter.map \u21d1e (nhds x) = nhds (\u21d1e x)", "decl_tp": "\u2200 {R\u2081 : Type u_1} {R\u2082 : Type u_2} [_inst_1 : semiring R\u2081] [_inst_2 : semiring R\u2082] {\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082} {\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081} [_inst_4 : ring_hom_inv_pair \u03c3\u2081\u2082 \u03c3\u2082\u2081] [_inst_5 : ring_hom_inv_pair \u03c3\u2082\u2081 \u03c3\u2081\u2082] {M\u2081 : Type u_4} [_inst_12 : topological_space M\u2081] [_inst_13 : add_comm_monoid M\u2081] {M\u2082 : Type u_6} [_inst_16 : topological_space M\u2082] [_inst_17 : add_comm_monoid M\u2082] [_inst_22 : module R\u2081 M\u2081] [_inst_24 : module R\u2082 M\u2082] (e : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) (x : M\u2081), filter.map \u21d1e (nhds x) = nhds (\u21d1e x)", "decl_nm": "continuous_linear_equiv.map_nhds_eq"}
{"formal_statement": "theorem ext_iff {\u03b1 : Sort u_1} {\u03b2 : Sort u_2} {f g : \u03b1 \u21aa \u03b2} :\n\t(\u2200 (x : \u03b1), \u21d1f x = \u21d1g x) \u2194 f = g", "decl_tp": "\u2200 {\u03b1 : Sort u_1} {\u03b2 : Sort u_2} {f g : \u03b1 \u21aa \u03b2}, (\u2200 (x : \u03b1), \u21d1f x = \u21d1g x) \u2194 f = g", "decl_nm": "function.embedding.ext_iff"}
{"formal_statement": "theorem inf_eq (x y : punit) :\n\tx \u2293 y = punit.star", "decl_tp": "\u2200 (x y : punit), x \u2293 y = punit.star", "decl_nm": "punit.inf_eq"}
{"formal_statement": "theorem sdiff_eq_empty_iff_subset {\u03b1 : Type*} [decidable_eq \u03b1] {s t : finset \u03b1} :\n\ts \\ t = \u2205 \u2194 s \u2286 t", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : decidable_eq \u03b1] {s t : finset \u03b1}, s \\ t = \u2205 \u2194 s \u2286 t", "decl_nm": "finset.sdiff_eq_empty_iff_subset"}
{"formal_statement": "theorem ext {\u03b1 : Sort u_1} {p : \u03b1 \u2192 Prop} {a1 a2 : {x // p x}} (\u1fb0 : \u2191a1 = \u2191a2) :\n\ta1 = a2", "decl_tp": "\u2200 {\u03b1 : Sort u_1} {p : \u03b1 \u2192 Prop} {a1 a2 : {x // p x}}, \u2191a1 = \u2191a2 \u2192 a1 = a2", "decl_nm": "subtype.ext"}
{"formal_statement": "theorem singleton_sublist {\u03b1 : Type u} {a : \u03b1} {l : list \u03b1} :\n\t[a] <+ l \u2194 a \u2208 l", "decl_tp": "\u2200 {\u03b1 : Type u} {a : \u03b1} {l : list \u03b1}, [a] <+ l \u2194 a \u2208 l", "decl_nm": "list.singleton_sublist"}
{"formal_statement": "theorem zero_apply {R : Type u} {\u03b9 : Type v} {M\u2081 : \u03b9 \u2192 Type w\u2081} {M\u2082 : Type w\u2082}\n\t[decidable_eq \u03b9] [semiring R] [\u03a0 (i : \u03b9), add_comm_monoid (M\u2081 i)] [add_comm_monoid M\u2082]\n\t[\u03a0 (i : \u03b9), module R (M\u2081 i)] [module R M\u2082] [\u03a0 (i : \u03b9), topological_space (M\u2081 i)]\n\t[topological_space M\u2082] (m : \u03a0 (i : \u03b9), M\u2081 i) :\n\t\u21d10 m = 0", "decl_tp": "\u2200 {R : Type u} {\u03b9 : Type v} {M\u2081 : \u03b9 \u2192 Type w\u2081} {M\u2082 : Type w\u2082} [_inst_1 : decidable_eq \u03b9] [_inst_2 : semiring R] [_inst_4 : \u03a0 (i : \u03b9), add_comm_monoid (M\u2081 i)] [_inst_6 : add_comm_monoid M\u2082] [_inst_10 : \u03a0 (i : \u03b9), module R (M\u2081 i)] [_inst_12 : module R M\u2082] [_inst_16 : \u03a0 (i : \u03b9), topological_space (M\u2081 i)] [_inst_18 : topological_space M\u2082] (m : \u03a0 (i : \u03b9), M\u2081 i), \u21d10 m = 0", "decl_nm": "continuous_multilinear_map.zero_apply"}
{"formal_statement": "theorem mem_nhds_subtype {\u03b1 : Type u} [topological_space \u03b1] (s : set \u03b1)\n\t(a : {x // x \u2208 s}) (t : set {x // x \u2208 s}) :\n\tt \u2208 nhds a \u2194 \u2203 (u : set \u03b1) (H : u \u2208 nhds \u2191a), coe \u207b\u00b9' u \u2286 t", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : topological_space \u03b1] (s : set \u03b1) (a : {x // x \u2208 s}) (t : set {x // x \u2208 s}), t \u2208 nhds a \u2194 \u2203 (u : set \u03b1) (H : u \u2208 nhds \u2191a), coe \u207b\u00b9' u \u2286 t", "decl_nm": "mem_nhds_subtype"}
{"formal_statement": "theorem comp {\u03b1 \u03b2 \u03b3 \u03b9 : Type*} [uniform_space \u03b2] {F : \u03b9 \u2192 \u03b1 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2}\n\t{s : set \u03b1} {p : filter \u03b9} (h : tendsto_uniformly_on F f p s) :\n\t\u2200 (g : \u03b3 \u2192 \u03b1), tendsto_uniformly_on (\u03bb (n : \u03b9), F n \u2218 g) (f \u2218 g) p (g \u207b\u00b9' s)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {\u03b3 : Type u_3} {\u03b9 : Type u_4} [_inst_1 : uniform_space \u03b2] {F : \u03b9 \u2192 \u03b1 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2} {s : set \u03b1} {p : filter \u03b9}, tendsto_uniformly_on F f p s \u2192 \u2200 (g : \u03b3 \u2192 \u03b1), tendsto_uniformly_on (\u03bb (n : \u03b9), F n \u2218 g) (f \u2218 g) p (g \u207b\u00b9' s)", "decl_nm": "tendsto_uniformly_on.comp"}
{"formal_statement": "theorem compl_inter {\u03b1 : Type*} [fintype \u03b1] [decidable_eq \u03b1] (s t : finset \u03b1) :\n\t(s \u2229 t)\u1d9c = s\u1d9c \u222a t\u1d9c", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : fintype \u03b1] [_inst_2 : decidable_eq \u03b1] (s t : finset \u03b1), (s \u2229 t)\u1d9c = s\u1d9c \u222a t\u1d9c", "decl_nm": "finset.compl_inter"}
{"formal_statement": "theorem continuous_at_aeval {R A : Type*} [comm_semiring R] [semiring A]\n\t[algebra R A] [topological_space A] [topological_ring A] (p : polynomial R)\n\t{a : A} :\n\tcontinuous_at (\u03bb (x : A), \u21d1(polynomial.aeval x) p) a", "decl_tp": "\u2200 {R : Type u_1} {A : Type u_2} [_inst_1 : comm_semiring R] [_inst_2 : semiring A] [_inst_3 : algebra R A] [_inst_4 : topological_space A] [_inst_5 : topological_ring A] (p : polynomial R) {a : A}, continuous_at (\u03bb (x : A), \u21d1(polynomial.aeval x) p) a", "decl_nm": "polynomial.continuous_at_aeval"}
{"formal_statement": "theorem is_lub_image_le {\u03b1 : Type u} {\u03b2 : Type v} [preorder \u03b1] [preorder \u03b2]\n\t{f : \u03b1 \u2192 \u03b2} (Hf : monotone f) (Ha : is_lub s a) (Hb : is_lub (f '' s) b) :\n\t\u2200 {a : \u03b1} {s : set \u03b1},  \u2200 {b : \u03b2},  b \u2264 f a", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : preorder \u03b1] [_inst_2 : preorder \u03b2] {f : \u03b1 \u2192 \u03b2}, monotone f \u2192 \u2200 {a : \u03b1} {s : set \u03b1}, is_lub s a \u2192 \u2200 {b : \u03b2}, is_lub (f '' s) b \u2192 b \u2264 f a", "decl_nm": "monotone.is_lub_image_le"}
{"formal_statement": "theorem mono_left {X : Type*} [emetric_space X] {s t s' : set X} (h' : is_metric_separated s' t)\n\t(hs : s \u2286 s') :\n\tis_metric_separated s t", "decl_tp": "\u2200 {X : Type u_1} [_inst_1 : emetric_space X] {s t s' : set X}, is_metric_separated s' t \u2192 s \u2286 s' \u2192 is_metric_separated s t", "decl_nm": "is_metric_separated.mono_left"}
{"formal_statement": "theorem to_add_submonoid {\u03b9 : Type v} {M : Type*} [decidable_eq \u03b9] [add_comm_group M]\n\t(A : \u03b9 \u2192 add_subgroup M) :\n\tdirect_sum.add_subgroup_is_internal A \u2194 direct_sum.add_submonoid_is_internal (\u03bb (i : \u03b9), (A i).to_add_submonoid)", "decl_tp": "\u2200 {\u03b9 : Type v} {M : Type u_1} [_inst_3 : decidable_eq \u03b9] [_inst_4 : add_comm_group M] (A : \u03b9 \u2192 add_subgroup M), direct_sum.add_subgroup_is_internal A \u2194 direct_sum.add_submonoid_is_internal (\u03bb (i : \u03b9), (A i).to_add_submonoid)", "decl_nm": "direct_sum.add_subgroup_is_internal.to_add_submonoid"}
{"formal_statement": "theorem snorm'_norm {\u03b1 F : Type*} {m0 : measurable_space \u03b1} {q : \u211d} {\u03bc : measure_theory.measure \u03b1}\n\t[normed_group F] {f : \u03b1 \u2192 F} :\n\tmeasure_theory.snorm' (\u03bb (a : \u03b1), \u2225f a\u2225) q \u03bc = measure_theory.snorm' f q \u03bc", "decl_tp": "\u2200 {\u03b1 : Type u_1} {F : Type u_3} {m0 : measurable_space \u03b1} {q : \u211d} {\u03bc : measure_theory.measure \u03b1} [_inst_3 : normed_group F] {f : \u03b1 \u2192 F}, measure_theory.snorm' (\u03bb (a : \u03b1), \u2225f a\u2225) q \u03bc = measure_theory.snorm' f q \u03bc", "decl_nm": "measure_theory.snorm'_norm"}
{"formal_statement": "theorem add_neg_of_lt_of_neg {\u03b1 : Type*} [add_zero_class \u03b1] [preorder \u03b1]\n\t[covariant_class \u03b1 \u03b1 (function.swap has_add.add) has_lt.lt] {a b c : \u03b1}\n\t(ha : a < 0) (hb : b < c) :\n\ta + b < c", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : add_zero_class \u03b1] [_inst_2 : preorder \u03b1] [_inst_3 : covariant_class \u03b1 \u03b1 (function.swap has_add.add) has_lt.lt] {a b c : \u03b1}, a < 0 \u2192 b < c \u2192 a + b < c", "decl_nm": "right.add_neg_of_lt_of_neg"}
{"formal_statement": "theorem minimal_comm {a b c : \u2124} (_x : fermat_42.minimal a b c) :\n\tfermat_42.minimal b a c", "decl_tp": "\u2200 {a b c : \u2124}, fermat_42.minimal a b c \u2192 fermat_42.minimal b a c", "decl_nm": "fermat_42.minimal_comm"}
{"formal_statement": "theorem has_deriv_within_at_Iio_iff_Iic {\ud835\udd5c : Type u} [nondiscrete_normed_field \ud835\udd5c]\n\t{F : Type v} [normed_group F] [normed_space \ud835\udd5c F] {f : \ud835\udd5c \u2192 F} {f' : F}\n\t{x : \ud835\udd5c} [partial_order \ud835\udd5c] :\n\thas_deriv_within_at f f' (set.Iio x) x \u2194 has_deriv_within_at f f' (set.Iic x) x", "decl_tp": "\u2200 {\ud835\udd5c : Type u} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {F : Type v} [_inst_2 : normed_group F] [_inst_3 : normed_space \ud835\udd5c F] {f : \ud835\udd5c \u2192 F} {f' : F} {x : \ud835\udd5c} [_inst_6 : partial_order \ud835\udd5c], has_deriv_within_at f f' (set.Iio x) x \u2194 has_deriv_within_at f f' (set.Iic x) x", "decl_nm": "has_deriv_within_at_Iio_iff_Iic"}
{"formal_statement": "theorem op_inj {C : Type u\u2081} [quiver C] {X Y : C} :\n\tfunction.injective quiver.hom.op", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : quiver C] {X Y : C}, function.injective quiver.hom.op", "decl_nm": "quiver.hom.op_inj"}
{"formal_statement": "theorem coe_to_subring {K : Type u} [field K] (s : subfield K) :\n\t\u2191(s.to_subring) = \u2191s", "decl_tp": "\u2200 {K : Type u} [_inst_1 : field K] (s : subfield K), \u2191(s.to_subring) = \u2191s", "decl_nm": "subfield.coe_to_subring"}
{"formal_statement": "theorem mem_iff_nth {\u03b1 : Type u} {a : \u03b1} {l : list \u03b1} :\n\ta \u2208 l \u2194 \u2203 (n : \u2115), l.nth n = option.some a", "decl_tp": "\u2200 {\u03b1 : Type u} {a : \u03b1} {l : list \u03b1}, a \u2208 l \u2194 \u2203 (n : \u2115), l.nth n = option.some a", "decl_nm": "list.mem_iff_nth"}
{"formal_statement": "theorem sqrt {E : Type*} [normed_group E] [normed_space \u211d E] {f : E \u2192 \u211d}\n\t{s : set E} (hf : differentiable_on \u211d f s) (hx : x \u2208 s) :\n\t(\u2200 (x : E),  f x \u2260 0) \u2192 differentiable_on \u211d (\u03bb (y : E), real.sqrt (f y)) s", "decl_tp": "\u2200 {E : Type u_1} [_inst_1 : normed_group E] [_inst_2 : normed_space \u211d E] {f : E \u2192 \u211d} {s : set E}, differentiable_on \u211d f s \u2192 (\u2200 (x : E), x \u2208 s \u2192 f x \u2260 0) \u2192 differentiable_on \u211d (\u03bb (y : E), real.sqrt (f y)) s", "decl_nm": "differentiable_on.sqrt"}
{"formal_statement": "theorem sum_le_sum {\u03b9 : Type*} (f g : \u03b9 \u2192 cardinal) :\n\t(\u2200 (i : \u03b9), f i \u2264 g i) \u2192 cardinal.sum f \u2264 cardinal.sum g", "decl_tp": "\u2200 {\u03b9 : Type u_1} (f g : \u03b9 \u2192 cardinal), (\u2200 (i : \u03b9), f i \u2264 g i) \u2192 cardinal.sum f \u2264 cardinal.sum g", "decl_nm": "cardinal.sum_le_sum"}
{"formal_statement": "theorem le_min_fac' {m n : \u2115} :\n\tn = 1 \u2228 m \u2264 n.min_fac \u2194 \u2200 (p : \u2115), 2 \u2264 p \u2192 p \u2223 n \u2192 m \u2264 p", "decl_tp": "\u2200 {m n : \u2115}, n = 1 \u2228 m \u2264 n.min_fac \u2194 \u2200 (p : \u2115), 2 \u2264 p \u2192 p \u2223 n \u2192 m \u2264 p", "decl_nm": "nat.le_min_fac'"}
{"formal_statement": "theorem differentiable {X Y : Type*} [normed_group X] [normed_group Y]\n\t[normed_space \u211d X] [normed_space \u211d Y] {f : X \u2192 Y} (h : conformal f) :\n\tdifferentiable \u211d f", "decl_tp": "\u2200 {X : Type u_1} {Y : Type u_2} [_inst_1 : normed_group X] [_inst_2 : normed_group Y] [_inst_4 : normed_space \u211d X] [_inst_5 : normed_space \u211d Y] {f : X \u2192 Y}, conformal f \u2192 differentiable \u211d f", "decl_nm": "conformal.differentiable"}
{"formal_statement": "theorem exists_nhds_one_split {M : Type*} [topological_space M] [monoid M]\n\t[has_continuous_mul M] {s : set M} (hs : s \u2208 nhds 1) :\n\t(\u2203 (V : set M) (H : V \u2208 nhds 1), \u2200 (v : M), v \u2208 V \u2192 \u2200 (w : M), w \u2208 V \u2192 v * w \u2208 s)", "decl_tp": "\u2200 {M : Type u_4} [_inst_2 : topological_space M] [_inst_3 : monoid M] [_inst_4 : has_continuous_mul M] {s : set M}, s \u2208 nhds 1 \u2192 (\u2203 (V : set M) (H : V \u2208 nhds 1), \u2200 (v : M), v \u2208 V \u2192 \u2200 (w : M), w \u2208 V \u2192 v * w \u2208 s)", "decl_nm": "exists_nhds_one_split"}
{"formal_statement": "theorem add_eq_left {R : Type u} [linear_order R] \u2983x y : tropical R\u2984 (h : x \u2264 y) :\n\tx + y = x", "decl_tp": "\u2200 {R : Type u} [_inst_1 : linear_order R] \u2983x y : tropical R\u2984, x \u2264 y \u2192 x + y = x", "decl_nm": "tropical.add_eq_left"}
{"formal_statement": "theorem of_alg_hom (F : Type*) {E : Type*} [field F] [field E] [algebra F E]\n\t(E' : Type*) [field E'] [algebra F E'] :\n\t(E \u2192\u2090[F] E') \u2192 \u2200 [is_separable F E'], is_separable F E", "decl_tp": "\u2200 (F : Type u_1) {E : Type u_3} [_inst_1 : field F] [_inst_3 : field E] [_inst_5 : algebra F E] (E' : Type u_2) [_inst_8 : field E'] [_inst_9 : algebra F E'], (E \u2192\u2090[F] E') \u2192 \u2200 [_inst_10 : is_separable F E'], is_separable F E", "decl_nm": "is_separable.of_alg_hom"}
{"formal_statement": "theorem symm_mk {R : Type u} {A\u2081 : Type v} {A\u2082 : Type w} [comm_semiring R]\n\t[semiring A\u2081] [semiring A\u2082] [algebra R A\u2081] [algebra R A\u2082] (f : A\u2081 \u2192 A\u2082)\n\t(f' : A\u2082 \u2192 A\u2081) (h\u2081 : function.left_inverse f' f) (h\u2082 : function.right_inverse f' f)\n\t(h\u2083 : \u2200 (x y : A\u2081), f (x * y) = f x * f y) (h\u2084 : \u2200 (x y : A\u2081), f (x + y) = f x + f y)\n\t(h\u2085 : \u2200 (r : R), f (\u21d1(algebra_map R A\u2081) r) = \u21d1(algebra_map R A\u2082) r) :\n\t{to_fun := f, inv_fun := f', left_inv := h\u2081, right_inv := h\u2082, map_mul' := h\u2083, map_add' := h\u2084, commutes' := h\u2085}.symm = {to_fun := f', inv_fun := f, left_inv := _, right_inv := _, map_mul' := _, map_add' := _, commutes' := _}", "decl_tp": "\u2200 {R : Type u} {A\u2081 : Type v} {A\u2082 : Type w} [_inst_1 : comm_semiring R] [_inst_2 : semiring A\u2081] [_inst_3 : semiring A\u2082] [_inst_5 : algebra R A\u2081] [_inst_6 : algebra R A\u2082] (f : A\u2081 \u2192 A\u2082) (f' : A\u2082 \u2192 A\u2081) (h\u2081 : function.left_inverse f' f) (h\u2082 : function.right_inverse f' f) (h\u2083 : \u2200 (x y : A\u2081), f (x * y) = f x * f y) (h\u2084 : \u2200 (x y : A\u2081), f (x + y) = f x + f y) (h\u2085 : \u2200 (r : R), f (\u21d1(algebra_map R A\u2081) r) = \u21d1(algebra_map R A\u2082) r), {to_fun := f, inv_fun := f', left_inv := h\u2081, right_inv := h\u2082, map_mul' := h\u2083, map_add' := h\u2084, commutes' := h\u2085}.symm = {to_fun := f', inv_fun := f, left_inv := _, right_inv := _, map_mul' := _, map_add' := _, commutes' := _}", "decl_nm": "alg_equiv.symm_mk"}
{"formal_statement": "theorem untrop_zpow {R : Type u} [add_group R] (x : tropical R) (n : \u2124) :\n\ttropical.untrop (x ^ n) = n \u2022 tropical.untrop x", "decl_tp": "\u2200 {R : Type u} [_inst_1 : add_group R] (x : tropical R) (n : \u2124), tropical.untrop (x ^ n) = n \u2022 tropical.untrop x", "decl_nm": "tropical.untrop_zpow"}
{"formal_statement": "theorem associator_hom_f {C : Type u\u2081} [category_theory.category C] [category_theory.monoidal_category C]\n\t(X Y Z : category_theory.center C) :\n\t(\u03b1_ X Y Z).hom.f = (\u03b1_ X.fst Y.fst Z.fst).hom", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] [_inst_2 : category_theory.monoidal_category C] (X Y Z : category_theory.center C), (\u03b1_ X Y Z).hom.f = (\u03b1_ X.fst Y.fst Z.fst).hom", "decl_nm": "category_theory.center.associator_hom_f"}
{"formal_statement": "theorem equiv_functor_obj {C : Type u} [category_theory.category C] (F : category_theory.discrete punit \u2964 C) :\n\tcategory_theory.functor.equiv.functor.obj F = F.obj punit.star", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] (F : category_theory.discrete punit \u2964 C), category_theory.functor.equiv.functor.obj F = F.obj punit.star", "decl_nm": "category_theory.functor.equiv_functor_obj"}
{"formal_statement": "theorem strict_convex_interval {\ud835\udd5c \u03b2 : Type*} [ordered_semiring \ud835\udd5c] [topological_space \u03b2]\n\t[linear_ordered_cancel_add_comm_monoid \u03b2] [order_topology \u03b2] [module \ud835\udd5c \u03b2]\n\t[ordered_smul \ud835\udd5c \u03b2] (r s : \u03b2) :\n\tstrict_convex \ud835\udd5c (set.interval r s)", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} {\u03b2 : Type u_4} [_inst_1 : ordered_semiring \ud835\udd5c] [_inst_8 : topological_space \u03b2] [_inst_9 : linear_ordered_cancel_add_comm_monoid \u03b2] [_inst_10 : order_topology \u03b2] [_inst_11 : module \ud835\udd5c \u03b2] [_inst_12 : ordered_smul \ud835\udd5c \u03b2] (r s : \u03b2), strict_convex \ud835\udd5c (set.interval r s)", "decl_nm": "strict_convex_interval"}
{"formal_statement": "theorem finite_of_finite_mul_left {\u03b1 : Type*} [comm_monoid \u03b1] {a b c : \u03b1}\n\t(_x : multiplicity.finite a (b * c)) :\n\tmultiplicity.finite a c", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : comm_monoid \u03b1] {a b c : \u03b1}, multiplicity.finite a (b * c) \u2192 multiplicity.finite a c", "decl_nm": "multiplicity.finite_of_finite_mul_left"}
{"formal_statement": "theorem counit_surjective (R : Type*) [comm_ring R] :\n\tfunction.surjective \u21d1(mv_polynomial.counit R)", "decl_tp": "\u2200 (R : Type u_3) [_inst_3 : comm_ring R], function.surjective \u21d1(mv_polynomial.counit R)", "decl_nm": "mv_polynomial.counit_surjective"}
{"formal_statement": "theorem ring_quot_mk_alg_hom_free_algebra_\u03b9_eq_\u03b9 (R : Type*) [comm_semiring R]\n\t{M : Type*} [add_comm_monoid M] [module R M] (m : M) :\n\t\u21d1(ring_quot.mk_alg_hom R (tensor_algebra.rel R M)) (free_algebra.\u03b9 R m) = \u21d1(tensor_algebra.\u03b9 R) m", "decl_tp": "\u2200 (R : Type u_1) [_inst_1 : comm_semiring R] {M : Type u_2} [_inst_2 : add_comm_monoid M] [_inst_3 : module R M] (m : M), \u21d1(ring_quot.mk_alg_hom R (tensor_algebra.rel R M)) (free_algebra.\u03b9 R m) = \u21d1(tensor_algebra.\u03b9 R) m", "decl_nm": "tensor_algebra.ring_quot_mk_alg_hom_free_algebra_\u03b9_eq_\u03b9"}
{"formal_statement": "theorem pure_seq {\u03b1 \u03b2 : Type u} {f : \u03b1 \u2192 \u03b2} {x : free_magma \u03b1} :\n\thas_pure.pure f <*> x = f <$> x", "decl_tp": "\u2200 {\u03b1 \u03b2 : Type u} {f : \u03b1 \u2192 \u03b2} {x : free_magma \u03b1}, has_pure.pure f <*> x = f <$> x", "decl_nm": "free_magma.pure_seq"}
{"formal_statement": "theorem range {\u03b1 \u03b9 : Type*} [semilattice_inf \u03b1] [order_bot \u03b1] {s : set \u03b9}\n\t{f : \u03b9 \u2192 \u03b1} (g : \u21a5s \u2192 \u03b9) (ht : s.pairwise_disjoint f) :\n\t(\u2200 (i : \u21a5s), f (g i) \u2264 f \u2191i) \u2192  (set.range g).pairwise_disjoint f", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b9 : Type u_2} [_inst_1 : semilattice_inf \u03b1] [_inst_2 : order_bot \u03b1] {s : set \u03b9} {f : \u03b9 \u2192 \u03b1} (g : \u21a5s \u2192 \u03b9), (\u2200 (i : \u21a5s), f (g i) \u2264 f \u2191i) \u2192 s.pairwise_disjoint f \u2192 (set.range g).pairwise_disjoint f", "decl_nm": "set.pairwise_disjoint.range"}
{"formal_statement": "theorem ker_coprod_of_disjoint_range {R : Type*} [ring R] {M : Type*} [topological_space M]\n\t[add_comm_group M] {M\u2082 : Type*} [topological_space M\u2082] [add_comm_group M\u2082]\n\t{M\u2083 : Type*} [topological_space M\u2083] [add_comm_group M\u2083] [module R M] [module R M\u2082]\n\t[module R M\u2083] [has_continuous_add M\u2083] (f : M \u2192L[R] M\u2083) (g : M\u2082 \u2192L[R] M\u2083)\n\t(hd : disjoint f.range g.range) :\n\t(f.coprod g).ker = f.ker.prod g.ker", "decl_tp": "\u2200 {R : Type u_1} [_inst_1 : ring R] {M : Type u_3} [_inst_3 : topological_space M] [_inst_4 : add_comm_group M] {M\u2082 : Type u_4} [_inst_5 : topological_space M\u2082] [_inst_6 : add_comm_group M\u2082] {M\u2083 : Type u_5} [_inst_7 : topological_space M\u2083] [_inst_8 : add_comm_group M\u2083] [_inst_11 : module R M] [_inst_13 : module R M\u2082] [_inst_14 : module R M\u2083] [_inst_16 : has_continuous_add M\u2083] (f : M \u2192L[R] M\u2083) (g : M\u2082 \u2192L[R] M\u2083), disjoint f.range g.range \u2192 (f.coprod g).ker = f.ker.prod g.ker", "decl_nm": "continuous_linear_map.ker_coprod_of_disjoint_range"}
{"formal_statement": "theorem coe_smul {\u03b1 : Type*} [measurable_space \u03b1] (j : measure_theory.jordan_decomposition \u03b1)\n\t(r : nnreal) :\n\t\u2191r \u2022 j = r \u2022 j", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : measurable_space \u03b1] (j : measure_theory.jordan_decomposition \u03b1) (r : nnreal), \u2191r \u2022 j = r \u2022 j", "decl_nm": "measure_theory.jordan_decomposition.coe_smul"}
{"formal_statement": "theorem le_iff_forall_one_lt_le_mul {\u03b1 : Type u} [group \u03b1] [linear_order \u03b1]\n\t[covariant_class \u03b1 \u03b1 has_mul.mul has_le.le] [densely_ordered \u03b1] {a b : \u03b1} :\n\ta \u2264 b \u2194 \u2200 (\u03b5 : \u03b1), 1 < \u03b5 \u2192 a \u2264 b * \u03b5", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : group \u03b1] [_inst_2 : linear_order \u03b1] [_inst_3 : covariant_class \u03b1 \u03b1 has_mul.mul has_le.le] [_inst_4 : densely_ordered \u03b1] {a b : \u03b1}, a \u2264 b \u2194 \u2200 (\u03b5 : \u03b1), 1 < \u03b5 \u2192 a \u2264 b * \u03b5", "decl_nm": "le_iff_forall_one_lt_le_mul"}
{"formal_statement": "theorem image_eq_of_maps_to {\u03b1 : Type u} {\u03b2 : Type v} {s : set \u03b1} {t : set \u03b2}\n\t{f : \u03b1 \u2192 \u03b2} (h\u2081 : set.surj_on f s t) (h\u2082 : set.maps_to f s t) :\n\tf '' s = t", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {s : set \u03b1} {t : set \u03b2} {f : \u03b1 \u2192 \u03b2}, set.surj_on f s t \u2192 set.maps_to f s t \u2192 f '' s = t", "decl_nm": "set.surj_on.image_eq_of_maps_to"}
{"formal_statement": "theorem bot_or_nontrivial {M : Type*} [add_zero_class M] (S : add_submonoid M) :\n\tS = \u22a5 \u2228 nontrivial \u21a5S", "decl_tp": "\u2200 {M : Type u_1} [_inst_1 : add_zero_class M] (S : add_submonoid M), S = \u22a5 \u2228 nontrivial \u21a5S", "decl_nm": "add_submonoid.bot_or_nontrivial"}
{"formal_statement": "theorem neg_one_zsmul_add {G : Type w} [add_group G] (a b : G) :\n\t(-1) \u2022 (a + b) = (-1) \u2022 b + (-1) \u2022 a", "decl_tp": "\u2200 {G : Type w} [_inst_1 : add_group G] (a b : G), (-1) \u2022 (a + b) = (-1) \u2022 b + (-1) \u2022 a", "decl_nm": "neg_one_zsmul_add"}
{"formal_statement": "theorem mem_mk {\u03b1 : Type*} {a : \u03b1} {s : multiset \u03b1} {nd : s.nodup} :\n\ta \u2208 {val := s, nodup := nd} \u2194 a \u2208 s", "decl_tp": "\u2200 {\u03b1 : Type u_1} {a : \u03b1} {s : multiset \u03b1} {nd : s.nodup}, a \u2208 {val := s, nodup := nd} \u2194 a \u2208 s", "decl_nm": "finset.mem_mk"}
{"formal_statement": "theorem bot_sub_top :\n\t\u22a5 - \u22a4 = \u22a5", "decl_tp": "\u22a5 - \u22a4 = \u22a5", "decl_nm": "ereal.bot_sub_top"}
{"formal_statement": "theorem zneg_succ (n : znum) :\n\t-n.succ = (-n).pred", "decl_tp": "\u2200 (n : znum), -n.succ = (-n).pred", "decl_nm": "znum.zneg_succ"}
{"formal_statement": "theorem tsum_smul_const {\u03b1 \u03b2 R : Type*} [semiring R] [topological_space R]\n\t[topological_space \u03b1] [add_comm_monoid \u03b1] [module R \u03b1] [has_continuous_smul R \u03b1]\n\t{f : \u03b2 \u2192 R} [t2_space \u03b1] {a : \u03b1} (hf : summable f) :\n\t\u2211' (z : \u03b2), f z \u2022 a = (\u2211' (z : \u03b2), f z) \u2022 a", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {R : Type u_5} [_inst_1 : semiring R] [_inst_2 : topological_space R] [_inst_3 : topological_space \u03b1] [_inst_4 : add_comm_monoid \u03b1] [_inst_5 : module R \u03b1] [_inst_6 : has_continuous_smul R \u03b1] {f : \u03b2 \u2192 R} [_inst_7 : t2_space \u03b1] {a : \u03b1}, summable f \u2192 \u2211' (z : \u03b2), f z \u2022 a = (\u2211' (z : \u03b2), f z) \u2022 a", "decl_nm": "tsum_smul_const"}
{"formal_statement": "theorem open_embedding_sigma_mk {\u03b9 : Type*} {\u03c3 : \u03b9 \u2192 Type*} [\u03a0 (i : \u03b9), topological_space (\u03c3 i)]\n\t{i : \u03b9} :\n\topen_embedding (sigma.mk i)", "decl_tp": "\u2200 {\u03b9 : Type u_1} {\u03c3 : \u03b9 \u2192 Type u_2} [_inst_1 : \u03a0 (i : \u03b9), topological_space (\u03c3 i)] {i : \u03b9}, open_embedding (sigma.mk i)", "decl_nm": "open_embedding_sigma_mk"}
{"formal_statement": "theorem add_one_le_two_mul {\u03b1 : Type u} [preorder \u03b1] [semiring \u03b1] [covariant_class \u03b1 \u03b1 has_add.add has_le.le]\n\t{a : \u03b1} (a1 : 1 \u2264 a) :\n\ta + 1 \u2264 2 * a", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : preorder \u03b1] [_inst_2 : semiring \u03b1] [_inst_3 : covariant_class \u03b1 \u03b1 has_add.add has_le.le] {a : \u03b1}, 1 \u2264 a \u2192 a + 1 \u2264 2 * a", "decl_nm": "add_one_le_two_mul"}
{"formal_statement": "theorem is_o_neg_left {\u03b1 F E' : Type*} [has_norm F] [normed_group E'] {g : \u03b1 \u2192 F}\n\t{f' : \u03b1 \u2192 E'} {l : filter \u03b1} :\n\tasymptotics.is_o (\u03bb (x : \u03b1), -f' x) g l \u2194 asymptotics.is_o f' g l", "decl_tp": "\u2200 {\u03b1 : Type u_1} {F : Type u_4} {E' : Type u_6} [_inst_2 : has_norm F] [_inst_4 : normed_group E'] {g : \u03b1 \u2192 F} {f' : \u03b1 \u2192 E'} {l : filter \u03b1}, asymptotics.is_o (\u03bb (x : \u03b1), -f' x) g l \u2194 asymptotics.is_o f' g l", "decl_nm": "asymptotics.is_o_neg_left"}
{"formal_statement": "theorem le_def {\u03b1 : Type*} {t s : topological_space \u03b1} :\n\tt \u2264 s \u2194 s.is_open \u2264 t.is_open", "decl_tp": "\u2200 {\u03b1 : Type u_1} {t s : topological_space \u03b1}, t \u2264 s \u2194 s.is_open \u2264 t.is_open", "decl_nm": "topological_space.le_def"}
{"formal_statement": "theorem dual {\u03b1 : Type u} [has_lt \u03b1] {a b : \u03b1} :\n\tb < a \u2192 \u21d1order_dual.to_dual a < \u21d1order_dual.to_dual b", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : has_lt \u03b1] {a b : \u03b1}, b < a \u2192 \u21d1order_dual.to_dual a < \u21d1order_dual.to_dual b", "decl_nm": "has_lt.lt.dual"}
{"formal_statement": "theorem map_mk' {G : Type u} [add_group G] (N : add_subgroup G) [nN : N.normal]\n\t{H : Type v} [add_group H] (M : add_subgroup H) [M.normal] (f : G \u2192+ H)\n\t(h : N \u2264 add_subgroup.comap f M) (x : G) :\n\t\u21d1(quotient_add_group.map N M f h) (\u21d1(quotient_add_group.mk' N) x) = \u2191(\u21d1f x)", "decl_tp": "\u2200 {G : Type u} [_inst_1 : add_group G] (N : add_subgroup G) [nN : N.normal] {H : Type v} [_inst_2 : add_group H] (M : add_subgroup H) [_inst_3 : M.normal] (f : G \u2192+ H) (h : N \u2264 add_subgroup.comap f M) (x : G), \u21d1(quotient_add_group.map N M f h) (\u21d1(quotient_add_group.mk' N) x) = \u2191(\u21d1f x)", "decl_nm": "quotient_add_group.map_mk'"}
{"formal_statement": "theorem orelse_eq_some {\u03b1 : Type*} (o o' : option \u03b1) (x : \u03b1) :\n\t(o <|> o') = option.some x \u2194 o = option.some x \u2228 o = option.none \u2227 o' = option.some x", "decl_tp": "\u2200 {\u03b1 : Type u_1} (o o' : option \u03b1) (x : \u03b1), (o <|> o') = option.some x \u2194 o = option.some x \u2228 o = option.none \u2227 o' = option.some x", "decl_nm": "option.orelse_eq_some"}
{"formal_statement": "theorem closure_empty_iff {\u03b1 : Type u} [topological_space \u03b1] (s : set \u03b1) :\n\tclosure s = \u2205 \u2194 s = \u2205", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : topological_space \u03b1] (s : set \u03b1), closure s = \u2205 \u2194 s = \u2205", "decl_nm": "closure_empty_iff"}
{"formal_statement": "theorem left_inverse_range_splitting {\u03b1 : Type u} {\u03b2 : Type v} (f : \u03b1 \u2192 \u03b2) :\n\tfunction.left_inverse (set.range_factorization f) (set.range_splitting f)", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} (f : \u03b1 \u2192 \u03b2), function.left_inverse (set.range_factorization f) (set.range_splitting f)", "decl_nm": "set.left_inverse_range_splitting"}
{"formal_statement": "theorem nat_trailing_degree_nat_cast {R : Type u} [semiring R] (n : \u2115) :\n\t\u2191n.nat_trailing_degree = 0", "decl_tp": "\u2200 {R : Type u} [_inst_1 : semiring R] (n : \u2115), \u2191n.nat_trailing_degree = 0", "decl_nm": "polynomial.nat_trailing_degree_nat_cast"}
{"formal_statement": "theorem concat_eq_append {\u03b1 : Type u} (a : \u03b1) (l : list \u03b1) :\n\tl.concat a = l ++ [a]", "decl_tp": "\u2200 {\u03b1 : Type u} (a : \u03b1) (l : list \u03b1), l.concat a = l ++ [a]", "decl_nm": "list.concat_eq_append"}
{"formal_statement": "theorem Inter_option {\u03b1 \u03b9 : Type*} (s : option \u03b9 \u2192 set \u03b1) :\n\t(\u22c2 (o : option \u03b9), s o) = s option.none \u2229 \u22c2 (i : \u03b9), s (option.some i)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b9 : Type u_2} (s : option \u03b9 \u2192 set \u03b1), (\u22c2 (o : option \u03b9), s o) = s option.none \u2229 \u22c2 (i : \u03b9), s (option.some i)", "decl_nm": "set.Inter_option"}
{"formal_statement": "theorem choice_mem_aux (x : Set) (h : \u2205 \u2209 x) (yx : y \u2208 x) :\n\t\u2200 (y : Set),  classical.epsilon (\u03bb (z : Set), z \u2208 y) \u2208 y", "decl_tp": "\u2200 (x : Set), \u2205 \u2209 x \u2192 \u2200 (y : Set), y \u2208 x \u2192 classical.epsilon (\u03bb (z : Set), z \u2208 y) \u2208 y", "decl_nm": "Set.choice_mem_aux"}
{"formal_statement": "theorem inter_right_idem {\u03b1 : Type*} [decidable_eq \u03b1] (s t : finset \u03b1) :\n\ts \u2229 t \u2229 t = s \u2229 t", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : decidable_eq \u03b1] (s t : finset \u03b1), s \u2229 t \u2229 t = s \u2229 t", "decl_nm": "finset.inter_right_idem"}
{"formal_statement": "theorem add {\u03b1 \u03b2 : Type*} {m m0 : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1}\n\t[measurable_space \u03b2] {f g : \u03b1 \u2192 \u03b2} [has_add \u03b2] [has_measurable_add\u2082 \u03b2]\n\t(hf : measure_theory.ae_measurable' m f \u03bc) (hg : measure_theory.ae_measurable' m g \u03bc) :\n\tmeasure_theory.ae_measurable' m (f + g) \u03bc", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {m m0 : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} [_inst_1 : measurable_space \u03b2] {f g : \u03b1 \u2192 \u03b2} [_inst_3 : has_add \u03b2] [_inst_4 : has_measurable_add\u2082 \u03b2], measure_theory.ae_measurable' m f \u03bc \u2192 measure_theory.ae_measurable' m g \u03bc \u2192 measure_theory.ae_measurable' m (f + g) \u03bc", "decl_nm": "measure_theory.ae_measurable'.add"}
{"formal_statement": "theorem induced_topology_pure {\u03b1 : Type u} :\n\ttopological_space.induced has_pure.pure ultrafilter.topological_space = \u22a5", "decl_tp": "\u2200 {\u03b1 : Type u}, topological_space.induced has_pure.pure ultrafilter.topological_space = \u22a5", "decl_nm": "induced_topology_pure"}
{"formal_statement": "theorem distortion_of_const {\u03b9 : Type*} {I : box_integral.box \u03b9} (\u03c0 : box_integral.tagged_prepartition I)\n\t[fintype \u03b9] {c : nnreal} (h\u2081 : \u03c0.to_prepartition.boxes.nonempty) :\n\t(\u2200 (J : box_integral.box \u03b9), J \u2208 \u03c0 \u2192 J.distortion = c) \u2192 \u03c0.distortion = c", "decl_tp": "\u2200 {\u03b9 : Type u_1} {I : box_integral.box \u03b9} (\u03c0 : box_integral.tagged_prepartition I) [_inst_1 : fintype \u03b9] {c : nnreal}, \u03c0.to_prepartition.boxes.nonempty \u2192 (\u2200 (J : box_integral.box \u03b9), J \u2208 \u03c0 \u2192 J.distortion = c) \u2192 \u03c0.distortion = c", "decl_nm": "box_integral.tagged_prepartition.distortion_of_const"}
{"formal_statement": "theorem eq_of_forall_edist_le {\u03b3 : Type w} [emetric_space \u03b3] {x y : \u03b3} :\n\t(\u2200 (\u03b5 : ennreal), \u03b5 > 0 \u2192 has_edist.edist x y \u2264 \u03b5) \u2192 x = y", "decl_tp": "\u2200 {\u03b3 : Type w} [_inst_2 : emetric_space \u03b3] {x y : \u03b3}, (\u2200 (\u03b5 : ennreal), \u03b5 > 0 \u2192 has_edist.edist x y \u2264 \u03b5) \u2192 x = y", "decl_nm": "eq_of_forall_edist_le"}
{"formal_statement": "theorem nat_div2 :\n\tprimrec nat.div2", "decl_tp": "primrec nat.div2", "decl_nm": "primrec.nat_div2"}
{"formal_statement": "theorem eq_iff_classes_eq {\u03b1 : Type*} {r\u2081 r\u2082 : setoid \u03b1} :\n\tr\u2081 = r\u2082 \u2194 \u2200 (x : \u03b1), {y : \u03b1 | r\u2081.rel x y} = {y : \u03b1 | r\u2082.rel x y}", "decl_tp": "\u2200 {\u03b1 : Type u_1} {r\u2081 r\u2082 : setoid \u03b1}, r\u2081 = r\u2082 \u2194 \u2200 (x : \u03b1), {y : \u03b1 | r\u2081.rel x y} = {y : \u03b1 | r\u2082.rel x y}", "decl_nm": "setoid.eq_iff_classes_eq"}
{"formal_statement": "theorem ext_ring_iff {M' R : Type*1} [semiring R] [add_monoid M'] [distrib_mul_action R M']\n\t{f g : R \u2192+[R] M'} :\n\tf = g \u2194 \u21d1f 1 = \u21d1g 1", "decl_tp": "\u2200 {M' : Type u_1} {R : Type u_11} [_inst_15 : semiring R] [_inst_26 : add_monoid M'] [_inst_27 : distrib_mul_action R M'] {f g : R \u2192+[R] M'}, f = g \u2194 \u21d1f 1 = \u21d1g 1", "decl_nm": "distrib_mul_action_hom.ext_ring_iff"}
{"formal_statement": "theorem append1_cases_append1 {n : \u2115} {C : typevec (n + 1) \u2192 Sort u} (H : \u03a0 (\u03b1 : typevec n)\n\t(\u03b2 : Type*), C (\u03b1 ::: \u03b2)) (\u03b1 : typevec n) (\u03b2 : Type*) :\n\ttypevec.append1_cases H (\u03b1 ::: \u03b2) = H \u03b1 \u03b2", "decl_tp": "\u2200 {n : \u2115} {C : typevec (n + 1) \u2192 Sort u} (H : \u03a0 (\u03b1 : typevec n) (\u03b2 : Type u_1), C (\u03b1 ::: \u03b2)) (\u03b1 : typevec n) (\u03b2 : Type u_1), typevec.append1_cases H (\u03b1 ::: \u03b2) = H \u03b1 \u03b2", "decl_nm": "typevec.append1_cases_append1"}
{"formal_statement": "theorem of_stream_cons {\u03b1 : Type u} (a : \u03b1) (s : stream \u03b1) :\n\tseq.of_stream (a::s) = seq.cons a (seq.of_stream s)", "decl_tp": "\u2200 {\u03b1 : Type u} (a : \u03b1) (s : stream \u03b1), seq.of_stream (a::s) = seq.cons a (seq.of_stream s)", "decl_nm": "seq.of_stream_cons"}
{"formal_statement": "theorem star_apply {I : Type u} {f : I \u2192 Type v} [\u03a0 (i : I), has_star (f i)]\n\t(x : \u03a0 (i : I), f i) (i : I) :\n\thas_star.star x i = has_star.star (x i)", "decl_tp": "\u2200 {I : Type u} {f : I \u2192 Type v} [_inst_1 : \u03a0 (i : I), has_star (f i)] (x : \u03a0 (i : I), f i) (i : I), has_star.star x i = has_star.star (x i)", "decl_nm": "pi.star_apply"}
{"formal_statement": "theorem lift_aux_unique {\u03b1 : Type u} {\u03b2 : Type v} [has_mul \u03b2] (F : mul_hom (free_magma \u03b1) \u03b2) :\n\t\u21d1F = free_magma.lift_aux (\u21d1F \u2218 free_magma.of)", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : has_mul \u03b2] (F : mul_hom (free_magma \u03b1) \u03b2), \u21d1F = free_magma.lift_aux (\u21d1F \u2218 free_magma.of)", "decl_nm": "free_magma.lift_aux_unique"}
{"formal_statement": "theorem is_local_max_on {\u03b1 : Type u} {\u03b2 : Type v} [topological_space \u03b1]\n\t[preorder \u03b2] {s : set \u03b1} {f g : \u03b1 \u2192 \u03b2} {a : \u03b1} (hle : g \u2264\u1da0[nhds_within a s] f)\n\t(hfga : f a = g a) (h : is_local_max_on f s a) :\n\tis_local_max_on g s a", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : topological_space \u03b1] [_inst_2 : preorder \u03b2] {s : set \u03b1} {f g : \u03b1 \u2192 \u03b2} {a : \u03b1}, g \u2264\u1da0[nhds_within a s] f \u2192 f a = g a \u2192 is_local_max_on f s a \u2192 is_local_max_on g s a", "decl_nm": "filter.eventually_le.is_local_max_on"}
{"formal_statement": "theorem mono {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c] {E : Type*} [normed_group E]\n\t[normed_space \ud835\udd5c E] {H : Type*} [topological_space H] {I : model_with_corners \ud835\udd5c E H}\n\t{M : Type*} [topological_space M] [charted_space H M] {x : M} {s t : set M}\n\t(h : unique_mdiff_within_at I s x) (st : s \u2286 t) :\n\tunique_mdiff_within_at I t x", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {H : Type u_3} [_inst_4 : topological_space H] {I : model_with_corners \ud835\udd5c E H} {M : Type u_4} [_inst_5 : topological_space M] [_inst_6 : charted_space H M] {x : M} {s t : set M}, unique_mdiff_within_at I s x \u2192 s \u2286 t \u2192 unique_mdiff_within_at I t x", "decl_nm": "unique_mdiff_within_at.mono"}
{"formal_statement": "theorem of_epi_section {C : Type u\u2081} [category_theory.category C] {X Y : C}\n\t{f : X \u27f6 Y} [category_theory.split_epi f] [category_theory.epi (category_theory.section_ f)] :\n\tcategory_theory.is_iso f", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {X Y : C} {f : X \u27f6 Y} [_inst_2 : category_theory.split_epi f] [_inst_3 : category_theory.epi (category_theory.section_ f)], category_theory.is_iso f", "decl_nm": "category_theory.is_iso.of_epi_section"}
{"formal_statement": "theorem mul_le_mul_left {R : Type u} [comm_semiring R] {A : Type v} [semiring A]\n\t[algebra R A] {M N P : submodule R A} (h : M \u2264 N) :\n\tM * P \u2264 N * P", "decl_tp": "\u2200 {R : Type u} [_inst_1 : comm_semiring R] {A : Type v} [_inst_2 : semiring A] [_inst_3 : algebra R A] {M N P : submodule R A}, M \u2264 N \u2192 M * P \u2264 N * P", "decl_nm": "submodule.mul_le_mul_left"}
{"formal_statement": "theorem prod_inf_prod {R : Type u} {A : Type v} {B : Type w} [comm_semiring R]\n\t[semiring A] [algebra R A] [semiring B] [algebra R B] {S T : subalgebra R A}\n\t{S\u2081 T\u2081 : subalgebra R B} :\n\tS.prod S\u2081 \u2293 T.prod T\u2081 = (S \u2293 T).prod (S\u2081 \u2293 T\u2081)", "decl_tp": "\u2200 {R : Type u} {A : Type v} {B : Type w} [_inst_1 : comm_semiring R] [_inst_2 : semiring A] [_inst_3 : algebra R A] [_inst_4 : semiring B] [_inst_5 : algebra R B] {S T : subalgebra R A} {S\u2081 T\u2081 : subalgebra R B}, S.prod S\u2081 \u2293 T.prod T\u2081 = (S \u2293 T).prod (S\u2081 \u2293 T\u2081)", "decl_nm": "subalgebra.prod_inf_prod"}
{"formal_statement": "theorem lim_nhds_id {\u03b1 : Type u} [topological_space \u03b1] [t2_space \u03b1] (a : \u03b1) :\n\tlim (nhds a) id = a", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : topological_space \u03b1] [_inst_2 : t2_space \u03b1] (a : \u03b1), lim (nhds a) id = a", "decl_nm": "lim_nhds_id"}
{"formal_statement": "theorem symm_diff_eq_left {\u03b1 : Type*} [generalized_boolean_algebra \u03b1] (a b : \u03b1) :\n\ta \u0394 b = a \u2194 b = \u22a5", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : generalized_boolean_algebra \u03b1] (a b : \u03b1), a \u0394 b = a \u2194 b = \u22a5", "decl_nm": "symm_diff_eq_left"}
{"formal_statement": "theorem intermediate_value {X : Type u} {\u03b1 : Type v} [topological_space X]\n\t[linear_order \u03b1] [topological_space \u03b1] [order_closed_topology \u03b1] {s : set X}\n\t(hs : is_preconnected s) (a : X) (ha : a \u2208 s) (hb : b \u2208 s) (hf : continuous_on f s) :\n\t\u2200 {a b : X},   \u2200 {f :  \u03b1},  set.Icc (f a) (f b) \u2286 f '' s", "decl_tp": "\u2200 {X : Type u} {\u03b1 : Type v} [_inst_1 : topological_space X] [_inst_2 : linear_order \u03b1] [_inst_3 : topological_space \u03b1] [_inst_4 : order_closed_topology \u03b1] {s : set X}, is_preconnected s \u2192 \u2200 {a b : X}, a \u2208 s \u2192 b \u2208 s \u2192 \u2200 {f : X \u2192 \u03b1}, continuous_on f s \u2192 set.Icc (f a) (f b) \u2286 f '' s", "decl_nm": "is_preconnected.intermediate_value"}
{"formal_statement": "theorem emetric_closed_ball {\u03b1 : Type u} [pseudo_metric_space \u03b1] {x : \u03b1}\n\t{\u03b5 : \u211d} (h : 0 \u2264 \u03b5) :\n\temetric.closed_ball x (ennreal.of_real \u03b5) = metric.closed_ball x \u03b5", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : pseudo_metric_space \u03b1] {x : \u03b1} {\u03b5 : \u211d}, 0 \u2264 \u03b5 \u2192 emetric.closed_ball x (ennreal.of_real \u03b5) = metric.closed_ball x \u03b5", "decl_nm": "metric.emetric_closed_ball"}
{"formal_statement": "theorem restr_open_to_local_equiv {\u03b1 \u03b2 : Type*} [topological_space \u03b1] [topological_space \u03b2]\n\t(e : local_homeomorph \u03b1 \u03b2) (s : set \u03b1) (hs : is_open s) :\n\t(e.restr_open s hs).to_local_equiv = e.to_local_equiv.restr s", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : topological_space \u03b1] [_inst_2 : topological_space \u03b2] (e : local_homeomorph \u03b1 \u03b2) (s : set \u03b1) (hs : is_open s), (e.restr_open s hs).to_local_equiv = e.to_local_equiv.restr s", "decl_nm": "local_homeomorph.restr_open_to_local_equiv"}
{"formal_statement": "theorem finite_dimensional {S : Type*} [comm_ring S] {K : Type*} [field K]\n\t[algebra K S] (pb : power_basis K S) :\n\tfinite_dimensional K S", "decl_tp": "\u2200 {S : Type u_2} [_inst_2 : comm_ring S] {K : Type u_6} [_inst_12 : field K] [_inst_15 : algebra K S], power_basis K S \u2192 finite_dimensional K S", "decl_nm": "power_basis.finite_dimensional"}
{"formal_statement": "theorem ball_add_singleton {E : Type*} [semi_normed_group E] (x y : E)\n\t(r : \u211d) :\n\tmetric.ball x r + {y} = metric.ball (x + y) r", "decl_tp": "\u2200 {E : Type u_1} [_inst_1 : semi_normed_group E] (x y : E) (r : \u211d), metric.ball x r + {y} = metric.ball (x + y) r", "decl_nm": "ball_add_singleton"}
{"formal_statement": "theorem volume_Ici {a : \u211d} :\n\t\u21d1measure_theory.measure_space.volume (set.Ici a) = \u22a4", "decl_tp": "\u2200 {a : \u211d}, \u21d1measure_theory.measure_space.volume (set.Ici a) = \u22a4", "decl_nm": "real.volume_Ici"}
{"formal_statement": "theorem of_\u03b5 {C : Type u\u2081} [category_theory.category C] [category_theory.monoidal_category C]\n\t{D : Type u\u2082} [category_theory.category D] [category_theory.monoidal_category D]\n\t(F : C \u2192 D) [I\u2081 : category_theory.functorial F] [I\u2082 : category_theory.lax_monoidal F] :\n\t(category_theory.lax_monoidal_functor.of F).\u03b5 = category_theory.lax_monoidal.\u03b5 F", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] [_inst_2 : category_theory.monoidal_category C] {D : Type u\u2082} [_inst_3 : category_theory.category D] [_inst_4 : category_theory.monoidal_category D] (F : C \u2192 D) [I\u2081 : category_theory.functorial F] [I\u2082 : category_theory.lax_monoidal F], (category_theory.lax_monoidal_functor.of F).\u03b5 = category_theory.lax_monoidal.\u03b5 F", "decl_nm": "category_theory.lax_monoidal_functor.of_\u03b5"}
{"formal_statement": "theorem mem_Icc {\u03b1 : Type*} [preorder \u03b1] [locally_finite_order \u03b1] {a b x : \u03b1} :\n\tx \u2208 multiset.Icc a b \u2194 a \u2264 x \u2227 x \u2264 b", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : preorder \u03b1] [_inst_2 : locally_finite_order \u03b1] {a b x : \u03b1}, x \u2208 multiset.Icc a b \u2194 a \u2264 x \u2227 x \u2264 b", "decl_nm": "multiset.mem_Icc"}
{"formal_statement": "theorem comap_prod_prod {R : Type u} {M : Type v} {M\u2082 : Type w} {M\u2083 : Type y}\n\t[semiring R] [add_comm_monoid M] [add_comm_monoid M\u2082] [add_comm_monoid M\u2083]\n\t[module R M] [module R M\u2082] [module R M\u2083] (f : M \u2192\u2097[R] M\u2082) (g : M \u2192\u2097[R] M\u2083)\n\t(p : submodule R M\u2082) (q : submodule R M\u2083) :\n\tsubmodule.comap (f.prod g) (p.prod q) = submodule.comap f p \u2293 submodule.comap g q", "decl_tp": "\u2200 {R : Type u} {M : Type v} {M\u2082 : Type w} {M\u2083 : Type y} [_inst_1 : semiring R] [_inst_2 : add_comm_monoid M] [_inst_3 : add_comm_monoid M\u2082] [_inst_4 : add_comm_monoid M\u2083] [_inst_6 : module R M] [_inst_7 : module R M\u2082] [_inst_8 : module R M\u2083] (f : M \u2192\u2097[R] M\u2082) (g : M \u2192\u2097[R] M\u2083) (p : submodule R M\u2082) (q : submodule R M\u2083), submodule.comap (f.prod g) (p.prod q) = submodule.comap f p \u2293 submodule.comap g q", "decl_nm": "linear_map.comap_prod_prod"}
{"formal_statement": "theorem trop_eq_iff_eq_untrop {R : Type u} {x : R} {y : tropical R} :\n\ttropical.trop x = y \u2194 x = tropical.untrop y", "decl_tp": "\u2200 {R : Type u} {x : R} {y : tropical R}, tropical.trop x = y \u2194 x = tropical.untrop y", "decl_nm": "tropical.trop_eq_iff_eq_untrop"}
{"formal_statement": "theorem lift_aux_tmul {R : Type*} [comm_semiring R] {M N P : Type*} [add_comm_monoid M]\n\t[add_comm_monoid N] [add_comm_monoid P] [module R M] [module R N] [module R P]\n\t(f : M \u2192\u2097[R] N \u2192\u2097[R] P) (m : M) (n : N) :\n\t\u21d1(tensor_product.lift_aux f) (m \u2297\u209c[R] n) = \u21d1(\u21d1f m) n", "decl_tp": "\u2200 {R : Type u_1} [_inst_1 : comm_semiring R] {M : Type u_4} {N : Type u_5} {P : Type u_6} [_inst_4 : add_comm_monoid M] [_inst_5 : add_comm_monoid N] [_inst_6 : add_comm_monoid P] [_inst_9 : module R M] [_inst_10 : module R N] [_inst_11 : module R P] (f : M \u2192\u2097[R] N \u2192\u2097[R] P) (m : M) (n : N), \u21d1(tensor_product.lift_aux f) (m \u2297\u209c[R] n) = \u21d1(\u21d1f m) n", "decl_nm": "tensor_product.lift_aux_tmul"}
{"formal_statement": "theorem card_support_ne_one {\u03b1 : Type*} [decidable_eq \u03b1] [fintype \u03b1] (f : equiv.perm \u03b1) :\n\tf.support.card \u2260 1", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : decidable_eq \u03b1] [_inst_2 : fintype \u03b1] (f : equiv.perm \u03b1), f.support.card \u2260 1", "decl_nm": "equiv.perm.card_support_ne_one"}
{"formal_statement": "theorem drop_fun_split_fun {n : \u2115} {\u03b1 : typevec (n + 1)} {\u03b1' : typevec (n + 1)}\n\t(f : \u03b1.drop.arrow \u03b1'.drop) (g : \u03b1.last \u2192 \u03b1'.last) :\n\ttypevec.drop_fun (typevec.split_fun f g) = f", "decl_tp": "\u2200 {n : \u2115} {\u03b1 : typevec (n + 1)} {\u03b1' : typevec (n + 1)} (f : \u03b1.drop.arrow \u03b1'.drop) (g : \u03b1.last \u2192 \u03b1'.last), typevec.drop_fun (typevec.split_fun f g) = f", "decl_nm": "typevec.drop_fun_split_fun"}
{"formal_statement": "theorem dvd_mul_right {\u03b1 : Type*} [monoid \u03b1] {a b u : \u03b1} (hu : is_unit u) :\n\t(a \u2223 b * u \u2194 a \u2223 b)", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : monoid \u03b1] {a b u : \u03b1}, is_unit u \u2192 (a \u2223 b * u \u2194 a \u2223 b)", "decl_nm": "is_unit.dvd_mul_right"}
{"formal_statement": "theorem prod_map_map_eq' {\u03b1\u2081 \u03b1\u2082 \u03b2\u2081 \u03b2\u2082 : Type*} (f : \u03b1\u2081 \u2192 \u03b1\u2082) (g : \u03b2\u2081 \u2192 \u03b2\u2082)\n\t(F : filter \u03b1\u2081) (G : filter \u03b2\u2081) :\n\t(filter.map f F).prod (filter.map g G) = filter.map (prod.map f g) (F.prod G)", "decl_tp": "\u2200 {\u03b1\u2081 : Type u_1} {\u03b1\u2082 : Type u_2} {\u03b2\u2081 : Type u_3} {\u03b2\u2082 : Type u_4} (f : \u03b1\u2081 \u2192 \u03b1\u2082) (g : \u03b2\u2081 \u2192 \u03b2\u2082) (F : filter \u03b1\u2081) (G : filter \u03b2\u2081), (filter.map f F).prod (filter.map g G) = filter.map (prod.map f g) (F.prod G)", "decl_nm": "filter.prod_map_map_eq'"}
{"formal_statement": "theorem coe_zero {\u03b1 : Type u} [uniform_space \u03b1] [has_zero \u03b1] :\n\t\u21910 = 0", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : uniform_space \u03b1] [_inst_2 : has_zero \u03b1], \u21910 = 0", "decl_nm": "uniform_space.completion.coe_zero"}
{"formal_statement": "theorem inl_injective {R : Type u} {M : Type v} [has_zero M] :\n\tfunction.injective triv_sq_zero_ext.inl", "decl_tp": "\u2200 {R : Type u} {M : Type v} [_inst_1 : has_zero M], function.injective triv_sq_zero_ext.inl", "decl_nm": "triv_sq_zero_ext.inl_injective"}
{"formal_statement": "theorem xgcd_val (x y : \u2115) :\n\tx.xgcd y = (x.gcd_a y, x.gcd_b y)", "decl_tp": "\u2200 (x y : \u2115), x.xgcd y = (x.gcd_a y, x.gcd_b y)", "decl_nm": "nat.xgcd_val"}
{"formal_statement": "theorem ite_not {\u03b1 : Sort u_1} (P : Prop) [decidable P] (a b : \u03b1) :\n\tite (\u00acP) a b = ite P b a", "decl_tp": "\u2200 {\u03b1 : Sort u_1} (P : Prop) [_inst_1 : decidable P] (a b : \u03b1), ite (\u00acP) a b = ite P b a", "decl_nm": "ite_not"}
{"formal_statement": "theorem continuous_conj :\n\tcontinuous \u21d1star_ring_aut", "decl_tp": "continuous \u21d1star_ring_aut", "decl_nm": "complex.continuous_conj"}
{"formal_statement": "theorem eq_lim_of_const_equiv {\u03b1 : Type*} [linear_ordered_field \u03b1] {\u03b2 : Type*}\n\t[ring \u03b2] {abv : \u03b2 \u2192 \u03b1} [is_absolute_value abv] [cau_seq.is_complete \u03b2 abv]\n\t{f : cau_seq \u03b2 abv} {x : \u03b2} (h : cau_seq.const abv x \u2248 f) :\n\tx = f.lim", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : linear_ordered_field \u03b1] {\u03b2 : Type u_2} [_inst_2 : ring \u03b2] {abv : \u03b2 \u2192 \u03b1} [_inst_3 : is_absolute_value abv] [_inst_4 : cau_seq.is_complete \u03b2 abv] {f : cau_seq \u03b2 abv} {x : \u03b2}, cau_seq.const abv x \u2248 f \u2192 x = f.lim", "decl_nm": "cau_seq.eq_lim_of_const_equiv"}
{"formal_statement": "theorem unique_mdiff_within_at {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c]\n\t{E : Type*} [normed_group E] [normed_space \ud835\udd5c E] {H : Type*} [topological_space H]\n\t{I : model_with_corners \ud835\udd5c E H} {M : Type*} [topological_space M] [charted_space H M]\n\t{x : M} {s : set M} (xs : x \u2208 s) (hs : is_open s) :\n\tunique_mdiff_within_at I s x", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {H : Type u_3} [_inst_4 : topological_space H] {I : model_with_corners \ud835\udd5c E H} {M : Type u_4} [_inst_5 : topological_space M] [_inst_6 : charted_space H M] {x : M} {s : set M}, x \u2208 s \u2192 is_open s \u2192 unique_mdiff_within_at I s x", "decl_nm": "is_open.unique_mdiff_within_at"}
{"formal_statement": "theorem choose_le_add (a b c : \u2115) :\n\ta.choose c \u2264 (a + b).choose c", "decl_tp": "\u2200 (a b c : \u2115), a.choose c \u2264 (a + b).choose c", "decl_nm": "nat.choose_le_add"}
{"formal_statement": "theorem list_foldl {\u03b1 \u03b2 \u03c3 : Type*} [primcodable \u03b1] [primcodable \u03b2] [primcodable \u03c3]\n\t{f : \u03b1 \u2192 list \u03b2} {g : \u03b1 \u2192 \u03c3} {h : \u03b1 \u2192 \u03c3 \u00d7 \u03b2 \u2192 \u03c3} :\n\tprimrec f \u2192 primrec g \u2192 primrec\u2082 h \u2192 primrec (\u03bb (a : \u03b1), list.foldl (\u03bb (s : \u03c3)\n\t(b : \u03b2), h a (s, b)) (g a) (f a))", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {\u03c3 : Type u_4} [_inst_1 : primcodable \u03b1] [_inst_2 : primcodable \u03b2] [_inst_4 : primcodable \u03c3] {f : \u03b1 \u2192 list \u03b2} {g : \u03b1 \u2192 \u03c3} {h : \u03b1 \u2192 \u03c3 \u00d7 \u03b2 \u2192 \u03c3}, primrec f \u2192 primrec g \u2192 primrec\u2082 h \u2192 primrec (\u03bb (a : \u03b1), list.foldl (\u03bb (s : \u03c3) (b : \u03b2), h a (s, b)) (g a) (f a))", "decl_nm": "primrec.list_foldl"}
{"formal_statement": "theorem one_succ_above_one {n : \u2115} :\n\t\u21d1(1.succ_above) 1 = 2", "decl_tp": "\u2200 {n : \u2115}, \u21d1(1.succ_above) 1 = 2", "decl_nm": "fin.one_succ_above_one"}
{"formal_statement": "theorem coe_pi_finset {\u03b1 : Type*} [decidable_eq \u03b1] [fintype \u03b1] {\u03b4 : \u03b1 \u2192 Type*}\n\t(t : \u03a0 (a : \u03b1), finset (\u03b4 a)) :\n\t\u2191(fintype.pi_finset t) = set.univ.pi (\u03bb (a : \u03b1), \u2191(t a))", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : decidable_eq \u03b1] [_inst_2 : fintype \u03b1] {\u03b4 : \u03b1 \u2192 Type u_4} (t : \u03a0 (a : \u03b1), finset (\u03b4 a)), \u2191(fintype.pi_finset t) = set.univ.pi (\u03bb (a : \u03b1), \u2191(t a))", "decl_nm": "fintype.coe_pi_finset"}
{"formal_statement": "theorem countable {\u03b1 : Type u} {s : set \u03b1} (hs : s.subsingleton) :\n\ts.countable", "decl_tp": "\u2200 {\u03b1 : Type u} {s : set \u03b1}, s.subsingleton \u2192 s.countable", "decl_nm": "set.subsingleton.countable"}
{"formal_statement": "theorem norm_sub_pow_two_real {F : Type*} [inner_product_space \u211d F] {x y : F} :\n\t\u2225x - y\u2225 ^ 2 = \u2225x\u2225 ^ 2 - 2 * has_inner.inner x y + \u2225y\u2225 ^ 2", "decl_tp": "\u2200 {F : Type u_3} [_inst_3 : inner_product_space \u211d F] {x y : F}, \u2225x - y\u2225 ^ 2 = \u2225x\u2225 ^ 2 - 2 * has_inner.inner x y + \u2225y\u2225 ^ 2", "decl_nm": "norm_sub_pow_two_real"}
{"formal_statement": "theorem powerset_len_aux_zero {\u03b1 : Type*} (l : list \u03b1) :\n\tmultiset.powerset_len_aux 0 l = [0]", "decl_tp": "\u2200 {\u03b1 : Type u_1} (l : list \u03b1), multiset.powerset_len_aux 0 l = [0]", "decl_nm": "multiset.powerset_len_aux_zero"}
{"formal_statement": "theorem comm {n a b : \u2115} :\n\ta \u2261 b [MOD n] \u2194 b \u2261 a [MOD n]", "decl_tp": "\u2200 {n a b : \u2115}, a \u2261 b [MOD n] \u2194 b \u2261 a [MOD n]", "decl_nm": "nat.modeq.comm"}
{"formal_statement": "theorem eq (R : Type u) [non_assoc_semiring R] {p : \u2115} (C : char_p R p) :\n\tp = ring_char R", "decl_tp": "\u2200 (R : Type u) [_inst_1 : non_assoc_semiring R] {p : \u2115}, char_p R p \u2192 p = ring_char R", "decl_nm": "ring_char.eq"}
{"formal_statement": "theorem mul_right_mono {a : ennreal} :\n\tmonotone (\u03bb (x : ennreal), x * a)", "decl_tp": "\u2200 {a : ennreal}, monotone (\u03bb (x : ennreal), x * a)", "decl_nm": "ennreal.mul_right_mono"}
{"formal_statement": "theorem tsub_apply {\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} [\u03a0 (i : \u03b9), canonically_ordered_add_monoid (\u03b1 i)]\n\t[\u03a0 (i : \u03b9), has_sub (\u03b1 i)] [\u03a0 (i : \u03b9), has_ordered_sub (\u03b1 i)] (f g : \u03a0\u2080 (i : \u03b9), \u03b1 i)\n\t(i : \u03b9) :\n\t\u21d1(f - g) i = \u21d1f i - \u21d1g i", "decl_tp": "\u2200 {\u03b9 : Type u_1} {\u03b1 : \u03b9 \u2192 Type u_2} [_inst_1 : \u03a0 (i : \u03b9), canonically_ordered_add_monoid (\u03b1 i)] [_inst_2 : \u03a0 (i : \u03b9), has_sub (\u03b1 i)] [_inst_3 : \u03a0 (i : \u03b9), has_ordered_sub (\u03b1 i)] (f g : \u03a0\u2080 (i : \u03b9), \u03b1 i) (i : \u03b9), \u21d1(f - g) i = \u21d1f i - \u21d1g i", "decl_nm": "dfinsupp.tsub_apply"}
{"formal_statement": "theorem ceil_to_nat {\u03b1 : Type*} [linear_ordered_ring \u03b1] [floor_ring \u03b1]\n\t(a : \u03b1) :\n\t\u2308a\u2309.to_nat = \u2308a\u2309\u208a", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : linear_ordered_ring \u03b1] [_inst_2 : floor_ring \u03b1] (a : \u03b1), \u2308a\u2309.to_nat = \u2308a\u2309\u208a", "decl_nm": "int.ceil_to_nat"}
{"formal_statement": "theorem add_apply {\u0393 R : Type*} [partial_order \u0393] [add_comm_monoid R] {\u03b1 : Type*}\n\t{s t : hahn_series.summable_family \u0393 R \u03b1} {a : \u03b1} :\n\t\u21d1(s + t) a = \u21d1s a + \u21d1t a", "decl_tp": "\u2200 {\u0393 : Type u_1} {R : Type u_2} [_inst_1 : partial_order \u0393] [_inst_2 : add_comm_monoid R] {\u03b1 : Type u_3} {s t : hahn_series.summable_family \u0393 R \u03b1} {a : \u03b1}, \u21d1(s + t) a = \u21d1s a + \u21d1t a", "decl_nm": "hahn_series.summable_family.add_apply"}
{"formal_statement": "theorem fst {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c] {E : Type*} [normed_group E]\n\t[normed_space \ud835\udd5c E] {F : Type*} [normed_group F] [normed_space \ud835\udd5c F] {G : Type*}\n\t[normed_group G] [normed_space \ud835\udd5c G] {x : E} {s : set E} {f\u2082 : E \u2192 F \u00d7 G}\n\t(hs : unique_diff_within_at \ud835\udd5c s x) (h : differentiable_within_at \ud835\udd5c f\u2082 s x) :\n\tfderiv_within \ud835\udd5c (\u03bb (x : E), (f\u2082 x).fst) s x = (continuous_linear_map.fst \ud835\udd5c F G).comp (fderiv_within \ud835\udd5c f\u2082 s x)", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {F : Type u_3} [_inst_4 : normed_group F] [_inst_5 : normed_space \ud835\udd5c F] {G : Type u_4} [_inst_6 : normed_group G] [_inst_7 : normed_space \ud835\udd5c G] {x : E} {s : set E} {f\u2082 : E \u2192 F \u00d7 G}, unique_diff_within_at \ud835\udd5c s x \u2192 differentiable_within_at \ud835\udd5c f\u2082 s x \u2192 fderiv_within \ud835\udd5c (\u03bb (x : E), (f\u2082 x).fst) s x = (continuous_linear_map.fst \ud835\udd5c F G).comp (fderiv_within \ud835\udd5c f\u2082 s x)", "decl_nm": "fderiv_within.fst"}
{"formal_statement": "theorem is_open_ball {\u03b1 : Type*} [uniform_space \u03b1] (x : \u03b1) {V : set (\u03b1 \u00d7 \u03b1)}\n\t(hV : is_open V) :\n\tis_open (uniform_space.ball x V)", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : uniform_space \u03b1] (x : \u03b1) {V : set (\u03b1 \u00d7 \u03b1)}, is_open V \u2192 is_open (uniform_space.ball x V)", "decl_nm": "uniform_space.is_open_ball"}
{"formal_statement": "theorem left_unitor_inv {C : Type u} [category_theory.category C] [category_theory.limits.has_binary_coproducts C]\n\t[category_theory.limits.has_initial C] (P : C) :\n\t(category_theory.limits.coprod.left_unitor P).inv = category_theory.limits.coprod.inr", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] [_inst_2 : category_theory.limits.has_binary_coproducts C] [_inst_3 : category_theory.limits.has_initial C] (P : C), (category_theory.limits.coprod.left_unitor P).inv = category_theory.limits.coprod.inr", "decl_nm": "category_theory.limits.coprod.left_unitor_inv"}
{"formal_statement": "theorem \u03b5_iso_hom {C : Type u\u2081} [category_theory.category C] [category_theory.monoidal_category C]\n\t{D : Type u\u2082} [category_theory.category D] [category_theory.monoidal_category D]\n\t(F : category_theory.monoidal_functor C D) :\n\tF.\u03b5_iso.hom = F.to_lax_monoidal_functor.\u03b5", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] [_inst_2 : category_theory.monoidal_category C] {D : Type u\u2082} [_inst_3 : category_theory.category D] [_inst_4 : category_theory.monoidal_category D] (F : category_theory.monoidal_functor C D), F.\u03b5_iso.hom = F.to_lax_monoidal_functor.\u03b5", "decl_nm": "category_theory.monoidal_functor.\u03b5_iso_hom"}
{"formal_statement": "theorem gcd_dvd_gcd_of_dvd_left {m k : \u2115} (n : \u2115) (H : m \u2223 k) :\n\tm.gcd n \u2223 k.gcd n", "decl_tp": "\u2200 {m k : \u2115} (n : \u2115), m \u2223 k \u2192 m.gcd n \u2223 k.gcd n", "decl_nm": "nat.gcd_dvd_gcd_of_dvd_left"}
{"formal_statement": "theorem left_adjoint_of_structured_arrow_initials_aux_apply {C : Type u\u2081}\n\t{D : Type u\u2082} [category_theory.category C] [category_theory.category D]\n\t(G : D \u2964 C) [\u2200 (A : C), category_theory.limits.has_initial (category_theory.structured_arrow A G)]\n\t(A : C) (B : D) (g : (\u22a5_ category_theory.structured_arrow A G).right \u27f6 B) :\n\t\u21d1(category_theory.left_adjoint_of_structured_arrow_initials_aux G A B) g = (\u22a5_ category_theory.structured_arrow A G).hom \u226b G.map g", "decl_tp": "\u2200 {C : Type u\u2081} {D : Type u\u2082} [_inst_1 : category_theory.category C] [_inst_2 : category_theory.category D] (G : D \u2964 C) [_inst_3 : \u2200 (A : C), category_theory.limits.has_initial (category_theory.structured_arrow A G)] (A : C) (B : D) (g : (\u22a5_ category_theory.structured_arrow A G).right \u27f6 B), \u21d1(category_theory.left_adjoint_of_structured_arrow_initials_aux G A B) g = (\u22a5_ category_theory.structured_arrow A G).hom \u226b G.map g", "decl_nm": "category_theory.left_adjoint_of_structured_arrow_initials_aux_apply"}
{"formal_statement": "theorem add_monoid_algebra_equiv_direct_sum_symm_apply {\u03b9 M : Type*} [decidable_eq \u03b9]\n\t[semiring M] [\u03a0 (m : M), decidable (m \u2260 0)] :\n\t\u21d1(add_monoid_algebra_equiv_direct_sum.symm) = direct_sum.to_add_monoid_algebra", "decl_tp": "\u2200 {\u03b9 : Type u_1} {M : Type u_3} [_inst_1 : decidable_eq \u03b9] [_inst_2 : semiring M] [_inst_3 : \u03a0 (m : M), decidable (m \u2260 0)], \u21d1(add_monoid_algebra_equiv_direct_sum.symm) = direct_sum.to_add_monoid_algebra", "decl_nm": "add_monoid_algebra_equiv_direct_sum_symm_apply"}
{"formal_statement": "theorem exists_of_step (k : Type u) [field k] (z : algebraic_closure k) :\n\t\u2203 (n : \u2115) (x : algebraic_closure.step k n), \u21d1(algebraic_closure.of_step k n) x = z", "decl_tp": "\u2200 (k : Type u) [_inst_1 : field k] (z : algebraic_closure k), \u2203 (n : \u2115) (x : algebraic_closure.step k n), \u21d1(algebraic_closure.of_step k n) x = z", "decl_nm": "algebraic_closure.exists_of_step"}
{"formal_statement": "theorem is_irrefl {\u03b1 \u03b2 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {F : Type*}\n\t[rel_hom_class F r s] (f : F) :\n\t\u2200 [is_irrefl \u03b2 s], is_irrefl \u03b1 r", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {F : Type u_4} [_inst_1 : rel_hom_class F r s], F \u2192 \u2200 [_inst_2 : is_irrefl \u03b2 s], is_irrefl \u03b1 r", "decl_nm": "rel_hom_class.is_irrefl"}
{"formal_statement": "theorem functor_pullback_inter {C : Type u\u2081} [category_theory.category C]\n\t{D : Type u\u2082} [category_theory.category D] (F : C \u2964 D) {X : C} (S R : category_theory.sieve (F.obj X)) :\n\tcategory_theory.sieve.functor_pullback F (S \u2293 R) = category_theory.sieve.functor_pullback F S \u2293 category_theory.sieve.functor_pullback F R", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {D : Type u\u2082} [_inst_2 : category_theory.category D] (F : C \u2964 D) {X : C} (S R : category_theory.sieve (F.obj X)), category_theory.sieve.functor_pullback F (S \u2293 R) = category_theory.sieve.functor_pullback F S \u2293 category_theory.sieve.functor_pullback F R", "decl_nm": "category_theory.sieve.functor_pullback_inter"}
{"formal_statement": "theorem sheafify_is_sheaf {C : Type u} [category_theory.category C] (J : category_theory.grothendieck_topology C)\n\t{D : Type w} [category_theory.category D] [category_theory.concrete_category D]\n\t[category_theory.limits.preserves_limits (category_theory.forget D)] [\u2200 (P : C\u1d52\u1d56 \u2964 D)\n\t(X : C) (S : J.cover X), category_theory.limits.has_multiequalizer (S.index P)]\n\t[\u2200 (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)\u1d52\u1d56 D]\n\t[\u03a0 (X : C), category_theory.limits.preserves_colimits_of_shape (J.cover X)\u1d52\u1d56 (category_theory.forget D)]\n\t[category_theory.reflects_isomorphisms (category_theory.forget D)] (P : C\u1d52\u1d56 \u2964 D) :\n\tcategory_theory.presheaf.is_sheaf J (J.sheafify P)", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] (J : category_theory.grothendieck_topology C) {D : Type w} [_inst_2 : category_theory.category D] [_inst_3 : category_theory.concrete_category D] [_inst_4 : category_theory.limits.preserves_limits (category_theory.forget D)] [_inst_5 : \u2200 (P : C\u1d52\u1d56 \u2964 D) (X : C) (S : J.cover X), category_theory.limits.has_multiequalizer (S.index P)] [_inst_6 : \u2200 (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)\u1d52\u1d56 D] [_inst_7 : \u03a0 (X : C), category_theory.limits.preserves_colimits_of_shape (J.cover X)\u1d52\u1d56 (category_theory.forget D)] [_inst_8 : category_theory.reflects_isomorphisms (category_theory.forget D)] (P : C\u1d52\u1d56 \u2964 D), category_theory.presheaf.is_sheaf J (J.sheafify P)", "decl_nm": "category_theory.grothendieck_topology.sheafify_is_sheaf"}
{"formal_statement": "theorem antisymm {\u03b1 : Type*} [circular_partial_order \u03b1] {a b c : \u03b1} (h : has_btw.btw a b c) :\n\thas_btw.btw c b a \u2192 a = b \u2228 b = c \u2228 c = a", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : circular_partial_order \u03b1] {a b c : \u03b1}, has_btw.btw a b c \u2192 has_btw.btw c b a \u2192 a = b \u2228 b = c \u2228 c = a", "decl_nm": "has_btw.btw.antisymm"}
{"formal_statement": "theorem le_comap_id {X : Type*} [topological_space X] (A : discrete_quotient X) :\n\tdiscrete_quotient.le_comap continuous_id A A", "decl_tp": "\u2200 {X : Type u_1} [_inst_1 : topological_space X] (A : discrete_quotient X), discrete_quotient.le_comap continuous_id A A", "decl_nm": "discrete_quotient.le_comap_id"}
{"formal_statement": "theorem eq_inv_smul_iff\u2080 {\u03b1 : Type u} {\u03b2 : Type v} [group_with_zero \u03b1]\n\t[mul_action \u03b1 \u03b2] {a : \u03b1} (ha : a \u2260 0) :\n\t\u2200 {x y : \u03b2}, x = a\u207b\u00b9 \u2022 y \u2194 a \u2022 x = y", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : group_with_zero \u03b1] [_inst_2 : mul_action \u03b1 \u03b2] {a : \u03b1}, a \u2260 0 \u2192 \u2200 {x y : \u03b2}, x = a\u207b\u00b9 \u2022 y \u2194 a \u2022 x = y", "decl_nm": "eq_inv_smul_iff\u2080"}
{"formal_statement": "theorem up_down {\u03b1 : Type*} [encodable \u03b1] {a : \u03b1} :\n\t(ulower.down a).up = a", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : encodable \u03b1] {a : \u03b1}, (ulower.down a).up = a", "decl_nm": "ulower.up_down"}
{"formal_statement": "theorem continuous_within_at_iff'_right {\u03b1 \u03b2 : Type*} [uniform_space \u03b1]\n\t[topological_space \u03b2] {f : \u03b2 \u2192 \u03b1} {b : \u03b2} {s : set \u03b2} :\n\tcontinuous_within_at f s b \u2194 filter.tendsto (\u03bb (x : \u03b2), (f b, f x)) (nhds_within b s)\n\t(uniformity \u03b1)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : uniform_space \u03b1] [_inst_2 : topological_space \u03b2] {f : \u03b2 \u2192 \u03b1} {b : \u03b2} {s : set \u03b2}, continuous_within_at f s b \u2194 filter.tendsto (\u03bb (x : \u03b2), (f b, f x)) (nhds_within b s) (uniformity \u03b1)", "decl_nm": "uniform.continuous_within_at_iff'_right"}
{"formal_statement": "theorem reduce {n : \u2115} {a : fin n} {n' a' b k nk : \u2115} (hn : n = n') (h : tactic.norm_fin.normalize_fin n a a')\n\t(e1 : n' * k = nk) (e2 : nk + b = a') :\n\ttactic.norm_fin.normalize_fin n a b", "decl_tp": "\u2200 {n : \u2115} {a : fin n} {n' a' b k nk : \u2115}, n = n' \u2192 tactic.norm_fin.normalize_fin n a a' \u2192 n' * k = nk \u2192 nk + b = a' \u2192 tactic.norm_fin.normalize_fin n a b", "decl_nm": "tactic.norm_fin.normalize_fin.reduce"}
{"formal_statement": "theorem bind_decode_iff {\u03b1 \u03b2 \u03c3 : Type*} [primcodable \u03b1] [primcodable \u03b2]\n\t[primcodable \u03c3] {f : \u03b1 \u2192 \u03b2 \u2192 option \u03c3} :\n\tprimrec\u2082 (\u03bb (a : \u03b1) (n : \u2115), (encodable.decode \u03b2 n).bind (f a)) \u2194 primrec\u2082 f", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {\u03c3 : Type u_5} [_inst_1 : primcodable \u03b1] [_inst_2 : primcodable \u03b2] [_inst_5 : primcodable \u03c3] {f : \u03b1 \u2192 \u03b2 \u2192 option \u03c3}, primrec\u2082 (\u03bb (a : \u03b1) (n : \u2115), (encodable.decode \u03b2 n).bind (f a)) \u2194 primrec\u2082 f", "decl_nm": "primrec.bind_decode_iff"}
{"formal_statement": "theorem coe_smul {R R\u2082 S\u2083 : Type*} [semiring R] [semiring R\u2082] [monoid S\u2083]\n\t[topological_space S\u2083] {M : Type*} [topological_space M] [add_comm_monoid M]\n\t[module R M] {M\u2082 : Type*} [topological_space M\u2082] [add_comm_monoid M\u2082]\n\t[module R\u2082 M\u2082] {\u03c3\u2081\u2082 : R \u2192+* R\u2082} (c : S\u2083) (f : M \u2192SL[\u03c3\u2081\u2082] M\u2082) [distrib_mul_action S\u2083 M\u2082]\n\t[has_continuous_smul S\u2083 M\u2082] [smul_comm_class R\u2082 S\u2083 M\u2082] :\n\t\u2191(c \u2022 f) = c \u2022 \u2191f", "decl_tp": "\u2200 {R : Type u_1} {R\u2082 : Type u_2} {S\u2083 : Type u_5} [_inst_1 : semiring R] [_inst_2 : semiring R\u2082] [_inst_5 : monoid S\u2083] [_inst_7 : topological_space S\u2083] {M : Type u_6} [_inst_8 : topological_space M] [_inst_9 : add_comm_monoid M] [_inst_10 : module R M] {M\u2082 : Type u_7} [_inst_11 : topological_space M\u2082] [_inst_12 : add_comm_monoid M\u2082] [_inst_13 : module R\u2082 M\u2082] {\u03c3\u2081\u2082 : R \u2192+* R\u2082} (c : S\u2083) (f : M \u2192SL[\u03c3\u2081\u2082] M\u2082) [_inst_30 : distrib_mul_action S\u2083 M\u2082] [_inst_31 : has_continuous_smul S\u2083 M\u2082] [_inst_32 : smul_comm_class R\u2082 S\u2083 M\u2082], \u2191(c \u2022 f) = c \u2022 \u2191f", "decl_nm": "continuous_linear_map.coe_smul"}
{"formal_statement": "theorem nontrivial_to_cycle {\u03b1 : Type*} [fintype \u03b1] [decidable_eq \u03b1] (f : equiv.perm \u03b1)\n\t(hf : f.is_cycle) :\n\t(f.to_cycle hf).nontrivial", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : fintype \u03b1] [_inst_2 : decidable_eq \u03b1] (f : equiv.perm \u03b1) (hf : f.is_cycle), (f.to_cycle hf).nontrivial", "decl_nm": "equiv.perm.nontrivial_to_cycle"}
{"formal_statement": "theorem Iio_union_Ici {\u03b1 : Type u} [linear_order \u03b1] {a : \u03b1} :\n\tset.Iio a \u222a set.Ici a = set.univ", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : linear_order \u03b1] {a : \u03b1}, set.Iio a \u222a set.Ici a = set.univ", "decl_nm": "set.Iio_union_Ici"}
{"formal_statement": "theorem one_nonempty {\u03b1 : Type*} [has_one \u03b1] :\n\t1.nonempty", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : has_one \u03b1], 1.nonempty", "decl_nm": "finset.one_nonempty"}
{"formal_statement": "theorem cast_nat_add_right {n n' m : \u2115} (i : fin n') (h : m + n' = m + n) :\n\t\u21d1(fin.cast h) (\u21d1(fin.nat_add m) i) = \u21d1(fin.nat_add m) (\u21d1(fin.cast _) i)", "decl_tp": "\u2200 {n n' m : \u2115} (i : fin n') (h : m + n' = m + n), \u21d1(fin.cast h) (\u21d1(fin.nat_add m) i) = \u21d1(fin.nat_add m) (\u21d1(fin.cast _) i)", "decl_nm": "fin.cast_nat_add_right"}
{"formal_statement": "theorem mem_to_list {n : \u2115} {\u03b1 : Type u} {v : \u03b1} {a : array n \u03b1} :\n\tv \u2208 a.to_list \u2194 v \u2208 a", "decl_tp": "\u2200 {n : \u2115} {\u03b1 : Type u} {v : \u03b1} {a : array n \u03b1}, v \u2208 a.to_list \u2194 v \u2208 a", "decl_nm": "array.mem_to_list"}
{"formal_statement": "theorem mem_nhds_one {G : Type u} [group G] (B : group_filter_basis G)\n\t{U : set G} (hU : U \u2208 B) :\n\tU \u2208 nhds 1", "decl_tp": "\u2200 {G : Type u} [_inst_1 : group G] (B : group_filter_basis G) {U : set G}, U \u2208 B \u2192 U \u2208 nhds 1", "decl_nm": "group_filter_basis.mem_nhds_one"}
{"formal_statement": "theorem coe_sort_coe_trans {\u03b1 : Sort u_1} {\u03b2 : Sort u_2} {\u03b3 : Sort u_3}\n\t{\u03b4 : out_param (Sort u_4)} [has_coe \u03b1 \u03b2] [has_coe_t_aux \u03b2 \u03b3] [has_coe_to_sort \u03b3 \u03b4]\n\t(x : \u03b1) :\n\t\u21a5x = \u21a5\u2191x", "decl_tp": "\u2200 {\u03b1 : Sort u_1} {\u03b2 : Sort u_2} {\u03b3 : Sort u_3} {\u03b4 : out_param (Sort u_4)} [_inst_1 : has_coe \u03b1 \u03b2] [_inst_2 : has_coe_t_aux \u03b2 \u03b3] [_inst_3 : has_coe_to_sort \u03b3 \u03b4] (x : \u03b1), \u21a5x = \u21a5\u2191x", "decl_nm": "coe_sort_coe_trans"}
{"formal_statement": "theorem to_complex_add (x y : gaussian_int) :\n\t\u2191(x + y) = \u2191x + \u2191y", "decl_tp": "\u2200 (x y : gaussian_int), \u2191(x + y) = \u2191x + \u2191y", "decl_nm": "gaussian_int.to_complex_add"}
{"formal_statement": "theorem erase_subperm {\u03b1 : Type uu} [decidable_eq \u03b1] (a : \u03b1) (l : list \u03b1) :\n\tl.erase a <+~ l", "decl_tp": "\u2200 {\u03b1 : Type uu} [_inst_1 : decidable_eq \u03b1] (a : \u03b1) (l : list \u03b1), l.erase a <+~ l", "decl_nm": "list.erase_subperm"}
{"formal_statement": "theorem Ico_subset_Ico {\u03b1 : Type*} [preorder \u03b1] [locally_finite_order \u03b1]\n\t{a\u2081 b\u2081 a\u2082 b\u2082 : \u03b1} (ha : a\u2082 \u2264 a\u2081) (hb : b\u2081 \u2264 b\u2082) :\n\tfinset.Ico a\u2081 b\u2081 \u2286 finset.Ico a\u2082 b\u2082", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : preorder \u03b1] [_inst_2 : locally_finite_order \u03b1] {a\u2081 b\u2081 a\u2082 b\u2082 : \u03b1}, a\u2082 \u2264 a\u2081 \u2192 b\u2081 \u2264 b\u2082 \u2192 finset.Ico a\u2081 b\u2081 \u2286 finset.Ico a\u2082 b\u2082", "decl_nm": "finset.Ico_subset_Ico"}
{"formal_statement": "theorem parallel_pair_hom_app_one {C : Type u} [category_theory.category C]\n\t{X Y X' Y' : C} (f g : X \u27f6 Y) (f' g' : X' \u27f6 Y') (p : X \u27f6 X') (q : Y \u27f6 Y')\n\t(wf : f \u226b q = p \u226b f') (wg : g \u226b q = p \u226b g') :\n\t(category_theory.limits.parallel_pair_hom f g f' g' p q wf wg).app category_theory.limits.walking_parallel_pair.one = q", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] {X Y X' Y' : C} (f g : X \u27f6 Y) (f' g' : X' \u27f6 Y') (p : X \u27f6 X') (q : Y \u27f6 Y') (wf : f \u226b q = p \u226b f') (wg : g \u226b q = p \u226b g'), (category_theory.limits.parallel_pair_hom f g f' g' p q wf wg).app category_theory.limits.walking_parallel_pair.one = q", "decl_nm": "category_theory.limits.parallel_pair_hom_app_one"}
{"formal_statement": "theorem eventually_countable_ball {\u03b9 \u03b1 : Type*} {l : filter \u03b1} [countable_Inter_filter l]\n\t{S : set \u03b9} (hS : S.countable) :\n\t\u2200 {p : \u03b1 \u2192 \u03a0 (i : \u03b9), i \u2208 S \u2192 Prop}, (\u2200\u1da0 (x : \u03b1) in l, \u2200 (i : \u03b9) (H : i \u2208 S), p x i H) \u2194 \u2200 (i : \u03b9)\n\t(H : i \u2208 S), \u2200\u1da0 (x : \u03b1) in l, p x i H", "decl_tp": "\u2200 {\u03b9 : Type u_1} {\u03b1 : Type u_2} {l : filter \u03b1} [_inst_1 : countable_Inter_filter l] {S : set \u03b9}, S.countable \u2192 \u2200 {p : \u03b1 \u2192 \u03a0 (i : \u03b9), i \u2208 S \u2192 Prop}, (\u2200\u1da0 (x : \u03b1) in l, \u2200 (i : \u03b9) (H : i \u2208 S), p x i H) \u2194 \u2200 (i : \u03b9) (H : i \u2208 S), \u2200\u1da0 (x : \u03b1) in l, p x i H", "decl_nm": "eventually_countable_ball"}
{"formal_statement": "theorem union_mem_iff {\u03b1 : Type u} {f : ultrafilter \u03b1} {s t : set \u03b1} :\n\ts \u222a t \u2208 f \u2194 s \u2208 f \u2228 t \u2208 f", "decl_tp": "\u2200 {\u03b1 : Type u} {f : ultrafilter \u03b1} {s t : set \u03b1}, s \u222a t \u2208 f \u2194 s \u2208 f \u2228 t \u2208 f", "decl_nm": "ultrafilter.union_mem_iff"}
{"formal_statement": "theorem coprime_of_coprime {x y z : \u2124} (h : pythagorean_triple x y z) (hc : x.gcd y = 1) :\n\ty.gcd z = 1", "decl_tp": "\u2200 {x y z : \u2124}, pythagorean_triple x y z \u2192 x.gcd y = 1 \u2192 y.gcd z = 1", "decl_nm": "pythagorean_triple.coprime_of_coprime"}
{"formal_statement": "theorem restrict {C : Type u\u2081} [category_theory.category C] {P : C\u1d52\u1d56 \u2964 Type w}\n\t{X : C} {R\u2081 R\u2082 : category_theory.presieve X} (h : R\u2081 \u2264 R\u2082) {x : category_theory.presieve.family_of_elements P R\u2082}\n\t(q : x.compatible) :\n\t(category_theory.presieve.family_of_elements.restrict h x).compatible", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {P : C\u1d52\u1d56 \u2964 Type w} {X : C} {R\u2081 R\u2082 : category_theory.presieve X} (h : R\u2081 \u2264 R\u2082) {x : category_theory.presieve.family_of_elements P R\u2082}, x.compatible \u2192 (category_theory.presieve.family_of_elements.restrict h x).compatible", "decl_nm": "category_theory.presieve.family_of_elements.compatible.restrict"}
{"formal_statement": "theorem le_prod_nonempty_of_submultiplicative {\u03b9 M N : Type*} [comm_monoid M]\n\t[ordered_comm_monoid N] (f : M \u2192 N) (hs : s.nonempty) :\n\t(\u2200 (x y : M), f (x * y) \u2264 f x * f y) \u2192 \u2200 {s : finset \u03b9},  \u2200 (g : \u03b9 \u2192 M), f (s.prod (\u03bb (i : \u03b9), g i)) \u2264 s.prod (\u03bb (i : \u03b9), f (g i))", "decl_tp": "\u2200 {\u03b9 : Type u_1} {M : Type u_4} {N : Type u_5} [_inst_1 : comm_monoid M] [_inst_2 : ordered_comm_monoid N] (f : M \u2192 N), (\u2200 (x y : M), f (x * y) \u2264 f x * f y) \u2192 \u2200 {s : finset \u03b9}, s.nonempty \u2192 \u2200 (g : \u03b9 \u2192 M), f (s.prod (\u03bb (i : \u03b9), g i)) \u2264 s.prod (\u03bb (i : \u03b9), f (g i))", "decl_nm": "finset.le_prod_nonempty_of_submultiplicative"}
{"formal_statement": "theorem continuous {\u03b1 : Type u} {\u03b2 : Type v} [pseudo_emetric_space \u03b1] [pseudo_emetric_space \u03b2]\n\t(h : \u03b1 \u2243\u1d62 \u03b2) :\n\tcontinuous \u21d1h", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : pseudo_emetric_space \u03b1] [_inst_2 : pseudo_emetric_space \u03b2] (h : \u03b1 \u2243\u1d62 \u03b2), continuous \u21d1h", "decl_nm": "isometric.continuous"}
{"formal_statement": "theorem nth_le_of_fn' {\u03b1 : Type u} {n : \u2115} (f : fin n \u2192 \u03b1) {i : \u2115} (h : i < (list.of_fn f).length) :\n\t(list.of_fn f).nth_le i h = f \u27e8i, _\u27e9", "decl_tp": "\u2200 {\u03b1 : Type u} {n : \u2115} (f : fin n \u2192 \u03b1) {i : \u2115} (h : i < (list.of_fn f).length), (list.of_fn f).nth_le i h = f \u27e8i, _\u27e9", "decl_nm": "list.nth_le_of_fn'"}
{"formal_statement": "theorem mk' {\u03b1 : Type v} {S : Type w} (e : \u03b1 \u2243 S) :\n\tsmall \u03b1", "decl_tp": "\u2200 {\u03b1 : Type v} {S : Type w}, \u03b1 \u2243 S \u2192 small \u03b1", "decl_nm": "small.mk'"}
{"formal_statement": "theorem imp {\u03b1 \u03b2 : Type*} {R S : \u03b1 \u2192 \u03b2 \u2192 Prop} (h : list.forall\u2082 R l\u2081 l\u2082) :\n\t(\u2200 (a : \u03b1) (b : \u03b2), R a b \u2192 S a b) \u2192 \u2200 {l\u2081 : list \u03b1} {l\u2082 : list \u03b2},  list.forall\u2082 S l\u2081 l\u2082", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {R S : \u03b1 \u2192 \u03b2 \u2192 Prop}, (\u2200 (a : \u03b1) (b : \u03b2), R a b \u2192 S a b) \u2192 \u2200 {l\u2081 : list \u03b1} {l\u2082 : list \u03b2}, list.forall\u2082 R l\u2081 l\u2082 \u2192 list.forall\u2082 S l\u2081 l\u2082", "decl_nm": "list.forall\u2082.imp"}
{"formal_statement": "theorem option_bind {\u03b1 \u03b2 \u03c3 : Type*} [primcodable \u03b1] [primcodable \u03b2] [primcodable \u03c3]\n\t{f : \u03b1 \u2192 option \u03b2} {g : \u03b1 \u2192 \u03b2 \u2192 option \u03c3} (hf : computable f) (hg : computable\u2082 g) :\n\tcomputable (\u03bb (a : \u03b1), (f a).bind (g a))", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {\u03c3 : Type u_4} [_inst_1 : primcodable \u03b1] [_inst_2 : primcodable \u03b2] [_inst_4 : primcodable \u03c3] {f : \u03b1 \u2192 option \u03b2} {g : \u03b1 \u2192 \u03b2 \u2192 option \u03c3}, computable f \u2192 computable\u2082 g \u2192 computable (\u03bb (a : \u03b1), (f a).bind (g a))", "decl_nm": "computable.option_bind"}
{"formal_statement": "theorem finite_type_iff_fg {R M : Type*} [comm_monoid M] [comm_ring R]\n\t[nontrivial R] :\n\talgebra.finite_type R (monoid_algebra R M) \u2194 monoid.fg M", "decl_tp": "\u2200 {R : Type u_1} {M : Type u_2} [_inst_1 : comm_monoid M] [_inst_2 : comm_ring R] [_inst_3 : nontrivial R], algebra.finite_type R (monoid_algebra R M) \u2194 monoid.fg M", "decl_nm": "monoid_algebra.finite_type_iff_fg"}
{"formal_statement": "theorem ediam_univ_of_noncompact {\u03b1 : Type u} [pseudo_metric_space \u03b1] [proper_space \u03b1]\n\t[noncompact_space \u03b1] :\n\temetric.diam set.univ = \u22a4", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : pseudo_metric_space \u03b1] [_inst_2 : proper_space \u03b1] [_inst_3 : noncompact_space \u03b1], emetric.diam set.univ = \u22a4", "decl_nm": "metric.ediam_univ_of_noncompact"}
{"formal_statement": "theorem map_matrix_apply {m : Type*} {\u03b1 : Type v} {\u03b2 : Type w} [fintype m]\n\t[decidable_eq m] [non_assoc_semiring \u03b1] [non_assoc_semiring \u03b2] (f : \u03b1 \u2243+* \u03b2)\n\t(M : matrix m m \u03b1) :\n\t\u21d1(f.map_matrix) M = M.map \u21d1f", "decl_tp": "\u2200 {m : Type u_2} {\u03b1 : Type v} {\u03b2 : Type w} [_inst_1 : fintype m] [_inst_2 : decidable_eq m] [_inst_3 : non_assoc_semiring \u03b1] [_inst_4 : non_assoc_semiring \u03b2] (f : \u03b1 \u2243+* \u03b2) (M : matrix m m \u03b1), \u21d1(f.map_matrix) M = M.map \u21d1f", "decl_nm": "ring_equiv.map_matrix_apply"}
{"formal_statement": "theorem mem_ext_chart_at_ind_source {\u03b9 : Type u\u03b9} {E : Type uE} [normed_group E]\n\t[normed_space \u211d E] [finite_dimensional \u211d E] {H : Type uH} [topological_space H]\n\t{I : model_with_corners \u211d E H} {M : Type uM} [topological_space M] [charted_space H M]\n\t[smooth_manifold_with_corners I M] {s : set M} (fs : smooth_bump_covering \u03b9 I M s)\n\t(x : M) (hx : x \u2208 s) :\n\tx \u2208 (ext_chart_at I (fs.c (fs.ind x hx))).source", "decl_tp": "\u2200 {\u03b9 : Type u\u03b9} {E : Type uE} [_inst_1 : normed_group E] [_inst_2 : normed_space \u211d E] [_inst_3 : finite_dimensional \u211d E] {H : Type uH} [_inst_4 : topological_space H] {I : model_with_corners \u211d E H} {M : Type uM} [_inst_5 : topological_space M] [_inst_6 : charted_space H M] [_inst_7 : smooth_manifold_with_corners I M] {s : set M} (fs : smooth_bump_covering \u03b9 I M s) (x : M) (hx : x \u2208 s), x \u2208 (ext_chart_at I (fs.c (fs.ind x hx))).source", "decl_nm": "smooth_bump_covering.mem_ext_chart_at_ind_source"}
{"formal_statement": "theorem add_le_of_le_sub_right {\u03b1 : Type u} [add_group \u03b1] [has_le \u03b1] [covariant_class \u03b1 \u03b1 (function.swap has_add.add) has_le.le]\n\t{a b c : \u03b1} :\n\ta \u2264 c - b \u2192 a + b \u2264 c", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : add_group \u03b1] [_inst_2 : has_le \u03b1] [_inst_3 : covariant_class \u03b1 \u03b1 (function.swap has_add.add) has_le.le] {a b c : \u03b1}, a \u2264 c - b \u2192 a + b \u2264 c", "decl_nm": "add_le_of_le_sub_right"}
{"formal_statement": "theorem rotate_hom\u2083 {C : Type u} [category_theory.category C] [category_theory.preadditive C]\n\t[category_theory.has_shift C \u2124] {T\u2081 T\u2082 : category_theory.triangulated.triangle C}\n\t(f : category_theory.triangulated.triangle_morphism T\u2081 T\u2082) :\n\tf.rotate.hom\u2083 = (category_theory.shift_functor C 1).map f.hom\u2081", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] [_inst_2 : category_theory.preadditive C] [_inst_3 : category_theory.has_shift C \u2124] {T\u2081 T\u2082 : category_theory.triangulated.triangle C} (f : category_theory.triangulated.triangle_morphism T\u2081 T\u2082), f.rotate.hom\u2083 = (category_theory.shift_functor C 1).map f.hom\u2081", "decl_nm": "category_theory.triangulated.triangle_morphism.rotate_hom\u2083"}
{"formal_statement": "theorem decidable_imp_symm {a b : Prop} [decidable a] :\n\t(\u00aca \u2192 b) \u2192 \u00acb \u2192 a", "decl_tp": "\u2200 {a b : Prop} [_inst_1 : decidable a], (\u00aca \u2192 b) \u2192 \u00acb \u2192 a", "decl_nm": "not.decidable_imp_symm"}
{"formal_statement": "theorem is_integral {R : Type u} {M : Type v} [comm_ring R] [nontrivial R]\n\t[add_comm_group M] [module R M] [module.free R M] [module.finite R M]\n\t(f : M \u2192\u2097[R] M) :\n\tis_integral R f", "decl_tp": "\u2200 {R : Type u} {M : Type v} [_inst_1 : comm_ring R] [_inst_2 : nontrivial R] [_inst_3 : add_comm_group M] [_inst_4 : module R M] [_inst_5 : module.free R M] [_inst_6 : module.finite R M] (f : M \u2192\u2097[R] M), is_integral R f", "decl_nm": "linear_map.is_integral"}
{"formal_statement": "theorem adjoin_simple_adjoin_simple (F : Type*) [field F] {E : Type*} [field E]\n\t[algebra F E] (\u03b1 \u03b2 : E) :\n\t\u2191(\u21a5F\u27ee\u03b1\u27ef)\u27ee\u03b2\u27ef = F\u27ee\u03b1, \u03b2\u27ef", "decl_tp": "\u2200 (F : Type u_1) [_inst_1 : field F] {E : Type u_2} [_inst_2 : field E] [_inst_3 : algebra F E] (\u03b1 \u03b2 : E), \u2191(\u21a5F\u27ee\u03b1\u27ef)\u27ee\u03b2\u27ef = F\u27ee\u03b1, \u03b2\u27ef", "decl_nm": "intermediate_field.adjoin_simple_adjoin_simple"}
{"formal_statement": "theorem log_le_iff_le_exp {x y : \u211d} (hx : 0 < x) :\n\t(real.log x \u2264 y \u2194 x \u2264 real.exp y)", "decl_tp": "\u2200 {x y : \u211d}, 0 < x \u2192 (real.log x \u2264 y \u2194 x \u2264 real.exp y)", "decl_nm": "real.log_le_iff_le_exp"}
{"formal_statement": "theorem gcd_comm {\u03b1 : Type*} [cancel_comm_monoid_with_zero \u03b1] [normalized_gcd_monoid \u03b1]\n\t(a b : \u03b1) :\n\tgcd_monoid.gcd a b = gcd_monoid.gcd b a", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : cancel_comm_monoid_with_zero \u03b1] [_inst_2 : normalized_gcd_monoid \u03b1] (a b : \u03b1), gcd_monoid.gcd a b = gcd_monoid.gcd b a", "decl_nm": "gcd_comm"}
{"formal_statement": "theorem dist {\u03b1 : Type u} {\u03b2 : Type v} [pseudo_metric_space \u03b1] [topological_space \u03b2]\n\t{f g : \u03b2 \u2192 \u03b1} (hf : continuous f) (hg : continuous g) :\n\tcontinuous (\u03bb (b : \u03b2), has_dist.dist (f b) (g b))", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : pseudo_metric_space \u03b1] [_inst_2 : topological_space \u03b2] {f g : \u03b2 \u2192 \u03b1}, continuous f \u2192 continuous g \u2192 continuous (\u03bb (b : \u03b2), has_dist.dist (f b) (g b))", "decl_nm": "continuous.dist"}
{"formal_statement": "theorem log_lt {b x c : ordinal} (b1 : 1 < b) (x0 : 0 < x) :\n\t(b.log x < c \u2194 x < b ^ c)", "decl_tp": "\u2200 {b x c : ordinal}, 1 < b \u2192 0 < x \u2192 (b.log x < c \u2194 x < b ^ c)", "decl_nm": "ordinal.log_lt"}
{"formal_statement": "theorem diag_coe {\u03b1 : Type*} [preorder \u03b1] (x : \u03b1) :\n\t\u21d1order_hom.diag x = (x, x)", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : preorder \u03b1] (x : \u03b1), \u21d1order_hom.diag x = (x, x)", "decl_nm": "order_hom.diag_coe"}
{"formal_statement": "theorem reduce_option_nth_iff {\u03b1 : Type u} {l : list (option \u03b1)} {x : \u03b1} :\n\t(\u2203 (i : \u2115), l.nth i = option.some (option.some x)) \u2194 \u2203 (i : \u2115), l.reduce_option.nth i = option.some x", "decl_tp": "\u2200 {\u03b1 : Type u} {l : list (option \u03b1)} {x : \u03b1}, (\u2203 (i : \u2115), l.nth i = option.some (option.some x)) \u2194 \u2203 (i : \u2115), l.reduce_option.nth i = option.some x", "decl_nm": "list.reduce_option_nth_iff"}
{"formal_statement": "theorem mul_val_succ {\u03b1 : Type u} {m : \u2115} {n' o' : Type*} [semiring \u03b1]\n\t[fintype n'] (A : matrix (fin m.succ) n' \u03b1) (B : matrix n' o' \u03b1) (i : fin m)\n\t(j : o') :\n\tA.mul B i.succ j = matrix.mul (matrix.vec_tail A) B i j", "decl_tp": "\u2200 {\u03b1 : Type u} {m : \u2115} {n' : Type u_2} {o' : Type u_3} [_inst_1 : semiring \u03b1] [_inst_2 : fintype n'] (A : matrix (fin m.succ) n' \u03b1) (B : matrix n' o' \u03b1) (i : fin m) (j : o'), A.mul B i.succ j = matrix.mul (matrix.vec_tail A) B i j", "decl_nm": "matrix.mul_val_succ"}
{"formal_statement": "theorem total_variation_mutually_singular_iff {\u03b1 : Type*} [measurable_space \u03b1]\n\t(s : measure_theory.signed_measure \u03b1) (\u03bc : measure_theory.measure \u03b1) :\n\ts.total_variation.mutually_singular \u03bc \u2194 s.to_jordan_decomposition.pos_part.mutually_singular \u03bc \u2227 s.to_jordan_decomposition.neg_part.mutually_singular \u03bc", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : measurable_space \u03b1] (s : measure_theory.signed_measure \u03b1) (\u03bc : measure_theory.measure \u03b1), s.total_variation.mutually_singular \u03bc \u2194 s.to_jordan_decomposition.pos_part.mutually_singular \u03bc \u2227 s.to_jordan_decomposition.neg_part.mutually_singular \u03bc", "decl_nm": "measure_theory.signed_measure.total_variation_mutually_singular_iff"}
{"formal_statement": "theorem mk_sub {R M : Type*} {x y : M} [ring R] [add_comm_group M] [module R M]\n\t(p : submodule R M) :\n\tsubmodule.quotient.mk (x - y) = submodule.quotient.mk x - submodule.quotient.mk y", "decl_tp": "\u2200 {R : Type u_1} {M : Type u_2} {x y : M} [_inst_1 : ring R] [_inst_2 : add_comm_group M] [_inst_3 : module R M] (p : submodule R M), submodule.quotient.mk (x - y) = submodule.quotient.mk x - submodule.quotient.mk y", "decl_nm": "submodule.quotient.mk_sub"}
{"formal_statement": "theorem eq_univ_of_subset {\u03b1 : Type u} {s t : set \u03b1} (h : s \u2286 t) (hs : s = set.univ) :\n\tt = set.univ", "decl_tp": "\u2200 {\u03b1 : Type u} {s t : set \u03b1}, s \u2286 t \u2192 s = set.univ \u2192 t = set.univ", "decl_nm": "set.eq_univ_of_subset"}
{"formal_statement": "theorem mk_zero {\u03b1 : Type*} :\n\t{val := 0, nodup := _} = \u2205", "decl_tp": "\u2200 {\u03b1 : Type u_1}, {val := 0, nodup := _} = \u2205", "decl_nm": "finset.mk_zero"}
{"formal_statement": "theorem coe_smul {R : Type*} [comm_semiring R] {A : Type*} [comm_semiring A]\n\t[algebra R A] {M : Type*} [add_comm_monoid M] [module A M] [module R M]\n\t{S : Type*} [monoid S] [distrib_mul_action S M] [smul_comm_class R S M]\n\t[smul_comm_class S A M] (r : S) (D : derivation R A M) :\n\t\u21d1(r \u2022 D) = r \u2022 \u21d1D", "decl_tp": "\u2200 {R : Type u_1} [_inst_1 : comm_semiring R] {A : Type u_2} [_inst_2 : comm_semiring A] [_inst_3 : algebra R A] {M : Type u_3} [_inst_4 : add_comm_monoid M] [_inst_5 : module A M] [_inst_6 : module R M] {S : Type u_4} [_inst_7 : monoid S] [_inst_8 : distrib_mul_action S M] [_inst_9 : smul_comm_class R S M] [_inst_10 : smul_comm_class S A M] (r : S) (D : derivation R A M), \u21d1(r \u2022 D) = r \u2022 \u21d1D", "decl_nm": "derivation.coe_smul"}
{"formal_statement": "theorem frontier_Ioi' {\u03b1 : Type u} [topological_space \u03b1] [linear_order \u03b1]\n\t[order_topology \u03b1] [densely_ordered \u03b1] {a : \u03b1} (ha : (set.Ioi a).nonempty) :\n\tfrontier (set.Ioi a) = {a}", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : topological_space \u03b1] [_inst_2 : linear_order \u03b1] [_inst_3 : order_topology \u03b1] [_inst_4 : densely_ordered \u03b1] {a : \u03b1}, (set.Ioi a).nonempty \u2192 frontier (set.Ioi a) = {a}", "decl_nm": "frontier_Ioi'"}
{"formal_statement": "theorem Icc_extend_right {\u03b1 \u03b2 : Type*} [linear_order \u03b1] {a b : \u03b1} (h : a \u2264 b)\n\t(f : \u21a5(set.Icc a b) \u2192 \u03b2) :\n\tset.Icc_extend h f b = f \u27e8b, _\u27e9", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : linear_order \u03b1] {a b : \u03b1} (h : a \u2264 b) (f : \u21a5(set.Icc a b) \u2192 \u03b2), set.Icc_extend h f b = f \u27e8b, _\u27e9", "decl_nm": "set.Icc_extend_right"}
{"formal_statement": "theorem aeval_def {R : Type u} {S\u2081 : Type v} {\u03c3 : Type*} [comm_semiring R]\n\t[comm_semiring S\u2081] [algebra R S\u2081] (f : \u03c3 \u2192 S\u2081) (p : mv_polynomial \u03c3 R) :\n\t\u21d1(mv_polynomial.aeval f) p = mv_polynomial.eval\u2082 (algebra_map R S\u2081) f p", "decl_tp": "\u2200 {R : Type u} {S\u2081 : Type v} {\u03c3 : Type u_1} [_inst_1 : comm_semiring R] [_inst_2 : comm_semiring S\u2081] [_inst_3 : algebra R S\u2081] (f : \u03c3 \u2192 S\u2081) (p : mv_polynomial \u03c3 R), \u21d1(mv_polynomial.aeval f) p = mv_polynomial.eval\u2082 (algebra_map R S\u2081) f p", "decl_nm": "mv_polynomial.aeval_def"}
{"formal_statement": "theorem whisker_left_iso_hom {B : Type u} [category_theory.bicategory B]\n\t{a b c : B} (f : a \u27f6 b) {g h : b \u27f6 c} (\u03b7 : g \u2245 h) :\n\t(category_theory.bicategory.whisker_left_iso f \u03b7).hom = category_theory.bicategory.whisker_left f \u03b7.hom", "decl_tp": "\u2200 {B : Type u} [_inst_1 : category_theory.bicategory B] {a b c : B} (f : a \u27f6 b) {g h : b \u27f6 c} (\u03b7 : g \u2245 h), (category_theory.bicategory.whisker_left_iso f \u03b7).hom = category_theory.bicategory.whisker_left f \u03b7.hom", "decl_nm": "category_theory.bicategory.whisker_left_iso_hom"}
{"formal_statement": "theorem cocone_morphism_hom {J : Type u\u2081} [category_theory.category J]\n\t{C : Type u} [category_theory.category C] {F : J \u2964 C} [category_theory.limits.has_colimit F]\n\t(c : category_theory.limits.cocone F) :\n\t(category_theory.limits.colimit.cocone_morphism c).hom = category_theory.limits.colimit.desc F c", "decl_tp": "\u2200 {J : Type u\u2081} [_inst_1 : category_theory.category J] {C : Type u} [_inst_3 : category_theory.category C] {F : J \u2964 C} [_inst_4 : category_theory.limits.has_colimit F] (c : category_theory.limits.cocone F), (category_theory.limits.colimit.cocone_morphism c).hom = category_theory.limits.colimit.desc F c", "decl_nm": "category_theory.limits.colimit.cocone_morphism_hom"}
{"formal_statement": "theorem comap_sup_eq {G : Type*} [group G] {N : Type*} [group N] (f : G \u2192* N)\n\t(H K : subgroup N) (hf : function.surjective \u21d1f) :\n\tsubgroup.comap f H \u2294 subgroup.comap f K = subgroup.comap f (H \u2294 K)", "decl_tp": "\u2200 {G : Type u_1} [_inst_1 : group G] {N : Type u_3} [_inst_3 : group N] (f : G \u2192* N) (H K : subgroup N), function.surjective \u21d1f \u2192 subgroup.comap f H \u2294 subgroup.comap f K = subgroup.comap f (H \u2294 K)", "decl_nm": "subgroup.comap_sup_eq"}
{"formal_statement": "theorem csupr_empty {\u03b1 : Sort u_1} [is_empty \u03b1] (f : \u03b1 \u2192 \u211d) :\n\t(\u2a06 (i : \u03b1), f i) = 0", "decl_tp": "\u2200 {\u03b1 : Sort u_1} [_inst_1 : is_empty \u03b1] (f : \u03b1 \u2192 \u211d), (\u2a06 (i : \u03b1), f i) = 0", "decl_nm": "real.csupr_empty"}
{"formal_statement": "theorem Union_union_compl_to_subordinate_boxes {\u03b9 : Type*} [fintype \u03b9]\n\t{I : box_integral.box \u03b9} (\u03c0\u2081 : box_integral.tagged_prepartition I) (\u03c0\u2082 : box_integral.prepartition I)\n\t(hU : \u03c0\u2082.Union = \u2191I \\ \u03c0\u2081.Union) (r : (\u03b9 \u2192 \u211d) \u2192 \u21a5(set.Ioi 0)) :\n\t(\u03c0\u2081.union_compl_to_subordinate \u03c0\u2082 hU r).Union = \u2191I", "decl_tp": "\u2200 {\u03b9 : Type u_1} [_inst_1 : fintype \u03b9] {I : box_integral.box \u03b9} (\u03c0\u2081 : box_integral.tagged_prepartition I) (\u03c0\u2082 : box_integral.prepartition I) (hU : \u03c0\u2082.Union = \u2191I \\ \u03c0\u2081.Union) (r : (\u03b9 \u2192 \u211d) \u2192 \u21a5(set.Ioi 0)), (\u03c0\u2081.union_compl_to_subordinate \u03c0\u2082 hU r).Union = \u2191I", "decl_nm": "box_integral.tagged_prepartition.Union_union_compl_to_subordinate_boxes"}
{"formal_statement": "theorem inv_rev {\u03b1 \ud835\udd5c : Type*1} {\ud835\udd5c' : Type*2} [normed_field \ud835\udd5c] [normed_field \ud835\udd5c']\n\t{l : filter \u03b1} {f : \u03b1 \u2192 \ud835\udd5c} {g : \u03b1 \u2192 \ud835\udd5c'} (h : asymptotics.is_o f g l) :\n\t(\u2200\u1da0 (x : \u03b1) in l, f x \u2260 0) \u2192 asymptotics.is_o (\u03bb (x : \u03b1), (g x)\u207b\u00b9) (\u03bb (x : \u03b1), (f x)\u207b\u00b9) l", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\ud835\udd5c : Type u_11} {\ud835\udd5c' : Type u_12} [_inst_9 : normed_field \ud835\udd5c] [_inst_10 : normed_field \ud835\udd5c'] {l : filter \u03b1} {f : \u03b1 \u2192 \ud835\udd5c} {g : \u03b1 \u2192 \ud835\udd5c'}, asymptotics.is_o f g l \u2192 (\u2200\u1da0 (x : \u03b1) in l, f x \u2260 0) \u2192 asymptotics.is_o (\u03bb (x : \u03b1), (g x)\u207b\u00b9) (\u03bb (x : \u03b1), (f x)\u207b\u00b9) l", "decl_nm": "asymptotics.is_o.inv_rev"}
{"formal_statement": "theorem limit_ext {C : Type u} [category_theory.category C] [category_theory.concrete_category C]\n\t{J : Type v} [category_theory.small_category J] (F : J \u2964 C) [category_theory.limits.preserves_limit F (category_theory.forget C)]\n\t[category_theory.limits.has_limit F] (x y : \u21a5(category_theory.limits.limit F)) :\n\t(\u2200 (j : J), \u21d1(category_theory.limits.limit.\u03c0 F j) x = \u21d1(category_theory.limits.limit.\u03c0 F j) y) \u2192 x = y", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] [_inst_2 : category_theory.concrete_category C] {J : Type v} [_inst_3 : category_theory.small_category J] (F : J \u2964 C) [_inst_4 : category_theory.limits.preserves_limit F (category_theory.forget C)] [_inst_5 : category_theory.limits.has_limit F] (x y : \u21a5(category_theory.limits.limit F)), (\u2200 (j : J), \u21d1(category_theory.limits.limit.\u03c0 F j) x = \u21d1(category_theory.limits.limit.\u03c0 F j) y) \u2192 x = y", "decl_nm": "category_theory.limits.concrete.limit_ext"}
{"formal_statement": "theorem range_mem_map {\u03b1 : Type u} {\u03b2 : Type v} {f : filter \u03b1} {m : \u03b1 \u2192 \u03b2} :\n\tset.range m \u2208 filter.map m f", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {f : filter \u03b1} {m : \u03b1 \u2192 \u03b2}, set.range m \u2208 filter.map m f", "decl_nm": "filter.range_mem_map"}
{"formal_statement": "theorem mk_eq {\u03b1 : Type*} [linear_ordered_field \u03b1] {\u03b2 : Type*} [comm_ring \u03b2]\n\t{abv : \u03b2 \u2192 \u03b1} [is_absolute_value abv] {f g : cau_seq \u03b2 abv} :\n\tcau_seq.completion.mk f = cau_seq.completion.mk g \u2194 f \u2248 g", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : linear_ordered_field \u03b1] {\u03b2 : Type u_2} [_inst_2 : comm_ring \u03b2] {abv : \u03b2 \u2192 \u03b1} [_inst_3 : is_absolute_value abv] {f g : cau_seq \u03b2 abv}, cau_seq.completion.mk f = cau_seq.completion.mk g \u2194 f \u2248 g", "decl_nm": "cau_seq.completion.mk_eq"}
{"formal_statement": "theorem uniq {C : Type u} [category_theory.category C] {X Y : C} {f : X \u27f6 Y}\n\t[category_theory.limits.has_image f] (F' : category_theory.limits.mono_factorisation f)\n\t(l : category_theory.limits.image f \u27f6 F'.I) (w : l \u226b F'.m = category_theory.limits.image.\u03b9 f) :\n\tl = category_theory.limits.image.lift F'", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] {X Y : C} {f : X \u27f6 Y} [_inst_2 : category_theory.limits.has_image f] (F' : category_theory.limits.mono_factorisation f) (l : category_theory.limits.image f \u27f6 F'.I), l \u226b F'.m = category_theory.limits.image.\u03b9 f \u2192 l = category_theory.limits.image.lift F'", "decl_nm": "category_theory.limits.has_image.uniq"}
{"formal_statement": "theorem comap_equiv_eq_map_symm {R R\u2082 M M\u2082 : Type*2} [comm_semiring R]\n\t[comm_semiring R\u2082] [add_comm_monoid M] [add_comm_monoid M\u2082] [module R M]\n\t[module R\u2082 M\u2082] {\u03c4\u2081\u2082 : R \u2192+* R\u2082} {\u03c4\u2082\u2081 : R\u2082 \u2192+* R} [ring_hom_inv_pair \u03c4\u2081\u2082 \u03c4\u2082\u2081]\n\t[ring_hom_inv_pair \u03c4\u2082\u2081 \u03c4\u2081\u2082] (e : M \u2243\u209b\u2097[\u03c4\u2081\u2082] M\u2082) (K : submodule R\u2082 M\u2082) :\n\tsubmodule.comap \u2191e K = submodule.map \u2191(e.symm) K", "decl_tp": "\u2200 {R : Type u_1} {R\u2082 : Type u_3} {M : Type u_9} {M\u2082 : Type u_12} [_inst_1 : comm_semiring R] [_inst_2 : comm_semiring R\u2082] [_inst_3 : add_comm_monoid M] [_inst_4 : add_comm_monoid M\u2082] [_inst_5 : module R M] [_inst_6 : module R\u2082 M\u2082] {\u03c4\u2081\u2082 : R \u2192+* R\u2082} {\u03c4\u2082\u2081 : R\u2082 \u2192+* R} [_inst_11 : ring_hom_inv_pair \u03c4\u2081\u2082 \u03c4\u2082\u2081] [_inst_12 : ring_hom_inv_pair \u03c4\u2082\u2081 \u03c4\u2081\u2082] (e : M \u2243\u209b\u2097[\u03c4\u2081\u2082] M\u2082) (K : submodule R\u2082 M\u2082), submodule.comap \u2191e K = submodule.map \u2191(e.symm) K", "decl_nm": "submodule.comap_equiv_eq_map_symm"}
{"formal_statement": "theorem inf_le_left {\u03b1 : Type u} [semilattice_inf \u03b1] {a b : \u03b1} :\n\ta \u2293 b \u2264 a", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : semilattice_inf \u03b1] {a b : \u03b1}, a \u2293 b \u2264 a", "decl_nm": "inf_le_left"}
{"formal_statement": "theorem mk_range_eq {\u03b1 \u03b2 : Type u} (f : \u03b1 \u2192 \u03b2) (h : function.injective f) :\n\tcardinal.mk \u21a5(set.range f) = cardinal.mk \u03b1", "decl_tp": "\u2200 {\u03b1 \u03b2 : Type u} (f : \u03b1 \u2192 \u03b2), function.injective f \u2192 cardinal.mk \u21a5(set.range f) = cardinal.mk \u03b1", "decl_nm": "cardinal.mk_range_eq"}
{"formal_statement": "theorem exists_of_ssubset {\u03b1 : Type u} {s t : set \u03b1} (h : s \u2282 t) :\n\t(\u2203 (x : \u03b1) (H : x \u2208 t), x \u2209 s)", "decl_tp": "\u2200 {\u03b1 : Type u} {s t : set \u03b1}, s \u2282 t \u2192 (\u2203 (x : \u03b1) (H : x \u2208 t), x \u2209 s)", "decl_nm": "set.exists_of_ssubset"}
{"formal_statement": "theorem to_LocallyRingedSpace_to_SheafedSpace {X : algebraic_geometry.PresheafedSpace CommRing}\n\t(Y : algebraic_geometry.LocallyRingedSpace) (f : X \u27f6 Y.to_SheafedSpace.to_PresheafedSpace)\n\t[H : algebraic_geometry.PresheafedSpace.is_open_immersion f] :\n\t(algebraic_geometry.PresheafedSpace.is_open_immersion.to_LocallyRingedSpace Y f).to_SheafedSpace = algebraic_geometry.PresheafedSpace.is_open_immersion.to_SheafedSpace Y.to_SheafedSpace f", "decl_tp": "\u2200 {X : algebraic_geometry.PresheafedSpace CommRing} (Y : algebraic_geometry.LocallyRingedSpace) (f : X \u27f6 Y.to_SheafedSpace.to_PresheafedSpace) [H : algebraic_geometry.PresheafedSpace.is_open_immersion f], (algebraic_geometry.PresheafedSpace.is_open_immersion.to_LocallyRingedSpace Y f).to_SheafedSpace = algebraic_geometry.PresheafedSpace.is_open_immersion.to_SheafedSpace Y.to_SheafedSpace f", "decl_nm": "algebraic_geometry.PresheafedSpace.is_open_immersion.to_LocallyRingedSpace_to_SheafedSpace"}
{"formal_statement": "theorem inverse_eq_inv {G\u2080 : Type*} [group_with_zero G\u2080] (a : G\u2080) :\n\tring.inverse a = a\u207b\u00b9", "decl_tp": "\u2200 {G\u2080 : Type u_2} [_inst_1 : group_with_zero G\u2080] (a : G\u2080), ring.inverse a = a\u207b\u00b9", "decl_nm": "ring.inverse_eq_inv"}
{"formal_statement": "theorem map_matrix_apply {m n R : Type*} {\u03b1 : Type v} {\u03b2 : Type w} [semiring R]\n\t[add_comm_monoid \u03b1] [add_comm_monoid \u03b2] [module R \u03b1] [module R \u03b2] (f : \u03b1 \u2243\u2097[R] \u03b2)\n\t(M : matrix m n \u03b1) :\n\t\u21d1(f.map_matrix) M = M.map \u21d1f", "decl_tp": "\u2200 {m : Type u_2} {n : Type u_3} {R : Type u_7} {\u03b1 : Type v} {\u03b2 : Type w} [_inst_1 : semiring R] [_inst_2 : add_comm_monoid \u03b1] [_inst_3 : add_comm_monoid \u03b2] [_inst_5 : module R \u03b1] [_inst_6 : module R \u03b2] (f : \u03b1 \u2243\u2097[R] \u03b2) (M : matrix m n \u03b1), \u21d1(f.map_matrix) M = M.map \u21d1f", "decl_nm": "linear_equiv.map_matrix_apply"}
{"formal_statement": "theorem mem_of_superset {\u03b1 : Type*} {\u03b9 : Sort u_4} {l : filter \u03b1} {p : \u03b9 \u2192 Prop}\n\t{s : \u03b9 \u2192 set \u03b1} {t : set \u03b1} {i : \u03b9} (hl : l.has_basis p s) (hi : p i)\n\t(ht : s i \u2286 t) :\n\tt \u2208 l", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b9 : Sort u_4} {l : filter \u03b1} {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 set \u03b1} {t : set \u03b1} {i : \u03b9}, l.has_basis p s \u2192 p i \u2192 s i \u2286 t \u2192 t \u2208 l", "decl_nm": "filter.has_basis.mem_of_superset"}
{"formal_statement": "theorem coe_le_coe {R : Type*} [comm_ring R] {S : submonoid R} {P : Type*}\n\t[comm_ring P] [algebra R P] {I J : fractional_ideal S P} :\n\t\u2191I \u2264 \u2191J \u2194 I \u2264 J", "decl_tp": "\u2200 {R : Type u_1} [_inst_1 : comm_ring R] {S : submonoid R} {P : Type u_2} [_inst_2 : comm_ring P] [_inst_3 : algebra R P] {I J : fractional_ideal S P}, \u2191I \u2264 \u2191J \u2194 I \u2264 J", "decl_nm": "fractional_ideal.coe_le_coe"}
{"formal_statement": "theorem prod_ite_eq' {\u03b2 : Type u} {\u03b1 : Type v} [comm_monoid \u03b2] [decidable_eq \u03b1]\n\t(s : finset \u03b1) (a : \u03b1) (b : \u03b1 \u2192 \u03b2) :\n\ts.prod (\u03bb (x : \u03b1), ite (x = a) (b x) 1) = ite (a \u2208 s) (b a) 1", "decl_tp": "\u2200 {\u03b2 : Type u} {\u03b1 : Type v} [_inst_1 : comm_monoid \u03b2] [_inst_2 : decidable_eq \u03b1] (s : finset \u03b1) (a : \u03b1) (b : \u03b1 \u2192 \u03b2), s.prod (\u03bb (x : \u03b1), ite (x = a) (b x) 1) = ite (a \u2208 s) (b a) 1", "decl_nm": "finset.prod_ite_eq'"}
{"formal_statement": "theorem of_nat_one :\n\tonote.of_nat 1 = 1", "decl_tp": "onote.of_nat 1 = 1", "decl_nm": "onote.of_nat_one"}
{"formal_statement": "theorem dvd_span_singleton {A : Type*} [comm_ring A] [is_domain A] [is_dedekind_domain A]\n\t{I : ideal A} {x : A} :\n\tI \u2223 ideal.span {x} \u2194 x \u2208 I", "decl_tp": "\u2200 {A : Type u_2} [_inst_2 : comm_ring A] [_inst_4 : is_domain A] [_inst_5 : is_dedekind_domain A] {I : ideal A} {x : A}, I \u2223 ideal.span {x} \u2194 x \u2208 I", "decl_nm": "ideal.dvd_span_singleton"}
{"formal_statement": "theorem quotient_map_quot_mk {\u03b1 : Type u} [topological_space \u03b1] {r : \u03b1 \u2192 \u03b1 \u2192 Prop} :\n\tquotient_map (quot.mk r)", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : topological_space \u03b1] {r : \u03b1 \u2192 \u03b1 \u2192 Prop}, quotient_map (quot.mk r)", "decl_nm": "quotient_map_quot_mk"}
{"formal_statement": "theorem pure_inj {\u03b1 : Type*} {a b : \u03b1} :\n\thas_pure.pure a = has_pure.pure b \u2194 a = b", "decl_tp": "\u2200 {\u03b1 : Type u_1} {a b : \u03b1}, has_pure.pure a = has_pure.pure b \u2194 a = b", "decl_nm": "semiquot.pure_inj"}
{"formal_statement": "theorem pos_of_le_one {\u03b1 : Type u} [lattice \u03b1] [comm_group \u03b1] (a : \u03b1) (h : a \u2264 1) :\n\ta\u207a = 1", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : lattice \u03b1] [_inst_2 : comm_group \u03b1] (a : \u03b1), a \u2264 1 \u2192 a\u207a = 1", "decl_nm": "lattice_ordered_comm_group.pos_of_le_one"}
{"formal_statement": "theorem unbounded_of_tendsto_at_bot' {\u03b1 \u03b2 : Type*} [nonempty \u03b1] [semilattice_inf \u03b1]\n\t[preorder \u03b2] [no_bot_order \u03b2] {f : \u03b1 \u2192 \u03b2} (h : filter.tendsto f filter.at_bot filter.at_bot) :\n\t\u00acbdd_below (set.range f)", "decl_tp": "\u2200 {\u03b1 : Type u_3} {\u03b2 : Type u_4} [_inst_1 : nonempty \u03b1] [_inst_2 : semilattice_inf \u03b1] [_inst_3 : preorder \u03b2] [_inst_4 : no_bot_order \u03b2] {f : \u03b1 \u2192 \u03b2}, filter.tendsto f filter.at_bot filter.at_bot \u2192 \u00acbdd_below (set.range f)", "decl_nm": "filter.unbounded_of_tendsto_at_bot'"}
{"formal_statement": "theorem smooth_on_snd {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c] {E : Type*}\n\t[normed_group E] [normed_space \ud835\udd5c E] {H : Type*} [topological_space H]\n\t{I : model_with_corners \ud835\udd5c E H} {M : Type*} [topological_space M] [charted_space H M]\n\t{F : Type*} [normed_group F] [normed_space \ud835\udd5c F] {G : Type*} [topological_space G]\n\t{J : model_with_corners \ud835\udd5c F G} {N : Type*0} [topological_space N] [charted_space G N]\n\t{s : set (M \u00d7 N)} :\n\tsmooth_on (I.prod J) J prod.snd s", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {H : Type u_3} [_inst_4 : topological_space H] {I : model_with_corners \ud835\udd5c E H} {M : Type u_4} [_inst_5 : topological_space M] [_inst_6 : charted_space H M] {F : Type u_8} [_inst_12 : normed_group F] [_inst_13 : normed_space \ud835\udd5c F] {G : Type u_9} [_inst_14 : topological_space G] {J : model_with_corners \ud835\udd5c F G} {N : Type u_10} [_inst_15 : topological_space N] [_inst_16 : charted_space G N] {s : set (M \u00d7 N)}, smooth_on (I.prod J) J prod.snd s", "decl_nm": "smooth_on_snd"}
{"formal_statement": "theorem srange_top_of_surjective {R : Type u} {S : Type v} [non_assoc_semiring R]\n\t[non_assoc_semiring S] (f : R \u2192+* S) (hf : function.surjective \u21d1f) :\n\tf.srange = \u22a4", "decl_tp": "\u2200 {R : Type u} {S : Type v} [_inst_1 : non_assoc_semiring R] [_inst_2 : non_assoc_semiring S] (f : R \u2192+* S), function.surjective \u21d1f \u2192 f.srange = \u22a4", "decl_nm": "ring_hom.srange_top_of_surjective"}
{"formal_statement": "theorem permutations_aux2_fst {\u03b1 \u03b2 : Type*} (t : \u03b1) (ts : list \u03b1) (r : list \u03b2)\n\t(ys : list \u03b1) (f : list \u03b1 \u2192 \u03b2) :\n\t(list.permutations_aux2 t ts r ys f).fst = ys ++ ts", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} (t : \u03b1) (ts : list \u03b1) (r : list \u03b2) (ys : list \u03b1) (f : list \u03b1 \u2192 \u03b2), (list.permutations_aux2 t ts r ys f).fst = ys ++ ts", "decl_nm": "list.permutations_aux2_fst"}
{"formal_statement": "theorem sign_symm_trans_trans {\u03b1 : Type u} {\u03b2 : Type v} [decidable_eq \u03b1]\n\t[fintype \u03b1] [decidable_eq \u03b2] [fintype \u03b2] (f : equiv.perm \u03b1) (e : \u03b1 \u2243 \u03b2) :\n\t\u21d1equiv.perm.sign ((e.symm.trans f).trans e) = \u21d1equiv.perm.sign f", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : decidable_eq \u03b1] [_inst_2 : fintype \u03b1] [_inst_3 : decidable_eq \u03b2] [_inst_4 : fintype \u03b2] (f : equiv.perm \u03b1) (e : \u03b1 \u2243 \u03b2), \u21d1equiv.perm.sign ((e.symm.trans f).trans e) = \u21d1equiv.perm.sign f", "decl_nm": "equiv.perm.sign_symm_trans_trans"}
{"formal_statement": "theorem zero_eq_neg {G : Type u} [add_group G] {a : G} :\n\t0 = -a \u2194 a = 0", "decl_tp": "\u2200 {G : Type u} [_inst_1 : add_group G] {a : G}, 0 = -a \u2194 a = 0", "decl_nm": "zero_eq_neg"}
{"formal_statement": "theorem mem_right_transversals_iff_bijective {G : Type*} [add_group G]\n\t{H : add_subgroup G} {S : set G} :\n\tS \u2208 add_subgroup.right_transversals \u2191H \u2194 function.bijective (set.restrict quotient.mk' S)", "decl_tp": "\u2200 {G : Type u_1} [_inst_1 : add_group G] {H : add_subgroup G} {S : set G}, S \u2208 add_subgroup.right_transversals \u2191H \u2194 function.bijective (set.restrict quotient.mk' S)", "decl_nm": "add_subgroup.mem_right_transversals_iff_bijective"}
{"formal_statement": "theorem coe_ne_bot {\u03b1 : Type u} (a : \u03b1) :\n\t\u2191a \u2260 \u22a5", "decl_tp": "\u2200 {\u03b1 : Type u} (a : \u03b1), \u2191a \u2260 \u22a5", "decl_nm": "with_bot.coe_ne_bot"}
{"formal_statement": "theorem pure_seq_eq_map {F : Type u \u2192 Type w} {G : Type v \u2192 Type u} [applicative F]\n\t[applicative G] [is_lawful_applicative F] [is_lawful_applicative G] {\u03b1 \u03b2 : Type v}\n\t(f : \u03b1 \u2192 \u03b2) (x : functor.comp F G \u03b1) :\n\thas_pure.pure f <*> x = f <$> x", "decl_tp": "\u2200 {F : Type u \u2192 Type w} {G : Type v \u2192 Type u} [_inst_1 : applicative F] [_inst_2 : applicative G] [_inst_3 : is_lawful_applicative F] [_inst_4 : is_lawful_applicative G] {\u03b1 \u03b2 : Type v} (f : \u03b1 \u2192 \u03b2) (x : functor.comp F G \u03b1), has_pure.pure f <*> x = f <$> x", "decl_nm": "functor.comp.pure_seq_eq_map"}
{"formal_statement": "theorem le_map_center_mass {\ud835\udd5c E \u03b2 \u03b9 : Type*} [linear_ordered_field \ud835\udd5c] [add_comm_group E]\n\t[ordered_add_comm_group \u03b2] [module \ud835\udd5c E] [module \ud835\udd5c \u03b2] [ordered_smul \ud835\udd5c \u03b2]\n\t{s : set E} {f : E \u2192 \u03b2} {t : finset \u03b9} {w : \u03b9 \u2192 \ud835\udd5c} {p : \u03b9 \u2192 E} (hf : concave_on \ud835\udd5c s f)\n\t(h\u2081 : 0 < t.sum (\u03bb (i : \u03b9), w i)) :\n\t(\u2200 (i : \u03b9), i \u2208 t \u2192 0 \u2264 w i) \u2192  (\u2200 (i : \u03b9), i \u2208 t \u2192 p i \u2208 s) \u2192 t.center_mass w (f \u2218 p) \u2264 f (t.center_mass w p)", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} {E : Type u_2} {\u03b2 : Type u_4} {\u03b9 : Type u_5} [_inst_1 : linear_ordered_field \ud835\udd5c] [_inst_2 : add_comm_group E] [_inst_3 : ordered_add_comm_group \u03b2] [_inst_4 : module \ud835\udd5c E] [_inst_5 : module \ud835\udd5c \u03b2] [_inst_6 : ordered_smul \ud835\udd5c \u03b2] {s : set E} {f : E \u2192 \u03b2} {t : finset \u03b9} {w : \u03b9 \u2192 \ud835\udd5c} {p : \u03b9 \u2192 E}, concave_on \ud835\udd5c s f \u2192 (\u2200 (i : \u03b9), i \u2208 t \u2192 0 \u2264 w i) \u2192 0 < t.sum (\u03bb (i : \u03b9), w i) \u2192 (\u2200 (i : \u03b9), i \u2208 t \u2192 p i \u2208 s) \u2192 t.center_mass w (f \u2218 p) \u2264 f (t.center_mass w p)", "decl_nm": "concave_on.le_map_center_mass"}
{"formal_statement": "theorem is_some_iff_exists {\u03b1 : Type*} {x : option \u03b1} :\n\t\u21a5(x.is_some) \u2194 \u2203 (a : \u03b1), x = option.some a", "decl_tp": "\u2200 {\u03b1 : Type u_1} {x : option \u03b1}, \u21a5(x.is_some) \u2194 \u2203 (a : \u03b1), x = option.some a", "decl_nm": "option.is_some_iff_exists"}
{"formal_statement": "theorem remaining :\n\t\u00acparser.remaining.step", "decl_tp": "\u00acparser.remaining.step", "decl_nm": "parser.step.remaining"}
{"formal_statement": "theorem tendsto_inverse_at_top_nhds_0_nat :\n\tfilter.tendsto (\u03bb (n : \u2115), (\u2191n)\u207b\u00b9) filter.at_top (nhds 0)", "decl_tp": "filter.tendsto (\u03bb (n : \u2115), (\u2191n)\u207b\u00b9) filter.at_top (nhds 0)", "decl_nm": "tendsto_inverse_at_top_nhds_0_nat"}
{"formal_statement": "theorem splits_of_splits_gcd_right {K : Type v} {L : Type w} [field K]\n\t[field L] (i : K \u2192+* L) {f g : polynomial K} (hg0 : g \u2260 0) (hg : polynomial.splits i g) :\n\tpolynomial.splits i (euclidean_domain.gcd f g)", "decl_tp": "\u2200 {K : Type v} {L : Type w} [_inst_1 : field K] [_inst_2 : field L] (i : K \u2192+* L) {f g : polynomial K}, g \u2260 0 \u2192 polynomial.splits i g \u2192 polynomial.splits i (euclidean_domain.gcd f g)", "decl_nm": "polynomial.splits_of_splits_gcd_right"}
{"formal_statement": "theorem exp {E : Type*} [normed_group E] [normed_space \u211d E] {f : E \u2192 \u211d}\n\t{x : E} {n : with_top \u2115} (hf : times_cont_diff_at \u211d n f x) :\n\ttimes_cont_diff_at \u211d n (\u03bb (x : E), real.exp (f x)) x", "decl_tp": "\u2200 {E : Type u_1} [_inst_1 : normed_group E] [_inst_2 : normed_space \u211d E] {f : E \u2192 \u211d} {x : E} {n : with_top \u2115}, times_cont_diff_at \u211d n f x \u2192 times_cont_diff_at \u211d n (\u03bb (x : E), real.exp (f x)) x", "decl_nm": "times_cont_diff_at.exp"}
{"formal_statement": "theorem update_nth_succ {\u03b1 : Type u} (x : \u03b1) (xs : list \u03b1) (n : \u2115) (a : \u03b1) :\n\t(x :: xs).update_nth n.succ a = x :: xs.update_nth n a", "decl_tp": "\u2200 {\u03b1 : Type u} (x : \u03b1) (xs : list \u03b1) (n : \u2115) (a : \u03b1), (x :: xs).update_nth n.succ a = x :: xs.update_nth n a", "decl_nm": "list.update_nth_succ"}
{"formal_statement": "theorem indicator {\u03b1 E : Type*} [measurable_space \u03b1] [normed_group E] [measurable_space E]\n\t{f : \u03b1 \u2192 E} {s : set \u03b1} {\u03bc : measure_theory.measure \u03b1} (h : measure_theory.integrable f \u03bc)\n\t(hs : measurable_set s) :\n\tmeasure_theory.integrable (s.indicator f) \u03bc", "decl_tp": "\u2200 {\u03b1 : Type u_1} {E : Type u_3} [_inst_1 : measurable_space \u03b1] [_inst_2 : normed_group E] [_inst_3 : measurable_space E] {f : \u03b1 \u2192 E} {s : set \u03b1} {\u03bc : measure_theory.measure \u03b1}, measure_theory.integrable f \u03bc \u2192 measurable_set s \u2192 measure_theory.integrable (s.indicator f) \u03bc", "decl_nm": "measure_theory.integrable.indicator"}
{"formal_statement": "theorem prod_map_comap_prod {G : Type*} [group G] {N : Type*} [group N]\n\t{G' N' : Type*} [group G'] [group N'] (f : G \u2192* N) (g : G' \u2192* N') (S : subgroup N)\n\t(S' : subgroup N') :\n\tsubgroup.comap (f.prod_map g) (S.prod S') = (subgroup.comap f S).prod (subgroup.comap g S')", "decl_tp": "\u2200 {G : Type u_1} [_inst_1 : group G] {N : Type u_3} [_inst_3 : group N] {G' : Type u_2} {N' : Type u_4} [_inst_6 : group G'] [_inst_7 : group N'] (f : G \u2192* N) (g : G' \u2192* N') (S : subgroup N) (S' : subgroup N'), subgroup.comap (f.prod_map g) (S.prod S') = (subgroup.comap f S).prod (subgroup.comap g S')", "decl_nm": "monoid_hom.prod_map_comap_prod"}
{"formal_statement": "theorem coe_norm_subgroup {E : Type*} [semi_normed_group E] {s : add_subgroup E}\n\t(x : \u21a5s) :\n\t\u2225x\u2225 = \u2225\u2191x\u2225", "decl_tp": "\u2200 {E : Type u_1} [_inst_3 : semi_normed_group E] {s : add_subgroup E} (x : \u21a5s), \u2225x\u2225 = \u2225\u2191x\u2225", "decl_nm": "coe_norm_subgroup"}
{"formal_statement": "theorem total_range {\u03b1 M : Type*} (R : Type*) [semiring R] [add_comm_monoid M]\n\t[module R M] {v : \u03b1 \u2192 M} (h : function.surjective v) :\n\t(finsupp.total \u03b1 M R v).range = \u22a4", "decl_tp": "\u2200 {\u03b1 : Type u_1} {M : Type u_2} (R : Type u_5) [_inst_1 : semiring R] [_inst_3 : add_comm_monoid M] [_inst_4 : module R M] {v : \u03b1 \u2192 M}, function.surjective v \u2192 (finsupp.total \u03b1 M R v).range = \u22a4", "decl_nm": "finsupp.total_range"}
{"formal_statement": "theorem two_not_dvd_two_mul_sub_one {n : \u2115} (w : 0 < n) :\n\t\u00ac2 \u2223 2 * n - 1", "decl_tp": "\u2200 {n : \u2115}, 0 < n \u2192 \u00ac2 \u2223 2 * n - 1", "decl_nm": "nat.two_not_dvd_two_mul_sub_one"}
{"formal_statement": "theorem join_nil {\u03b1 : Type u} (a : \u03b1) (S : seq (seq1 \u03b1)) :\n\tseq1.join ((a, seq.nil \u03b1), S) = (a, S.join)", "decl_tp": "\u2200 {\u03b1 : Type u} (a : \u03b1) (S : seq (seq1 \u03b1)), seq1.join ((a, seq.nil \u03b1), S) = (a, S.join)", "decl_nm": "seq1.join_nil"}
{"formal_statement": "theorem to_add_equiv_apply {M N : Type*} [add_zero_class M] [add_zero_class N]\n\t(f : M \u2192+ N) (g : N \u2192+ M) (h\u2081 : g.comp f = add_monoid_hom.id M) (h\u2082 : f.comp g = add_monoid_hom.id N) :\n\t\u21d1(f.to_add_equiv g h\u2081 h\u2082) = \u21d1f", "decl_tp": "\u2200 {M : Type u_3} {N : Type u_4} [_inst_1 : add_zero_class M] [_inst_2 : add_zero_class N] (f : M \u2192+ N) (g : N \u2192+ M) (h\u2081 : g.comp f = add_monoid_hom.id M) (h\u2082 : f.comp g = add_monoid_hom.id N), \u21d1(f.to_add_equiv g h\u2081 h\u2082) = \u21d1f", "decl_nm": "add_monoid_hom.to_add_equiv_apply"}
{"formal_statement": "theorem pi_univ_Ioo_subset {\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} [\u03a0 (i : \u03b9), preorder (\u03b1 i)]\n\t(x y : \u03a0 (i : \u03b9), \u03b1 i) [nonempty \u03b9] :\n\tset.univ.pi (\u03bb (i : \u03b9), set.Ioo (x i) (y i)) \u2286 set.Ioo x y", "decl_tp": "\u2200 {\u03b9 : Type u_1} {\u03b1 : \u03b9 \u2192 Type u_2} [_inst_1 : \u03a0 (i : \u03b9), preorder (\u03b1 i)] (x y : \u03a0 (i : \u03b9), \u03b1 i) [_inst_2 : nonempty \u03b9], set.univ.pi (\u03bb (i : \u03b9), set.Ioo (x i) (y i)) \u2286 set.Ioo x y", "decl_nm": "set.pi_univ_Ioo_subset"}
{"formal_statement": "theorem le_or_le_of_add_eq_add_pred {a b c d : \u2115} (h : c + d = a + b - 1) :\n\ta \u2264 c \u2228 b \u2264 d", "decl_tp": "\u2200 {a b c d : \u2115}, c + d = a + b - 1 \u2192 a \u2264 c \u2228 b \u2264 d", "decl_nm": "nat.le_or_le_of_add_eq_add_pred"}
{"formal_statement": "theorem gcd_pos_of_pos_right (m : \u2115) {n : \u2115} (npos : 0 < n) :\n\t0 < m.gcd n", "decl_tp": "\u2200 (m : \u2115) {n : \u2115}, 0 < n \u2192 0 < m.gcd n", "decl_nm": "nat.gcd_pos_of_pos_right"}
{"formal_statement": "theorem coe_comp {R : Type u} {L\u2081 : Type v} {L\u2082 : Type w} {L\u2083 : Type w\u2081}\n\t[comm_ring R] [lie_ring L\u2081] [lie_algebra R L\u2081] [lie_ring L\u2082] [lie_algebra R L\u2082]\n\t[lie_ring L\u2083] [lie_algebra R L\u2083] (f : L\u2082 \u2192\u2097\u2045R\u2046 L\u2083) (g : L\u2081 \u2192\u2097\u2045R\u2046 L\u2082) :\n\t\u21d1(f.comp g) = \u21d1f \u2218 \u21d1g", "decl_tp": "\u2200 {R : Type u} {L\u2081 : Type v} {L\u2082 : Type w} {L\u2083 : Type w\u2081} [_inst_1 : comm_ring R] [_inst_2 : lie_ring L\u2081] [_inst_3 : lie_algebra R L\u2081] [_inst_4 : lie_ring L\u2082] [_inst_5 : lie_algebra R L\u2082] [_inst_6 : lie_ring L\u2083] [_inst_7 : lie_algebra R L\u2083] (f : L\u2082 \u2192\u2097\u2045R\u2046 L\u2083) (g : L\u2081 \u2192\u2097\u2045R\u2046 L\u2082), \u21d1(f.comp g) = \u21d1f \u2218 \u21d1g", "decl_nm": "lie_hom.coe_comp"}
{"formal_statement": "theorem smooth_on_id {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c] {E : Type*}\n\t[normed_group E] [normed_space \ud835\udd5c E] {H : Type*} [topological_space H]\n\t{I : model_with_corners \ud835\udd5c E H} {M : Type*} [topological_space M] [charted_space H M]\n\t{s : set M} :\n\tsmooth_on I I id s", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {H : Type u_3} [_inst_4 : topological_space H] {I : model_with_corners \ud835\udd5c E H} {M : Type u_4} [_inst_5 : topological_space M] [_inst_6 : charted_space H M] {s : set M}, smooth_on I I id s", "decl_nm": "smooth_on_id"}
{"formal_statement": "theorem to_topological_space_comap {\u03b1 \u03b2 : Type*} {f : \u03b1 \u2192 \u03b2} {u : uniform_space \u03b2} :\n\tuniform_space.to_topological_space = topological_space.induced f uniform_space.to_topological_space", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {f : \u03b1 \u2192 \u03b2} {u : uniform_space \u03b2}, uniform_space.to_topological_space = topological_space.induced f uniform_space.to_topological_space", "decl_nm": "to_topological_space_comap"}
{"formal_statement": "theorem lookup_empty {\u03b1 : Type u} {\u03b2 : \u03b1 \u2192 Type v} [decidable_eq \u03b1] (a : \u03b1) :\n\talist.lookup a \u2205 = option.none", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : \u03b1 \u2192 Type v} [_inst_1 : decidable_eq \u03b1] (a : \u03b1), alist.lookup a \u2205 = option.none", "decl_nm": "alist.lookup_empty"}
{"formal_statement": "theorem coe_basis {R S : Type*} [comm_ring R] [comm_ring S] [algebra R S]\n\t(pb : power_basis R S) :\n\t\u21d1(pb.basis) = \u03bb (i : fin pb.dim), pb.gen ^ \u2191i", "decl_tp": "\u2200 {R : Type u_1} {S : Type u_2} [_inst_1 : comm_ring R] [_inst_2 : comm_ring S] [_inst_4 : algebra R S] (pb : power_basis R S), \u21d1(pb.basis) = \u03bb (i : fin pb.dim), pb.gen ^ \u2191i", "decl_nm": "power_basis.coe_basis"}
{"formal_statement": "theorem tendsto_neg_nhds_within_Iic {H : Type x} [topological_space H]\n\t[ordered_add_comm_group H] [topological_add_group H] {a : H} :\n\tfilter.tendsto has_neg.neg (nhds_within a (set.Iic a)) (nhds_within (-a)\n\t(set.Ici (-a)))", "decl_tp": "\u2200 {H : Type x} [_inst_5 : topological_space H] [_inst_6 : ordered_add_comm_group H] [_inst_7 : topological_add_group H] {a : H}, filter.tendsto has_neg.neg (nhds_within a (set.Iic a)) (nhds_within (-a) (set.Ici (-a)))", "decl_nm": "tendsto_neg_nhds_within_Iic"}
{"formal_statement": "theorem symm {M : Type*} [has_mul M] (c : con M) {x y : M} :\n\t\u21d1c x y \u2192 \u21d1c y x", "decl_tp": "\u2200 {M : Type u_1} [_inst_1 : has_mul M] (c : con M) {x y : M}, \u21d1c x y \u2192 \u21d1c y x", "decl_nm": "con.symm"}
{"formal_statement": "theorem const_smul {X Y : Type*} [normed_group X] [normed_group Y] [normed_space \u211d X]\n\t[normed_space \u211d Y] {f : X \u2192 Y} {x : X} {c : \u211d} (hc : c \u2260 0) (hf : conformal_at f x) :\n\tconformal_at (c \u2022 f) x", "decl_tp": "\u2200 {X : Type u_1} {Y : Type u_2} [_inst_1 : normed_group X] [_inst_2 : normed_group Y] [_inst_4 : normed_space \u211d X] [_inst_5 : normed_space \u211d Y] {f : X \u2192 Y} {x : X} {c : \u211d}, c \u2260 0 \u2192 conformal_at f x \u2192 conformal_at (c \u2022 f) x", "decl_nm": "conformal_at.const_smul"}
{"formal_statement": "theorem const_inj {\u03b1 \u03b2 : Type*} {l : filter \u03b1} [l.ne_bot] {a b : \u03b2} :\n\t\u2191a = \u2191b \u2194 a = b", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {l : filter \u03b1} [_inst_1 : l.ne_bot] {a b : \u03b2}, \u2191a = \u2191b \u2194 a = b", "decl_nm": "filter.germ.const_inj"}
{"formal_statement": "theorem congr_tmul {R : Type*} [comm_semiring R] {M N P Q : Type*} [add_comm_monoid M]\n\t[add_comm_monoid N] [add_comm_monoid P] [add_comm_monoid Q] [module R M]\n\t[module R N] [module R P] [module R Q] (f : M \u2243\u2097[R] P) (g : N \u2243\u2097[R] Q)\n\t(m : M) (n : N) :\n\t\u21d1(tensor_product.congr f g) (m \u2297\u209c[R] n) = \u21d1f m \u2297\u209c[R] \u21d1g n", "decl_tp": "\u2200 {R : Type u_1} [_inst_1 : comm_semiring R] {M : Type u_4} {N : Type u_5} {P : Type u_6} {Q : Type u_7} [_inst_4 : add_comm_monoid M] [_inst_5 : add_comm_monoid N] [_inst_6 : add_comm_monoid P] [_inst_7 : add_comm_monoid Q] [_inst_9 : module R M] [_inst_10 : module R N] [_inst_11 : module R P] [_inst_12 : module R Q] (f : M \u2243\u2097[R] P) (g : N \u2243\u2097[R] Q) (m : M) (n : N), \u21d1(tensor_product.congr f g) (m \u2297\u209c[R] n) = \u21d1f m \u2297\u209c[R] \u21d1g n", "decl_nm": "tensor_product.congr_tmul"}
{"formal_statement": "theorem neg {\u03b1 \u03b2 : Type*} {f : \u03b1 \u2192 \u03b2} [measurable_space \u03b1] [topological_space \u03b2]\n\t[add_group \u03b2] [topological_add_group \u03b2] (hf : measure_theory.strongly_measurable f) :\n\tmeasure_theory.strongly_measurable (-f)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {f : \u03b1 \u2192 \u03b2} [_inst_1 : measurable_space \u03b1] [_inst_2 : topological_space \u03b2] [_inst_3 : add_group \u03b2] [_inst_4 : topological_add_group \u03b2], measure_theory.strongly_measurable f \u2192 measure_theory.strongly_measurable (-f)", "decl_nm": "measure_theory.strongly_measurable.neg"}
{"formal_statement": "theorem subsingleton_unique' {\u03b1 : Sort u} (h\u2081 h\u2082 : unique \u03b1) :\n\th\u2081 = h\u2082", "decl_tp": "\u2200 {\u03b1 : Sort u} (h\u2081 h\u2082 : unique \u03b1), h\u2081 = h\u2082", "decl_nm": "unique.subsingleton_unique'"}
{"formal_statement": "theorem mul_down {\u03b1 : Type u} {x y : ulift \u03b1} [has_mul \u03b1] :\n\t(x * y).down = x.down * y.down", "decl_tp": "\u2200 {\u03b1 : Type u} {x y : ulift \u03b1} [_inst_1 : has_mul \u03b1], (x * y).down = x.down * y.down", "decl_nm": "ulift.mul_down"}
{"formal_statement": "theorem gcd_dvd_left (n m : \u2115+) :\n\tn.gcd m \u2223 n", "decl_tp": "\u2200 (n m : \u2115+), n.gcd m \u2223 n", "decl_nm": "pnat.gcd_dvd_left"}
{"formal_statement": "theorem comp_one {M N P : Type*} [mul_one_class M] [mul_one_class N] [mul_one_class P]\n\t(f : N \u2192* P) :\n\tf.comp 1 = 1", "decl_tp": "\u2200 {M : Type u_1} {N : Type u_2} {P : Type u_3} [_inst_3 : mul_one_class M] [_inst_4 : mul_one_class N] [_inst_5 : mul_one_class P] (f : N \u2192* P), f.comp 1 = 1", "decl_nm": "monoid_hom.comp_one"}
{"formal_statement": "theorem measurable_sum {M \u03b1 : Type*} [add_monoid M] [measurable_space M]\n\t[has_measurable_add\u2082 M] [measurable_space \u03b1] (l : list (\u03b1 \u2192 M)) :\n\t(\u2200 (f : \u03b1 \u2192 M), f \u2208 l \u2192 measurable f) \u2192 measurable (\u03bb (x : \u03b1), (list.map (\u03bb (f : \u03b1 \u2192 M), f x) l).sum)", "decl_tp": "\u2200 {M : Type u_1} {\u03b1 : Type u_2} [_inst_1 : add_monoid M] [_inst_2 : measurable_space M] [_inst_3 : has_measurable_add\u2082 M] [_inst_4 : measurable_space \u03b1] (l : list (\u03b1 \u2192 M)), (\u2200 (f : \u03b1 \u2192 M), f \u2208 l \u2192 measurable f) \u2192 measurable (\u03bb (x : \u03b1), (list.map (\u03bb (f : \u03b1 \u2192 M), f x) l).sum)", "decl_nm": "list.measurable_sum"}
{"formal_statement": "theorem subtype_equiv_subtype_perm_apply_of_mem {\u03b1 : Type*} {p : \u03b1 \u2192 Prop}\n\t[decidable_pred p] (f : equiv.perm (subtype p)) {a : \u03b1} (h : p a) :\n\t\u21d1(\u21d1(equiv.perm.subtype_equiv_subtype_perm p) f) a = \u2191(\u21d1f \u27e8a, h\u27e9)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {p : \u03b1 \u2192 Prop} [_inst_1 : decidable_pred p] (f : equiv.perm (subtype p)) {a : \u03b1} (h : p a), \u21d1(\u21d1(equiv.perm.subtype_equiv_subtype_perm p) f) a = \u2191(\u21d1f \u27e8a, h\u27e9)", "decl_nm": "equiv.perm.subtype_equiv_subtype_perm_apply_of_mem"}
{"formal_statement": "theorem sub_apply' {R : Type*} [ring R] {R\u2082 : Type*} [ring R\u2082] {M : Type*}\n\t[topological_space M] [add_comm_group M] {M\u2082 : Type*} [topological_space M\u2082]\n\t[add_comm_group M\u2082] [module R M] [module R\u2082 M\u2082] {\u03c3\u2081\u2082 : R \u2192+* R\u2082} (f g : M \u2192SL[\u03c3\u2081\u2082] M\u2082)\n\t(x : M) :\n\t\u21d1(\u2191f - \u2191g) x = \u21d1f x - \u21d1g x", "decl_tp": "\u2200 {R : Type u_1} [_inst_1 : ring R] {R\u2082 : Type u_2} [_inst_2 : ring R\u2082] {M : Type u_3} [_inst_3 : topological_space M] [_inst_4 : add_comm_group M] {M\u2082 : Type u_4} [_inst_5 : topological_space M\u2082] [_inst_6 : add_comm_group M\u2082] [_inst_11 : module R M] [_inst_12 : module R\u2082 M\u2082] {\u03c3\u2081\u2082 : R \u2192+* R\u2082} (f g : M \u2192SL[\u03c3\u2081\u2082] M\u2082) (x : M), \u21d1(\u2191f - \u2191g) x = \u21d1f x - \u21d1g x", "decl_nm": "continuous_linear_map.sub_apply'"}
{"formal_statement": "theorem infinite_pos_neg_of_infinite_neg {x : \u211d*} (hp : x.infinite_neg) :\n\t(-x).infinite_pos", "decl_tp": "\u2200 {x : \u211d*}, x.infinite_neg \u2192 (-x).infinite_pos", "decl_nm": "hyperreal.infinite_pos_neg_of_infinite_neg"}
{"formal_statement": "theorem is_closed_map {\u03b1 \u03b2 : Type*} [topological_space \u03b1] [topological_space \u03b2]\n\t{f : \u03b1 \u2192 \u03b2} (hf : inducing f) (h : is_closed (set.range f)) :\n\tis_closed_map f", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : topological_space \u03b1] [_inst_2 : topological_space \u03b2] {f : \u03b1 \u2192 \u03b2}, inducing f \u2192 is_closed (set.range f) \u2192 is_closed_map f", "decl_nm": "inducing.is_closed_map"}
{"formal_statement": "theorem lift_aux_I :\n\tcomplex.lift_aux complex.I complex.I_mul_I = alg_hom.id \u211d \u2102", "decl_tp": "complex.lift_aux complex.I complex.I_mul_I = alg_hom.id \u211d \u2102", "decl_nm": "complex.lift_aux_I"}
{"formal_statement": "theorem tendsto_nhds_iff {\u03b2 \u03b3 : Type*} [topological_space \u03b2] [topological_space \u03b3]\n\t{\u03b9 : Type*} {f : \u03b9 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3} {a : filter \u03b9} {b : \u03b2} (hg : embedding g) :\n\t(filter.tendsto f a (nhds b) \u2194 filter.tendsto (g \u2218 f) a (nhds (g b)))", "decl_tp": "\u2200 {\u03b2 : Type u_2} {\u03b3 : Type u_3} [_inst_2 : topological_space \u03b2] [_inst_3 : topological_space \u03b3] {\u03b9 : Type u_1} {f : \u03b9 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3} {a : filter \u03b9} {b : \u03b2}, embedding g \u2192 (filter.tendsto f a (nhds b) \u2194 filter.tendsto (g \u2218 f) a (nhds (g b)))", "decl_nm": "embedding.tendsto_nhds_iff"}
{"formal_statement": "theorem add_equiv_apply {\u03b1 : Type u} {\u03b2 : Type v} (e : \u03b1 \u2243 \u03b2) [has_add \u03b2]\n\t(a : \u03b1) :\n\t\u21d1(e.add_equiv) a = \u21d1e a", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} (e : \u03b1 \u2243 \u03b2) [_inst_1 : has_add \u03b2] (a : \u03b1), \u21d1(e.add_equiv) a = \u21d1e a", "decl_nm": "equiv.add_equiv_apply"}
{"formal_statement": "theorem modify_nth_tail_eq_take_drop {\u03b1 : Type u} (f : list \u03b1 \u2192 list \u03b1)\n\t(H : f list.nil = list.nil) :\n\t\u2200 (n : \u2115) (l : list \u03b1), list.modify_nth_tail f n l = list.take n l ++ f (list.drop n l)", "decl_tp": "\u2200 {\u03b1 : Type u} (f : list \u03b1 \u2192 list \u03b1), f list.nil = list.nil \u2192 \u2200 (n : \u2115) (l : list \u03b1), list.modify_nth_tail f n l = list.take n l ++ f (list.drop n l)", "decl_nm": "list.modify_nth_tail_eq_take_drop"}
{"formal_statement": "theorem divp_mul_cancel {\u03b1 : Type u} [monoid \u03b1] (a : \u03b1) (u : units \u03b1) :\n\ta /\u209a u * \u2191u = a", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : monoid \u03b1] (a : \u03b1) (u : units \u03b1), a /\u209a u * \u2191u = a", "decl_nm": "divp_mul_cancel"}
{"formal_statement": "theorem coe_reindex {\u03b9 \u03b9' R M : Type*} [semiring R] [add_comm_monoid M]\n\t[module R M] (b : basis \u03b9 R M) (e : \u03b9 \u2243 \u03b9') :\n\t\u21d1(b.reindex e) = \u21d1b \u2218 \u21d1(e.symm)", "decl_tp": "\u2200 {\u03b9 : Type u_1} {\u03b9' : Type u_2} {R : Type u_3} {M : Type u_5} [_inst_1 : semiring R] [_inst_2 : add_comm_monoid M] [_inst_3 : module R M] (b : basis \u03b9 R M) (e : \u03b9 \u2243 \u03b9'), \u21d1(b.reindex e) = \u21d1b \u2218 \u21d1(e.symm)", "decl_nm": "basis.coe_reindex"}
{"formal_statement": "theorem div_eq_inv_self {G : Type u} [group G] {a b : G} :\n\ta / b = b\u207b\u00b9 \u2194 a = 1", "decl_tp": "\u2200 {G : Type u} [_inst_1 : group G] {a b : G}, a / b = b\u207b\u00b9 \u2194 a = 1", "decl_nm": "div_eq_inv_self"}
{"formal_statement": "theorem mul_iff_right {R M : Type*} {a b : R} [monoid R] [mul_action R M]\n\t(ha : is_smul_regular M a) :\n\t(is_smul_regular M (a * b) \u2194 is_smul_regular M b)", "decl_tp": "\u2200 {R : Type u_1} {M : Type u_3} {a b : R} [_inst_1 : monoid R] [_inst_2 : mul_action R M], is_smul_regular M a \u2192 (is_smul_regular M (a * b) \u2194 is_smul_regular M b)", "decl_nm": "is_smul_regular.mul_iff_right"}
{"formal_statement": "theorem proj_Icc_eq_one {x : \u211d} :\n\tset.proj_Icc 0 1 zero_le_one x = 1 \u2194 1 \u2264 x", "decl_tp": "\u2200 {x : \u211d}, set.proj_Icc 0 1 zero_le_one x = 1 \u2194 1 \u2264 x", "decl_nm": "proj_Icc_eq_one"}
{"formal_statement": "theorem is_preconnected_Ici {\u03b1 : Type u} [conditionally_complete_linear_order \u03b1]\n\t[topological_space \u03b1] [order_topology \u03b1] [densely_ordered \u03b1] {a : \u03b1} :\n\tis_preconnected (set.Ici a)", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : conditionally_complete_linear_order \u03b1] [_inst_2 : topological_space \u03b1] [_inst_3 : order_topology \u03b1] [_inst_8 : densely_ordered \u03b1] {a : \u03b1}, is_preconnected (set.Ici a)", "decl_nm": "is_preconnected_Ici"}
{"formal_statement": "theorem correctness {\u03b1 : Type*} [comm_semiring \u03b1] (t : tree \u03b1) (r\u2081 r\u2082 : tactic.ring2.csring_expr)\n\t(H : tactic.ring2.horner_expr.of_csexpr r\u2081 = tactic.ring2.horner_expr.of_csexpr r\u2082) :\n\ttactic.ring2.csring_expr.eval t r\u2081 = tactic.ring2.csring_expr.eval t r\u2082", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : comm_semiring \u03b1] (t : tree \u03b1) (r\u2081 r\u2082 : tactic.ring2.csring_expr), tactic.ring2.horner_expr.of_csexpr r\u2081 = tactic.ring2.horner_expr.of_csexpr r\u2082 \u2192 tactic.ring2.csring_expr.eval t r\u2081 = tactic.ring2.csring_expr.eval t r\u2082", "decl_nm": "tactic.ring2.correctness"}
{"formal_statement": "theorem prod_mk_nhds {\u03b1 : Type u} {\u03b2 : Type v} [topological_space \u03b1] [topological_space \u03b2]\n\t{pa : \u03b1 \u2192 Prop} {a : \u03b1} (b : \u03b2) :\n\t(\u2200\u1da0 (x : \u03b1) in nhds a, pa x) \u2192 \u2200 {pb :  Prop} {b : \u03b2}, (\u2200\u1da0 (y : \u03b2) in nhds b, pb y) \u2192 (\u2200\u1da0 (p : \u03b1 \u00d7 \u03b2) in nhds (a, b), pa p.fst \u2227 pb p.snd)", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : topological_space \u03b1] [_inst_2 : topological_space \u03b2] {pa : \u03b1 \u2192 Prop} {a : \u03b1}, (\u2200\u1da0 (x : \u03b1) in nhds a, pa x) \u2192 \u2200 {pb : \u03b2 \u2192 Prop} {b : \u03b2}, (\u2200\u1da0 (y : \u03b2) in nhds b, pb y) \u2192 (\u2200\u1da0 (p : \u03b1 \u00d7 \u03b2) in nhds (a, b), pa p.fst \u2227 pb p.snd)", "decl_nm": "filter.eventually.prod_mk_nhds"}
{"formal_statement": "theorem map_zero\u2082 {R : Type*} [semiring R] {S : Type*} [semiring S] {R\u2082 : Type*}\n\t[semiring R\u2082] {S\u2082 : Type*} [semiring S\u2082] {M N P : Type*} [add_comm_monoid M]\n\t[add_comm_monoid N] [add_comm_monoid P] [module R M] [module S N] [module R\u2082 P]\n\t[module S\u2082 P] [smul_comm_class S\u2082 R\u2082 P] {\u03c1\u2081\u2082 : R \u2192+* R\u2082} {\u03c3\u2081\u2082 : S \u2192+* S\u2082}\n\t(f : M \u2192\u209b\u2097[\u03c1\u2081\u2082] N \u2192\u209b\u2097[\u03c3\u2081\u2082] P) (y : N) :\n\t\u21d1(\u21d1f 0) y = 0", "decl_tp": "\u2200 {R : Type u_1} [_inst_1 : semiring R] {S : Type u_2} [_inst_2 : semiring S] {R\u2082 : Type u_3} [_inst_3 : semiring R\u2082] {S\u2082 : Type u_4} [_inst_4 : semiring S\u2082] {M : Type u_5} {N : Type u_6} {P : Type u_7} [_inst_5 : add_comm_monoid M] [_inst_6 : add_comm_monoid N] [_inst_7 : add_comm_monoid P] [_inst_13 : module R M] [_inst_14 : module S N] [_inst_15 : module R\u2082 P] [_inst_16 : module S\u2082 P] [_inst_23 : smul_comm_class S\u2082 R\u2082 P] {\u03c1\u2081\u2082 : R \u2192+* R\u2082} {\u03c3\u2081\u2082 : S \u2192+* S\u2082} (f : M \u2192\u209b\u2097[\u03c1\u2081\u2082] N \u2192\u209b\u2097[\u03c3\u2081\u2082] P) (y : N), \u21d1(\u21d1f 0) y = 0", "decl_nm": "linear_map.map_zero\u2082"}
{"formal_statement": "theorem injective {R\u2081 R\u2082 : Type*} [semiring R\u2081] [semiring R\u2082] {\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082}\n\t{\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081} [ring_hom_inv_pair \u03c3\u2081\u2082 \u03c3\u2082\u2081] [ring_hom_inv_pair \u03c3\u2082\u2081 \u03c3\u2081\u2082]\n\t{M\u2081 : Type*} [topological_space M\u2081] [add_comm_monoid M\u2081] {M\u2082 : Type*}\n\t[topological_space M\u2082] [add_comm_monoid M\u2082] [module R\u2081 M\u2081] [module R\u2082 M\u2082]\n\t(e : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) :\n\tfunction.injective \u21d1e", "decl_tp": "\u2200 {R\u2081 : Type u_1} {R\u2082 : Type u_2} [_inst_1 : semiring R\u2081] [_inst_2 : semiring R\u2082] {\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082} {\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081} [_inst_4 : ring_hom_inv_pair \u03c3\u2081\u2082 \u03c3\u2082\u2081] [_inst_5 : ring_hom_inv_pair \u03c3\u2082\u2081 \u03c3\u2081\u2082] {M\u2081 : Type u_4} [_inst_12 : topological_space M\u2081] [_inst_13 : add_comm_monoid M\u2081] {M\u2082 : Type u_6} [_inst_16 : topological_space M\u2082] [_inst_17 : add_comm_monoid M\u2082] [_inst_22 : module R\u2081 M\u2081] [_inst_24 : module R\u2082 M\u2082] (e : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082), function.injective \u21d1e", "decl_nm": "continuous_linear_equiv.injective"}
{"formal_statement": "theorem prod_eq_prod_Ico_succ_bot {\u03b2 : Type v} [comm_monoid \u03b2] {a b : \u2115}\n\t(a : \u2115) (hab : a < b) :\n\t\u2200 (f :  \u03b2), (finset.Ico a b).prod (\u03bb (k : \u2115), f k) = f a * (finset.Ico (a + 1) b).prod (\u03bb (k : \u2115), f k)", "decl_tp": "\u2200 {\u03b2 : Type v} [_inst_1 : comm_monoid \u03b2] {a b : \u2115}, a < b \u2192 \u2200 (f : \u2115 \u2192 \u03b2), (finset.Ico a b).prod (\u03bb (k : \u2115), f k) = f a * (finset.Ico (a + 1) b).prod (\u03bb (k : \u2115), f k)", "decl_nm": "finset.prod_eq_prod_Ico_succ_bot"}
{"formal_statement": "theorem eq_repeat' {\u03b1 : Type*} {a : \u03b1} {s : multiset \u03b1} :\n\ts = multiset.repeat a (\u21d1multiset.card s) \u2194 \u2200 (b : \u03b1), b \u2208 s \u2192 b = a", "decl_tp": "\u2200 {\u03b1 : Type u_1} {a : \u03b1} {s : multiset \u03b1}, s = multiset.repeat a (\u21d1multiset.card s) \u2194 \u2200 (b : \u03b1), b \u2208 s \u2192 b = a", "decl_nm": "multiset.eq_repeat'"}
{"formal_statement": "theorem closure_subtype {\u03b1 : Type u} [topological_space \u03b1] {p : \u03b1 \u2192 Prop}\n\t{x : {a // p a}} {s : set {a // p a}} :\n\tx \u2208 closure s \u2194 \u2191x \u2208 closure (coe '' s)", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : topological_space \u03b1] {p : \u03b1 \u2192 Prop} {x : {a // p a}} {s : set {a // p a}}, x \u2208 closure s \u2194 \u2191x \u2208 closure (coe '' s)", "decl_nm": "closure_subtype"}
{"formal_statement": "theorem asc_factorial_zero (n : \u2115) :\n\tn.asc_factorial 0 = 1", "decl_tp": "\u2200 (n : \u2115), n.asc_factorial 0 = 1", "decl_nm": "nat.asc_factorial_zero"}
{"formal_statement": "theorem lc_def {R M \u03b9 : Type*} [comm_ring R] [add_comm_group M] [module R M]\n\t(e : \u03b9 \u2192 M) (l : \u03b9 \u2192\u2080 R) :\n\tdual_pair.lc e l = \u21d1(finsupp.total \u03b9 M R e) l", "decl_tp": "\u2200 {R : Type u_1} {M : Type u_2} {\u03b9 : Type u_3} [_inst_1 : comm_ring R] [_inst_2 : add_comm_group M] [_inst_3 : module R M] (e : \u03b9 \u2192 M) (l : \u03b9 \u2192\u2080 R), dual_pair.lc e l = \u21d1(finsupp.total \u03b9 M R e) l", "decl_nm": "dual_pair.lc_def"}
{"formal_statement": "theorem abv_sub {S : Type*} [linear_ordered_field S] {R : Type*} [ring R]\n\t(abv : R \u2192 S) [is_absolute_value abv] (a b : R) :\n\tabv (a - b) = abv (b - a)", "decl_tp": "\u2200 {S : Type u_1} [_inst_1 : linear_ordered_field S] {R : Type u_2} [_inst_2 : ring R] (abv : R \u2192 S) [_inst_3 : is_absolute_value abv] (a b : R), abv (a - b) = abv (b - a)", "decl_nm": "is_absolute_value.abv_sub"}
{"formal_statement": "theorem finite_of_is_wf {\u03b1 : Type*} [linear_ordered_cancel_comm_monoid \u03b1]\n\t{s t : set \u03b1} (hs : s.is_wf) (ht : t.is_wf) :\n\t\u2200 (a : \u03b1), (s.mul_antidiagonal t a).finite", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : linear_ordered_cancel_comm_monoid \u03b1] {s t : set \u03b1}, s.is_wf \u2192 t.is_wf \u2192 \u2200 (a : \u03b1), (s.mul_antidiagonal t a).finite", "decl_nm": "set.mul_antidiagonal.finite_of_is_wf"}
{"formal_statement": "theorem subset_closed_ball_norm {\ud835\udd5c A : Type*} [normed_field \ud835\udd5c] [normed_ring A]\n\t[normed_algebra \ud835\udd5c A] [complete_space A] (a : A) :\n\tspectrum \ud835\udd5c a \u2286 metric.closed_ball 0 \u2225a\u2225", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} {A : Type u_2} [_inst_1 : normed_field \ud835\udd5c] [_inst_2 : normed_ring A] [_inst_3 : normed_algebra \ud835\udd5c A] [_inst_4 : complete_space A] (a : A), spectrum \ud835\udd5c a \u2286 metric.closed_ball 0 \u2225a\u2225", "decl_nm": "spectrum.subset_closed_ball_norm"}
{"formal_statement": "theorem inj_iff {n a b : \u2115} {ha : a < n} {hb : b < n} :\n\t\u27e8a, ha\u27e9 = \u27e8b, hb\u27e9 \u2194 a = b", "decl_tp": "\u2200 {n a b : \u2115} {ha : a < n} {hb : b < n}, \u27e8a, ha\u27e9 = \u27e8b, hb\u27e9 \u2194 a = b", "decl_nm": "fin.mk.inj_iff"}
{"formal_statement": "theorem gold_pos :\n\t0 < golden_ratio", "decl_tp": "0 < golden_ratio", "decl_nm": "gold_pos"}
{"formal_statement": "theorem get_coe' (x : \u2115) (h : \u2191x.dom) :\n\t\u2191x.get h = x", "decl_tp": "\u2200 (x : \u2115) (h : \u2191x.dom), \u2191x.get h = x", "decl_nm": "enat.get_coe'"}
{"formal_statement": "theorem measurable_of_not_restrict_le_zero {\u03b1 : Type*} {m : measurable_space \u03b1}\n\t{M : Type*} [topological_space M] [ordered_add_comm_monoid M] (v : measure_theory.vector_measure \u03b1 M)\n\t{i : set \u03b1} (hi : \u00acv.restrict i \u2264 0.restrict i) :\n\tmeasurable_set i", "decl_tp": "\u2200 {\u03b1 : Type u_1} {m : measurable_space \u03b1} {M : Type u_3} [_inst_1 : topological_space M] [_inst_2 : ordered_add_comm_monoid M] (v : measure_theory.vector_measure \u03b1 M) {i : set \u03b1}, \u00acv.restrict i \u2264 0.restrict i \u2192 measurable_set i", "decl_nm": "measure_theory.vector_measure.measurable_of_not_restrict_le_zero"}
{"formal_statement": "theorem is_diag_iff_proj_eq {\u03b1 : Type*} (z : \u03b1 \u00d7 \u03b1) :\n\tsym2.is_diag \u27e6z\u27e7 \u2194 z.fst = z.snd", "decl_tp": "\u2200 {\u03b1 : Type u_1} (z : \u03b1 \u00d7 \u03b1), sym2.is_diag \u27e6z\u27e7 \u2194 z.fst = z.snd", "decl_nm": "sym2.is_diag_iff_proj_eq"}
{"formal_statement": "theorem imp_eq_bot_iff {\u03b1 : Type*} [boolean_algebra \u03b1] {a b : \u03b1} :\n\ta \u21d2\u2092 b = \u22a5 \u2194 a = \u22a4 \u2227 b = \u22a5", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : boolean_algebra \u03b1] {a b : \u03b1}, a \u21d2\u2092 b = \u22a5 \u2194 a = \u22a4 \u2227 b = \u22a5", "decl_nm": "lattice.imp_eq_bot_iff"}
{"formal_statement": "theorem swap_apply_of_ne_of_ne {\u03b1 : Sort u} [decidable_eq \u03b1] {a b x : \u03b1} :\n\tx \u2260 a \u2192 x \u2260 b \u2192 \u21d1(equiv.swap a b) x = x", "decl_tp": "\u2200 {\u03b1 : Sort u} [_inst_1 : decidable_eq \u03b1] {a b x : \u03b1}, x \u2260 a \u2192 x \u2260 b \u2192 \u21d1(equiv.swap a b) x = x", "decl_nm": "equiv.swap_apply_of_ne_of_ne"}
{"formal_statement": "theorem complete_space_iff_is_complete_univ {\u03b1 : Type u} [uniform_space \u03b1] :\n\tcomplete_space \u03b1 \u2194 is_complete set.univ", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : uniform_space \u03b1], complete_space \u03b1 \u2194 is_complete set.univ", "decl_nm": "complete_space_iff_is_complete_univ"}
{"formal_statement": "theorem implies_neg_elim_core {p : omega.nat.preform} :\n\tp.implies (omega.nat.neg_elim_core p)", "decl_tp": "\u2200 {p : omega.nat.preform}, p.implies (omega.nat.neg_elim_core p)", "decl_nm": "omega.nat.implies_neg_elim_core"}
{"formal_statement": "theorem cos {E : Type*} [normed_group E] [normed_space \u211d E] {f : E \u2192 \u211d}\n\t(hc : differentiable \u211d f) :\n\tdifferentiable \u211d (\u03bb (x : E), real.cos (f x))", "decl_tp": "\u2200 {E : Type u_1} [_inst_1 : normed_group E] [_inst_2 : normed_space \u211d E] {f : E \u2192 \u211d}, differentiable \u211d f \u2192 differentiable \u211d (\u03bb (x : E), real.cos (f x))", "decl_nm": "differentiable.cos"}
{"formal_statement": "theorem mk'_spec'_mk {R : Type*} [comm_ring R] {M : submonoid R} (S : Type*)\n\t[comm_ring S] [algebra R S] [is_localization M S] (x y : R) (hy : y \u2208 M) :\n\t\u21d1(algebra_map R S) y * is_localization.mk' S x \u27e8y, hy\u27e9 = \u21d1(algebra_map R S) x", "decl_tp": "\u2200 {R : Type u_1} [_inst_1 : comm_ring R] {M : submonoid R} (S : Type u_2) [_inst_2 : comm_ring S] [_inst_3 : algebra R S] [_inst_5 : is_localization M S] (x y : R) (hy : y \u2208 M), \u21d1(algebra_map R S) y * is_localization.mk' S x \u27e8y, hy\u27e9 = \u21d1(algebra_map R S) x", "decl_nm": "is_localization.mk'_spec'_mk"}
{"formal_statement": "theorem smul_single' {\u03b1 R : Type*1} {_x : semiring R} (c : R) (a : \u03b1) (b : R) :\n\tc \u2022 finsupp.single a b = finsupp.single a (c * b)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {R : Type u_11} {_x : semiring R} (c : R) (a : \u03b1) (b : R), c \u2022 finsupp.single a b = finsupp.single a (c * b)", "decl_nm": "finsupp.smul_single'"}
{"formal_statement": "theorem is_G\u03b4_compl {\u03b1 : Type*} [topological_space \u03b1] [t1_space \u03b1] {s : set \u03b1}\n\t(hs : s.subsingleton) :\n\tis_G\u03b4 s\u1d9c", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : topological_space \u03b1] [_inst_2 : t1_space \u03b1] {s : set \u03b1}, s.subsingleton \u2192 is_G\u03b4 s\u1d9c", "decl_nm": "set.subsingleton.is_G\u03b4_compl"}
{"formal_statement": "theorem to_Module_iso'_right_inv {R : Type u} [ring R] {X\u2081 : Type v} {g\u2081 : add_comm_group X\u2081}\n\t{m\u2081 : module R X\u2081} {X\u2082 : Module R} (e : X\u2081 \u2243\u2097[R] \u21a5X\u2082) :\n\te.to_Module_iso'_right.inv = \u2191(e.symm)", "decl_tp": "\u2200 {R : Type u} [_inst_1 : ring R] {X\u2081 : Type v} {g\u2081 : add_comm_group X\u2081} {m\u2081 : module R X\u2081} {X\u2082 : Module R} (e : X\u2081 \u2243\u2097[R] \u21a5X\u2082), e.to_Module_iso'_right.inv = \u2191(e.symm)", "decl_nm": "linear_equiv.to_Module_iso'_right_inv"}
{"formal_statement": "theorem symm_symm {R\u2081 R\u2082 : Type*} [semiring R\u2081] [semiring R\u2082] {\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082}\n\t{\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081} [ring_hom_inv_pair \u03c3\u2081\u2082 \u03c3\u2082\u2081] [ring_hom_inv_pair \u03c3\u2082\u2081 \u03c3\u2081\u2082]\n\t{M\u2081 : Type*} [topological_space M\u2081] [add_comm_monoid M\u2081] {M\u2082 : Type*}\n\t[topological_space M\u2082] [add_comm_monoid M\u2082] [module R\u2081 M\u2081] [module R\u2082 M\u2082]\n\t(e : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) :\n\te.symm.symm = e", "decl_tp": "\u2200 {R\u2081 : Type u_1} {R\u2082 : Type u_2} [_inst_1 : semiring R\u2081] [_inst_2 : semiring R\u2082] {\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082} {\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081} [_inst_4 : ring_hom_inv_pair \u03c3\u2081\u2082 \u03c3\u2082\u2081] [_inst_5 : ring_hom_inv_pair \u03c3\u2082\u2081 \u03c3\u2081\u2082] {M\u2081 : Type u_4} [_inst_12 : topological_space M\u2081] [_inst_13 : add_comm_monoid M\u2081] {M\u2082 : Type u_6} [_inst_16 : topological_space M\u2082] [_inst_17 : add_comm_monoid M\u2082] [_inst_22 : module R\u2081 M\u2081] [_inst_24 : module R\u2082 M\u2082] (e : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082), e.symm.symm = e", "decl_nm": "continuous_linear_equiv.symm_symm"}
{"formal_statement": "theorem empty_union {\u03b1 : Type u} {\u03b2 : \u03b1 \u2192 Type v} [decidable_eq \u03b1] {s : alist \u03b2} :\n\t\u2205 \u222a s = s", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : \u03b1 \u2192 Type v} [_inst_1 : decidable_eq \u03b1] {s : alist \u03b2}, \u2205 \u222a s = s", "decl_nm": "alist.empty_union"}
{"formal_statement": "theorem image_neg_Iio {G : Type u} [ordered_add_comm_group G] (a : G) :\n\thas_neg.neg '' set.Iio a = set.Ioi (-a)", "decl_tp": "\u2200 {G : Type u} [_inst_1 : ordered_add_comm_group G] (a : G), has_neg.neg '' set.Iio a = set.Ioi (-a)", "decl_nm": "set.image_neg_Iio"}
{"formal_statement": "theorem not_two_dvd_bit1 (n : \u2115) :\n\t\u00ac2 \u2223 bit1 n", "decl_tp": "\u2200 (n : \u2115), \u00ac2 \u2223 bit1 n", "decl_nm": "nat.not_two_dvd_bit1"}
{"formal_statement": "theorem Henstock_le_McShane :\n\tbox_integral.integration_params.Henstock \u2264 box_integral.integration_params.McShane", "decl_tp": "box_integral.integration_params.Henstock \u2264 box_integral.integration_params.McShane", "decl_nm": "box_integral.integration_params.Henstock_le_McShane"}
{"formal_statement": "theorem pow_log_eq_self {M : Type*} [monoid M] [decidable_eq M] {n : M}\n\t(p : \u21a5(submonoid.powers n)) :\n\tsubmonoid.pow n (submonoid.log p) = p", "decl_tp": "\u2200 {M : Type u_1} [_inst_1 : monoid M] [_inst_2 : decidable_eq M] {n : M} (p : \u21a5(submonoid.powers n)), submonoid.pow n (submonoid.log p) = p", "decl_nm": "submonoid.pow_log_eq_self"}
{"formal_statement": "theorem to_equiv_coe_symm {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c] {E : Type*}\n\t[normed_group E] [normed_space \ud835\udd5c E] {F : Type*} [normed_group F] [normed_space \ud835\udd5c F]\n\t{H : Type*} [topological_space H] {G : Type*} [topological_space G] {I : model_with_corners \ud835\udd5c E H}\n\t{J : model_with_corners \ud835\udd5c F G} {M : Type*} [topological_space M] [charted_space H M]\n\t{N : Type*0} [topological_space N] [charted_space G N] {n : with_top \u2115}\n\t(h : diffeomorph I J M N n) :\n\t\u21d1(h.to_equiv.symm) = \u21d1(h.symm)", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {F : Type u_4} [_inst_6 : normed_group F] [_inst_7 : normed_space \ud835\udd5c F] {H : Type u_5} [_inst_8 : topological_space H] {G : Type u_7} [_inst_10 : topological_space G] {I : model_with_corners \ud835\udd5c E H} {J : model_with_corners \ud835\udd5c F G} {M : Type u_8} [_inst_11 : topological_space M] [_inst_12 : charted_space H M] {N : Type u_10} [_inst_15 : topological_space N] [_inst_16 : charted_space G N] {n : with_top \u2115} (h : diffeomorph I J M N n), \u21d1(h.to_equiv.symm) = \u21d1(h.symm)", "decl_nm": "diffeomorph.to_equiv_coe_symm"}
{"formal_statement": "theorem nat_lt_limit {o : ordinal} (h : o.is_limit) :\n\t\u2200 (n : \u2115), \u2191n < o", "decl_tp": "\u2200 {o : ordinal}, o.is_limit \u2192 \u2200 (n : \u2115), \u2191n < o", "decl_nm": "ordinal.nat_lt_limit"}
{"formal_statement": "theorem coe_map_inv {M : Type u} {N : Type v} [monoid M] [monoid N] (f : M \u2192* N)\n\t(u : units M) :\n\t\u2191(\u21d1(units.map f) u)\u207b\u00b9 = \u21d1f \u2191u\u207b\u00b9", "decl_tp": "\u2200 {M : Type u} {N : Type v} [_inst_1 : monoid M] [_inst_2 : monoid N] (f : M \u2192* N) (u : units M), \u2191(\u21d1(units.map f) u)\u207b\u00b9 = \u21d1f \u2191u\u207b\u00b9", "decl_nm": "units.coe_map_inv"}
{"formal_statement": "theorem lt_omega_iff_finite {\u03b1 : Type*} {S : set \u03b1} :\n\tcardinal.mk \u21a5S < cardinal.omega \u2194 S.finite", "decl_tp": "\u2200 {\u03b1 : Type u_1} {S : set \u03b1}, cardinal.mk \u21a5S < cardinal.omega \u2194 S.finite", "decl_nm": "cardinal.lt_omega_iff_finite"}
{"formal_statement": "theorem sup_left_comm {\u03b1 : Type u} [semilattice_sup \u03b1] (a b c : \u03b1) :\n\ta \u2294 (b \u2294 c) = b \u2294 (a \u2294 c)", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : semilattice_sup \u03b1] (a b c : \u03b1), a \u2294 (b \u2294 c) = b \u2294 (a \u2294 c)", "decl_nm": "sup_left_comm"}
{"formal_statement": "theorem inv_lt_one_of_one_lt {\u03b1 : Type u} [ordered_comm_group \u03b1] {a : \u03b1} :\n\t1 < a \u2192 a\u207b\u00b9 < 1", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : ordered_comm_group \u03b1] {a : \u03b1}, 1 < a \u2192 a\u207b\u00b9 < 1", "decl_nm": "inv_lt_one_of_one_lt"}
{"formal_statement": "theorem mk_add_mk {R : Type*} [comm_ring R] {c\u2081 c\u2082 : R} (a\u2081 a\u2082 a\u2083 a\u2084 b\u2081 b\u2082 b\u2083 b\u2084 : R) :\n\t{re := a\u2081, im_i := a\u2082, im_j := a\u2083, im_k := a\u2084} + {re := b\u2081, im_i := b\u2082, im_j := b\u2083, im_k := b\u2084} = {re := a\u2081 + b\u2081, im_i := a\u2082 + b\u2082, im_j := a\u2083 + b\u2083, im_k := a\u2084 + b\u2084}", "decl_tp": "\u2200 {R : Type u_1} [_inst_1 : comm_ring R] {c\u2081 c\u2082 : R} (a\u2081 a\u2082 a\u2083 a\u2084 b\u2081 b\u2082 b\u2083 b\u2084 : R), {re := a\u2081, im_i := a\u2082, im_j := a\u2083, im_k := a\u2084} + {re := b\u2081, im_i := b\u2082, im_j := b\u2083, im_k := b\u2084} = {re := a\u2081 + b\u2081, im_i := a\u2082 + b\u2082, im_j := a\u2083 + b\u2083, im_k := a\u2084 + b\u2084}", "decl_nm": "quaternion_algebra.mk_add_mk"}
{"formal_statement": "theorem mem_facets {\ud835\udd5c E : Type*} [ordered_ring \ud835\udd5c] [add_comm_group E] [module \ud835\udd5c E]\n\t{K : geometry.simplicial_complex \ud835\udd5c E} {s : finset E} :\n\ts \u2208 K.facets \u2194 s \u2208 K.faces \u2227 \u2200 (t : finset E), t \u2208 K.faces \u2192 s \u2286 t \u2192 s = t", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} {E : Type u_2} [_inst_1 : ordered_ring \ud835\udd5c] [_inst_2 : add_comm_group E] [_inst_3 : module \ud835\udd5c E] {K : geometry.simplicial_complex \ud835\udd5c E} {s : finset E}, s \u2208 K.facets \u2194 s \u2208 K.faces \u2227 \u2200 (t : finset E), t \u2208 K.faces \u2192 s \u2286 t \u2192 s = t", "decl_nm": "geometry.simplicial_complex.mem_facets"}
{"formal_statement": "theorem mem_map {\u03b1 \u03b2 : Type*} (f : \u03b1 \u2192 \u03b2) {o : part \u03b1} {a : \u03b1} (\u1fb0 : a \u2208 o) :\n\tf a \u2208 part.map f o", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} (f : \u03b1 \u2192 \u03b2) {o : part \u03b1} {a : \u03b1}, a \u2208 o \u2192 f a \u2208 part.map f o", "decl_nm": "part.mem_map"}
{"formal_statement": "theorem eq_top_of_bot_eq_top {\u03b1 : Type u} [partial_order \u03b1] [bounded_order \u03b1]\n\t(h\u03b1 : \u22a5 = \u22a4) :\n\t\u2200 (x : \u03b1), x = \u22a4", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : partial_order \u03b1] [_inst_2 : bounded_order \u03b1], \u22a5 = \u22a4 \u2192 \u2200 (x : \u03b1), x = \u22a4", "decl_nm": "eq_top_of_bot_eq_top"}
{"formal_statement": "theorem comp_id {C : Type u\u2081} [category_theory.category C] {D : Type u\u2082}\n\t[category_theory.category D] (F : C \u2964 D) :\n\tF \u22d9 \ud835\udfed D = F", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {D : Type u\u2082} [_inst_2 : category_theory.category D] (F : C \u2964 D), F \u22d9 \ud835\udfed D = F", "decl_nm": "category_theory.functor.comp_id"}
{"formal_statement": "theorem update_row_ne {m n : Type*} {\u03b1 : Type v} {M : matrix n m \u03b1} {i : n}\n\t{b : m \u2192 \u03b1} [decidable_eq n] {i' : n} (i_ne : i' \u2260 i) :\n\tM.update_row i b i' = M i'", "decl_tp": "\u2200 {m : Type u_2} {n : Type u_3} {\u03b1 : Type v} {M : matrix n m \u03b1} {i : n} {b : m \u2192 \u03b1} [_inst_1 : decidable_eq n] {i' : n}, i' \u2260 i \u2192 M.update_row i b i' = M i'", "decl_nm": "matrix.update_row_ne"}
{"formal_statement": "theorem I_mul_I_of_nonzero {K : Type*} [is_R_or_C K] (\u1fb0 : is_R_or_C.I \u2260 0) :\n\tis_R_or_C.I * is_R_or_C.I = -1", "decl_tp": "\u2200 {K : Type u_1} [_inst_1 : is_R_or_C K], is_R_or_C.I \u2260 0 \u2192 is_R_or_C.I * is_R_or_C.I = -1", "decl_nm": "is_R_or_C.I_mul_I_of_nonzero"}
{"formal_statement": "theorem id {\u03b1 : Type*} [primcodable \u03b1] :\n\tprimrec id", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : primcodable \u03b1], primrec id", "decl_nm": "primrec.id"}
{"formal_statement": "theorem diagram_to_cone_X {C : Type u\u2081} [category_theory.category C] {D : Type u\u2082}\n\t[category_theory.category D] {J : Type v\u2081} [category_theory.small_category J]\n\t(F : C \u2964 D) {X : D} (G : J \u2964 category_theory.structured_arrow X F) :\n\t(category_theory.structured_arrow_cone.diagram_to_cone F G).X = X", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {D : Type u\u2082} [_inst_2 : category_theory.category D] {J : Type v\u2081} [_inst_3 : category_theory.small_category J] (F : C \u2964 D) {X : D} (G : J \u2964 category_theory.structured_arrow X F), (category_theory.structured_arrow_cone.diagram_to_cone F G).X = X", "decl_nm": "category_theory.structured_arrow_cone.diagram_to_cone_X"}
{"formal_statement": "theorem gal_C_is_solvable {F : Type*} [field F] (x : F) :\n\tis_solvable (\u21d1polynomial.C x).gal", "decl_tp": "\u2200 {F : Type u_1} [_inst_1 : field F] (x : F), is_solvable (\u21d1polynomial.C x).gal", "decl_nm": "gal_C_is_solvable"}
{"formal_statement": "theorem cos_pi_div_two :\n\treal.cos (real.pi / 2) = 0", "decl_tp": "real.cos (real.pi / 2) = 0", "decl_nm": "real.cos_pi_div_two"}
{"formal_statement": "theorem trans {X : Type u} {Y : Type v} [topological_space X] [topological_space Y]\n\t{P : C(X, Y) \u2192 Prop} \u2983f g h : C(X, Y)\u2984 (h\u2080 : f.homotopic_with g P) (h\u2081 : g.homotopic_with h P) :\n\tf.homotopic_with h P", "decl_tp": "\u2200 {X : Type u} {Y : Type v} [_inst_1 : topological_space X] [_inst_2 : topological_space Y] {P : C(X, Y) \u2192 Prop} \u2983f g h : C(X, Y)\u2984, f.homotopic_with g P \u2192 g.homotopic_with h P \u2192 f.homotopic_with h P", "decl_nm": "continuous_map.homotopic_with.trans"}
{"formal_statement": "theorem cos_pi_sub (x : \u211d) :\n\treal.cos (real.pi - x) = -real.cos x", "decl_tp": "\u2200 (x : \u211d), real.cos (real.pi - x) = -real.cos x", "decl_nm": "real.cos_pi_sub"}
{"formal_statement": "theorem le_sup {\u03b1 \u03b2 : Type*} [semilattice_sup \u03b1] [order_bot \u03b1] {s : finset \u03b2}\n\t{f : \u03b2 \u2192 \u03b1} {b : \u03b2} (hb : b \u2208 s) :\n\tf b \u2264 s.sup f", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : semilattice_sup \u03b1] [_inst_2 : order_bot \u03b1] {s : finset \u03b2} {f : \u03b2 \u2192 \u03b1} {b : \u03b2}, b \u2208 s \u2192 f b \u2264 s.sup f", "decl_nm": "finset.le_sup"}
{"formal_statement": "theorem add_hom_ext' {\u03b1 M N : Type*} [add_zero_class M] [add_zero_class N] \u2983f g : (\u03b1 \u2192\u2080 M) \u2192+ N\u2984 :\n\t(\u2200 (x : \u03b1), f.comp (finsupp.single_add_hom x) = g.comp (finsupp.single_add_hom x)) \u2192 f = g", "decl_tp": "\u2200 {\u03b1 : Type u_1} {M : Type u_5} {N : Type u_7} [_inst_1 : add_zero_class M] [_inst_2 : add_zero_class N] \u2983f g : (\u03b1 \u2192\u2080 M) \u2192+ N\u2984, (\u2200 (x : \u03b1), f.comp (finsupp.single_add_hom x) = g.comp (finsupp.single_add_hom x)) \u2192 f = g", "decl_nm": "finsupp.add_hom_ext'"}
{"formal_statement": "theorem mk_range_eq_lift {\u03b1 : Type u} {\u03b2 : Type v} {f : \u03b1 \u2192 \u03b2} (hf : function.injective f) :\n\t(cardinal.mk \u21a5(set.range f)).lift = (cardinal.mk \u03b1).lift", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {f : \u03b1 \u2192 \u03b2}, function.injective f \u2192 (cardinal.mk \u21a5(set.range f)).lift = (cardinal.mk \u03b1).lift", "decl_nm": "cardinal.mk_range_eq_lift"}
{"formal_statement": "theorem unique {\u03b1 : Type*} [comm_monoid \u03b1] [decidable_rel has_dvd.dvd]\n\t{a b : \u03b1} {k : \u2115} (hk : a ^ k \u2223 b) (hsucc : \u00aca ^ (k + 1) \u2223 b) :\n\t\u2191k = multiplicity a b", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : comm_monoid \u03b1] [_inst_2 : decidable_rel has_dvd.dvd] {a b : \u03b1} {k : \u2115}, a ^ k \u2223 b \u2192 \u00aca ^ (k + 1) \u2223 b \u2192 \u2191k = multiplicity a b", "decl_nm": "multiplicity.unique"}
{"formal_statement": "theorem inv_fun_on_mem {\u03b1 : Type u} [n : nonempty \u03b1] {\u03b2 : Sort v} {f : \u03b1 \u2192 \u03b2}\n\t{s : set \u03b1} {b : \u03b2} :\n\t(\u2203 (a : \u03b1) (H : a \u2208 s), f a = b) \u2192 function.inv_fun_on f s b \u2208 s", "decl_tp": "\u2200 {\u03b1 : Type u} [n : nonempty \u03b1] {\u03b2 : Sort v} {f : \u03b1 \u2192 \u03b2} {s : set \u03b1} {b : \u03b2}, (\u2203 (a : \u03b1) (H : a \u2208 s), f a = b) \u2192 function.inv_fun_on f s b \u2208 s", "decl_nm": "function.inv_fun_on_mem"}
{"formal_statement": "theorem coe_complex_coe (r : \u211d) :\n\t\u2191\u2191r = \u2191r", "decl_tp": "\u2200 (r : \u211d), \u2191\u2191r = \u2191r", "decl_nm": "quaternion.coe_complex_coe"}
{"formal_statement": "theorem measure_union_lt_top_iff {\u03b1 : Type*} [measurable_space \u03b1] {\u03bc : measure_theory.measure \u03b1}\n\t{s t : set \u03b1} :\n\t\u21d1\u03bc (s \u222a t) < \u22a4 \u2194 \u21d1\u03bc s < \u22a4 \u2227 \u21d1\u03bc t < \u22a4", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : measurable_space \u03b1] {\u03bc : measure_theory.measure \u03b1} {s t : set \u03b1}, \u21d1\u03bc (s \u222a t) < \u22a4 \u2194 \u21d1\u03bc s < \u22a4 \u2227 \u21d1\u03bc t < \u22a4", "decl_nm": "measure_theory.measure_union_lt_top_iff"}
{"formal_statement": "theorem is_countably_spanning_spanning_sets {\u03b1 : Type*} {m0 : measurable_space \u03b1}\n\t(\u03bc : measure_theory.measure \u03b1) [measure_theory.sigma_finite \u03bc] :\n\tis_countably_spanning (set.range (measure_theory.spanning_sets \u03bc))", "decl_tp": "\u2200 {\u03b1 : Type u_1} {m0 : measurable_space \u03b1} (\u03bc : measure_theory.measure \u03b1) [_inst_3 : measure_theory.sigma_finite \u03bc], is_countably_spanning (set.range (measure_theory.spanning_sets \u03bc))", "decl_nm": "measure_theory.is_countably_spanning_spanning_sets"}
{"formal_statement": "theorem has_limits_of_shape_op_of_has_colimits_of_shape {C : Type u} [category_theory.category C]\n\t{J : Type v} [category_theory.small_category J] [category_theory.limits.has_colimits_of_shape J\u1d52\u1d56 C] :\n\tcategory_theory.limits.has_limits_of_shape J C\u1d52\u1d56", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] {J : Type v} [_inst_2 : category_theory.small_category J] [_inst_3 : category_theory.limits.has_colimits_of_shape J\u1d52\u1d56 C], category_theory.limits.has_limits_of_shape J C\u1d52\u1d56", "decl_nm": "category_theory.limits.has_limits_of_shape_op_of_has_colimits_of_shape"}
{"formal_statement": "theorem to_monoid_with_zero_hom_eq_coe {\u03b1 : Type u} {\u03b2 : Type v} {r\u03b1 : non_assoc_semiring \u03b1}\n\t{r\u03b2 : non_assoc_semiring \u03b2} (f : \u03b1 \u2192+* \u03b2) :\n\t\u21d1(f.to_monoid_with_zero_hom) = \u21d1f", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {r\u03b1 : non_assoc_semiring \u03b1} {r\u03b2 : non_assoc_semiring \u03b2} (f : \u03b1 \u2192+* \u03b2), \u21d1(f.to_monoid_with_zero_hom) = \u21d1f", "decl_nm": "ring_hom.to_monoid_with_zero_hom_eq_coe"}
{"formal_statement": "theorem gcd_one_right (i : \u2124) :\n\ti.gcd 1 = 1", "decl_tp": "\u2200 (i : \u2124), i.gcd 1 = 1", "decl_nm": "int.gcd_one_right"}
{"formal_statement": "theorem floor_eq_on_Ico' {\u03b1 : Type*} [linear_ordered_ring \u03b1] [floor_ring \u03b1]\n\t(n : \u2124) (a : \u03b1) (ha : a \u2208 set.Ico \u2191n (\u2191n + 1)) :\n\t\u2191\u230aa\u230b = \u2191n", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : linear_ordered_ring \u03b1] [_inst_2 : floor_ring \u03b1] (n : \u2124) (a : \u03b1), a \u2208 set.Ico \u2191n (\u2191n + 1) \u2192 \u2191\u230aa\u230b = \u2191n", "decl_nm": "int.floor_eq_on_Ico'"}
{"formal_statement": "theorem braiding_hom {C : Type u} [category_theory.category C] (P Q : C)\n\t[category_theory.limits.has_binary_product P Q] [category_theory.limits.has_binary_product Q P] :\n\t(category_theory.limits.prod.braiding P Q).hom = category_theory.limits.prod.lift category_theory.limits.prod.snd category_theory.limits.prod.fst", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] (P Q : C) [_inst_2 : category_theory.limits.has_binary_product P Q] [_inst_3 : category_theory.limits.has_binary_product Q P], (category_theory.limits.prod.braiding P Q).hom = category_theory.limits.prod.lift category_theory.limits.prod.snd category_theory.limits.prod.fst", "decl_nm": "category_theory.limits.prod.braiding_hom"}
{"formal_statement": "theorem eq_of_lt_succ_of_not_lt {a b : \u2115} (h1 : a < b + 1) (h2 : \u00aca < b) :\n\ta = b", "decl_tp": "\u2200 {a b : \u2115}, a < b + 1 \u2192 \u00aca < b \u2192 a = b", "decl_nm": "nat.eq_of_lt_succ_of_not_lt"}
{"formal_statement": "theorem comap_map {\u03b1 : Type u} {\u03b2 : Type v} {f : filter \u03b1} {m : \u03b1 \u2192 \u03b2}\n\t(h : function.injective m) :\n\tfilter.comap m (filter.map m f) = f", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {f : filter \u03b1} {m : \u03b1 \u2192 \u03b2}, function.injective m \u2192 filter.comap m (filter.map m f) = f", "decl_nm": "filter.comap_map"}
{"formal_statement": "theorem diagram_to_cone_\u03c0_app {C : Type u\u2081} [category_theory.category C]\n\t{D : Type u\u2082} [category_theory.category D] {J : Type v\u2081} [category_theory.small_category J]\n\t(F : C \u2964 D) {X : D} (G : J \u2964 category_theory.structured_arrow X F) (j : J) :\n\t(category_theory.structured_arrow_cone.diagram_to_cone F G).\u03c0.app j = (G.obj j).hom", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {D : Type u\u2082} [_inst_2 : category_theory.category D] {J : Type v\u2081} [_inst_3 : category_theory.small_category J] (F : C \u2964 D) {X : D} (G : J \u2964 category_theory.structured_arrow X F) (j : J), (category_theory.structured_arrow_cone.diagram_to_cone F G).\u03c0.app j = (G.obj j).hom", "decl_nm": "category_theory.structured_arrow_cone.diagram_to_cone_\u03c0_app"}
{"formal_statement": "theorem differentiable_at {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c] {E : Type*}\n\t[normed_group E] [normed_space \ud835\udd5c E] {F : Type*} [normed_group F] [normed_space \ud835\udd5c F]\n\t{f : E \u2192 F} {x : E} (h : differentiable \ud835\udd5c f) :\n\tdifferentiable_at \ud835\udd5c f x", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {F : Type u_3} [_inst_4 : normed_group F] [_inst_5 : normed_space \ud835\udd5c F] {f : E \u2192 F} {x : E}, differentiable \ud835\udd5c f \u2192 differentiable_at \ud835\udd5c f x", "decl_nm": "differentiable.differentiable_at"}
{"formal_statement": "theorem add_left {R : Type x} [distrib R] {a b x y : R} (ha : semiconj_by a x y)\n\t(hb : semiconj_by b x y) :\n\tsemiconj_by (a + b) x y", "decl_tp": "\u2200 {R : Type x} [_inst_1 : distrib R] {a b x y : R}, semiconj_by a x y \u2192 semiconj_by b x y \u2192 semiconj_by (a + b) x y", "decl_nm": "semiconj_by.add_left"}
{"formal_statement": "theorem C_bit0 {R : Type u} {a : R} [semiring R] :\n\t\u21d1polynomial.C (bit0 a) = bit0 (\u21d1polynomial.C a)", "decl_tp": "\u2200 {R : Type u} {a : R} [_inst_1 : semiring R], \u21d1polynomial.C (bit0 a) = bit0 (\u21d1polynomial.C a)", "decl_nm": "polynomial.C_bit0"}
{"formal_statement": "theorem infinite_neg_mul_of_not_infinitesimal_pos_infinite_neg {x y : \u211d*}\n\t(hx : \u00acx.infinitesimal) (hp : 0 < x) (hy : y.infinite_neg) :\n\t(x * y).infinite_neg", "decl_tp": "\u2200 {x y : \u211d*}, \u00acx.infinitesimal \u2192 0 < x \u2192 y.infinite_neg \u2192 (x * y).infinite_neg", "decl_nm": "hyperreal.infinite_neg_mul_of_not_infinitesimal_pos_infinite_neg"}
{"formal_statement": "theorem coe_fn_zero {\u03b1 : Type*} (E : Type*) {m0 : measurable_space \u03b1} (p : ennreal)\n\t(\u03bc : measure_theory.measure \u03b1) [measurable_space E] [normed_group E] [borel_space E]\n\t[topological_space.second_countable_topology E] :\n\t\u21d10 =\u1d50[\u03bc] 0", "decl_tp": "\u2200 {\u03b1 : Type u_1} (E : Type u_2) {m0 : measurable_space \u03b1} (p : ennreal) (\u03bc : measure_theory.measure \u03b1) [_inst_1 : measurable_space E] [_inst_2 : normed_group E] [_inst_5 : borel_space E] [_inst_6 : topological_space.second_countable_topology E], \u21d10 =\u1d50[\u03bc] 0", "decl_nm": "measure_theory.Lp.coe_fn_zero"}
{"formal_statement": "theorem tendsto_at_bot' {\u03b1 \u03b2 : Type*} [nonempty \u03b1] [semilattice_inf \u03b1]\n\t{f : \u03b1 \u2192 \u03b2} {l : filter \u03b2} :\n\tfilter.tendsto f filter.at_bot l \u2194 \u2200 (s : set \u03b2), s \u2208 l \u2192 (\u2203 (a : \u03b1), \u2200 (b : \u03b1), b \u2264 a \u2192 f b \u2208 s)", "decl_tp": "\u2200 {\u03b1 : Type u_3} {\u03b2 : Type u_4} [_inst_1 : nonempty \u03b1] [_inst_2 : semilattice_inf \u03b1] {f : \u03b1 \u2192 \u03b2} {l : filter \u03b2}, filter.tendsto f filter.at_bot l \u2194 \u2200 (s : set \u03b2), s \u2208 l \u2192 (\u2203 (a : \u03b1), \u2200 (b : \u03b1), b \u2264 a \u2192 f b \u2208 s)", "decl_nm": "filter.tendsto_at_bot'"}
{"formal_statement": "theorem nat_add {x : \u211d} (h : irrational x) :\n\t\u2200 (m : \u2115), irrational (\u2191m + x)", "decl_tp": "\u2200 {x : \u211d}, irrational x \u2192 \u2200 (m : \u2115), irrational (\u2191m + x)", "decl_nm": "irrational.nat_add"}
{"formal_statement": "theorem leibniz_lie {L : Type v} {M : Type w} [lie_ring L] [add_comm_group M]\n\t[lie_ring_module L M] (x y : L) (m : M) :\n\t\u2045x,\u2045y,m\u2046\u2046 = \u2045\u2045x,y\u2046,m\u2046 + \u2045y,\u2045x,m\u2046\u2046", "decl_tp": "\u2200 {L : Type v} {M : Type w} [_inst_2 : lie_ring L] [_inst_4 : add_comm_group M] [_inst_6 : lie_ring_module L M] (x y : L) (m : M), \u2045x,\u2045y,m\u2046\u2046 = \u2045\u2045x,y\u2046,m\u2046 + \u2045y,\u2045x,m\u2046\u2046", "decl_nm": "leibniz_lie"}
{"formal_statement": "theorem to_non_unital_alg_hom_apply {R : Type u} {L : Type v} [comm_ring R]\n\t[lie_ring L] [lie_algebra R L] {L\u2082 : Type w} [lie_ring L\u2082] [lie_algebra R L\u2082]\n\t(f : L \u2192\u2097\u2045R\u2046 L\u2082) (\u1fb0 : L) :\n\t\u21d1(f.to_non_unital_alg_hom) \u1fb0 = \u21d1f \u1fb0", "decl_tp": "\u2200 {R : Type u} {L : Type v} [_inst_1 : comm_ring R] [_inst_2 : lie_ring L] [_inst_3 : lie_algebra R L] {L\u2082 : Type w} [_inst_4 : lie_ring L\u2082] [_inst_5 : lie_algebra R L\u2082] (f : L \u2192\u2097\u2045R\u2046 L\u2082) (\u1fb0 : L), \u21d1(f.to_non_unital_alg_hom) \u1fb0 = \u21d1f \u1fb0", "decl_nm": "lie_hom.to_non_unital_alg_hom_apply"}
{"formal_statement": "theorem conj_lie_apply (z : \u2102) :\n\t\u21d1complex.conj_lie z = \u21d1star_ring_aut z", "decl_tp": "\u2200 (z : \u2102), \u21d1complex.conj_lie z = \u21d1star_ring_aut z", "decl_nm": "complex.conj_lie_apply"}
{"formal_statement": "theorem smul_def {M : Type*} [mul_action ennreal M] (c : nnreal) (x : M) :\n\tc \u2022 x = \u2191c \u2022 x", "decl_tp": "\u2200 {M : Type u_1} [_inst_1 : mul_action ennreal M] (c : nnreal) (x : M), c \u2022 x = \u2191c \u2022 x", "decl_nm": "ennreal.smul_def"}
{"formal_statement": "theorem sum_zero_index {\u03b1 M N : Type*} [has_zero M] [add_comm_monoid N]\n\t{h : \u03b1 \u2192 M \u2192 N} :\n\t0.sum h = 0", "decl_tp": "\u2200 {\u03b1 : Type u_1} {M : Type u_5} {N : Type u_7} [_inst_1 : has_zero M] [_inst_3 : add_comm_monoid N] {h : \u03b1 \u2192 M \u2192 N}, 0.sum h = 0", "decl_nm": "finsupp.sum_zero_index"}
{"formal_statement": "theorem sum_congr {\u03b1 M N : Type*} [has_zero M] [add_comm_monoid N] {f : \u03b1 \u2192\u2080 M}\n\t{g1 g2 : \u03b1 \u2192 M \u2192 N} :\n\t(\u2200 (x : \u03b1), x \u2208 f.support \u2192 g1 x (\u21d1f x) = g2 x (\u21d1f x)) \u2192 f.sum g1 = f.sum g2", "decl_tp": "\u2200 {\u03b1 : Type u_1} {M : Type u_5} {N : Type u_7} [_inst_1 : has_zero M] [_inst_3 : add_comm_monoid N] {f : \u03b1 \u2192\u2080 M} {g1 g2 : \u03b1 \u2192 M \u2192 N}, (\u2200 (x : \u03b1), x \u2208 f.support \u2192 g1 x (\u21d1f x) = g2 x (\u21d1f x)) \u2192 f.sum g1 = f.sum g2", "decl_nm": "finsupp.sum_congr"}
{"formal_statement": "theorem mul_salem_spencer_pi {\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} [\u03a0 (i : \u03b9), monoid (\u03b1 i)]\n\t{s : \u03a0 (i : \u03b9), set (\u03b1 i)} :\n\t(\u2200 (i : \u03b9), mul_salem_spencer (s i)) \u2192 mul_salem_spencer (set.univ.pi s)", "decl_tp": "\u2200 {\u03b9 : Type u_1} {\u03b1 : \u03b9 \u2192 Type u_2} [_inst_3 : \u03a0 (i : \u03b9), monoid (\u03b1 i)] {s : \u03a0 (i : \u03b9), set (\u03b1 i)}, (\u2200 (i : \u03b9), mul_salem_spencer (s i)) \u2192 mul_salem_spencer (set.univ.pi s)", "decl_nm": "mul_salem_spencer_pi"}
{"formal_statement": "theorem cones_equiv_inverse {C : Type v} [category_theory.small_category C]\n\t{D : Type v} [category_theory.small_category D] (F : C \u2964 D) [F.initial]\n\t{E : Type u} [category_theory.category E] (G : D \u2964 E) :\n\t(category_theory.functor.initial.cones_equiv F G).inverse = category_theory.limits.cones.whiskering F", "decl_tp": "\u2200 {C : Type v} [_inst_1 : category_theory.small_category C] {D : Type v} [_inst_2 : category_theory.small_category D] (F : C \u2964 D) [_inst_3 : F.initial] {E : Type u} [_inst_4 : category_theory.category E] (G : D \u2964 E), (category_theory.functor.initial.cones_equiv F G).inverse = category_theory.limits.cones.whiskering F", "decl_nm": "category_theory.functor.initial.cones_equiv_inverse"}
{"formal_statement": "theorem get_mem {\u03b1 : Type*} {q : semiquot \u03b1} (p : q.is_pure) :\n\tq.get p \u2208 q", "decl_tp": "\u2200 {\u03b1 : Type u_1} {q : semiquot \u03b1} (p : q.is_pure), q.get p \u2208 q", "decl_nm": "semiquot.get_mem"}
{"formal_statement": "theorem to_quotient_apply {G : Type*6} [group G] (H : subgroup G) (g : G) :\n\t\u21d1(mul_action_hom.to_quotient H) g = \u2191g", "decl_tp": "\u2200 {G : Type u_16} [_inst_25 : group G] (H : subgroup G) (g : G), \u21d1(mul_action_hom.to_quotient H) g = \u2191g", "decl_nm": "mul_action_hom.to_quotient_apply"}
{"formal_statement": "theorem mul' {M \u03b1 : Type*} [measurable_space M] [has_mul M] [measurable_space \u03b1]\n\t[has_measurable_mul\u2082 M] {f g : \u03b1 \u2192 M} (hf : measurable f) (hg : measurable g) :\n\tmeasurable (f * g)", "decl_tp": "\u2200 {M : Type u_1} {\u03b1 : Type u_2} [_inst_1 : measurable_space M] [_inst_2 : has_mul M] [_inst_3 : measurable_space \u03b1] [_inst_4 : has_measurable_mul\u2082 M] {f g : \u03b1 \u2192 M}, measurable f \u2192 measurable g \u2192 measurable (f * g)", "decl_nm": "measurable.mul'"}
{"formal_statement": "theorem coe_prod {M N : Type*} [add_zero_class M] [add_zero_class N] (s : add_submonoid M)\n\t(t : add_submonoid N) :\n\t\u2191(s.prod t) = \u2191s.prod \u2191t", "decl_tp": "\u2200 {M : Type u_1} {N : Type u_2} [_inst_1 : add_zero_class M] [_inst_2 : add_zero_class N] (s : add_submonoid M) (t : add_submonoid N), \u2191(s.prod t) = \u2191s.prod \u2191t", "decl_nm": "add_submonoid.coe_prod"}
{"formal_statement": "theorem associator_inv {C : Type u} [category_theory.category C] [category_theory.limits.has_binary_coproducts C]\n\t(P Q R : C) :\n\t(category_theory.limits.coprod.associator P Q R).inv = category_theory.limits.coprod.desc (category_theory.limits.coprod.inl \u226b category_theory.limits.coprod.inl)\n\t(category_theory.limits.coprod.desc (category_theory.limits.coprod.inr \u226b category_theory.limits.coprod.inl) category_theory.limits.coprod.inr)", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] [_inst_2 : category_theory.limits.has_binary_coproducts C] (P Q R : C), (category_theory.limits.coprod.associator P Q R).inv = category_theory.limits.coprod.desc (category_theory.limits.coprod.inl \u226b category_theory.limits.coprod.inl) (category_theory.limits.coprod.desc (category_theory.limits.coprod.inr \u226b category_theory.limits.coprod.inl) category_theory.limits.coprod.inr)", "decl_nm": "category_theory.limits.coprod.associator_inv"}
{"formal_statement": "theorem neg_left {R : Type x} [ring R] {a x y : R} (h : semiconj_by a x y) :\n\tsemiconj_by (-a) x y", "decl_tp": "\u2200 {R : Type x} [_inst_1 : ring R] {a x y : R}, semiconj_by a x y \u2192 semiconj_by (-a) x y", "decl_nm": "semiconj_by.neg_left"}
{"formal_statement": "theorem zpow_of_nat {G : Type*} [div_inv_monoid G] (a : G) (n : \u2115) :\n\ta ^ int.of_nat n = a ^ n", "decl_tp": "\u2200 {G : Type u_1} [_inst_1 : div_inv_monoid G] (a : G) (n : \u2115), a ^ int.of_nat n = a ^ n", "decl_nm": "zpow_of_nat"}
{"formal_statement": "theorem refl (x : pSet) :\n\tx.equiv x", "decl_tp": "\u2200 (x : pSet), x.equiv x", "decl_nm": "pSet.equiv.refl"}
{"formal_statement": "theorem tail_even {\u03b1 : Type u} (s : stream \u03b1) :\n\ts.even.tail = s.tail.tail.even", "decl_tp": "\u2200 {\u03b1 : Type u} (s : stream \u03b1), s.even.tail = s.tail.tail.even", "decl_nm": "stream.tail_even"}
{"formal_statement": "theorem dual {\u03b1 : Type u} [preorder \u03b1] {s : set \u03b1} (h : bdd_above s) :\n\tbdd_below (\u21d1order_dual.of_dual \u207b\u00b9' s)", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : preorder \u03b1] {s : set \u03b1}, bdd_above s \u2192 bdd_below (\u21d1order_dual.of_dual \u207b\u00b9' s)", "decl_nm": "bdd_above.dual"}
{"formal_statement": "theorem exists_maximal_of_nonempty_chains_bounded {\u03b1 : Type u} {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\n\t[nonempty \u03b1] :\n\t(\u2200 (c : set \u03b1), zorn.chain r c \u2192 c.nonempty \u2192 (\u2203 (ub : \u03b1), \u2200 (a : \u03b1), a \u2208 c \u2192 r a ub)) \u2192 (\u2200 {a b c : \u03b1}, r a b \u2192 r b c \u2192 r a c) \u2192 (\u2203 (m : \u03b1), \u2200 (a : \u03b1), r m a \u2192 r a m)", "decl_tp": "\u2200 {\u03b1 : Type u} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [_inst_1 : nonempty \u03b1], (\u2200 (c : set \u03b1), zorn.chain r c \u2192 c.nonempty \u2192 (\u2203 (ub : \u03b1), \u2200 (a : \u03b1), a \u2208 c \u2192 r a ub)) \u2192 (\u2200 {a b c : \u03b1}, r a b \u2192 r b c \u2192 r a c) \u2192 (\u2203 (m : \u03b1), \u2200 (a : \u03b1), r m a \u2192 r a m)", "decl_nm": "zorn.exists_maximal_of_nonempty_chains_bounded"}
{"formal_statement": "theorem preimage_injective {\u03b1 : Type u} {\u03b2 : Type v} {f : \u03b1 \u2192 \u03b2} :\n\tfunction.injective (set.preimage f) \u2194 function.surjective f", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {f : \u03b1 \u2192 \u03b2}, function.injective (set.preimage f) \u2194 function.surjective f", "decl_nm": "set.preimage_injective"}
{"formal_statement": "theorem mk_lt_mk {\u03b1 : Type u} {\u03b2 : Type v} [preorder \u03b1] [preorder \u03b2] {x\u2081 x\u2082 : \u03b1}\n\t{y\u2081 y\u2082 : \u03b2} :\n\t(x\u2081, y\u2081) < (x\u2082, y\u2082) \u2194 x\u2081 < x\u2082 \u2227 y\u2081 \u2264 y\u2082 \u2228 x\u2081 \u2264 x\u2082 \u2227 y\u2081 < y\u2082", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : preorder \u03b1] [_inst_2 : preorder \u03b2] {x\u2081 x\u2082 : \u03b1} {y\u2081 y\u2082 : \u03b2}, (x\u2081, y\u2081) < (x\u2082, y\u2082) \u2194 x\u2081 < x\u2082 \u2227 y\u2081 \u2264 y\u2082 \u2228 x\u2081 \u2264 x\u2082 \u2227 y\u2081 < y\u2082", "decl_nm": "prod.mk_lt_mk"}
{"formal_statement": "theorem translation_number_eq_of_tendsto_aux (f : circle_deg1_lift) {\u03c4' : \u211d}\n\t(h : filter.tendsto f.transnum_aux_seq filter.at_top (nhds \u03c4')) :\n\tf.translation_number = \u03c4'", "decl_tp": "\u2200 (f : circle_deg1_lift) {\u03c4' : \u211d}, filter.tendsto f.transnum_aux_seq filter.at_top (nhds \u03c4') \u2192 f.translation_number = \u03c4'", "decl_nm": "circle_deg1_lift.translation_number_eq_of_tendsto_aux"}
{"formal_statement": "theorem mem_pair {x y z : Set} :\n\tx \u2208 {y, z} \u2194 x = y \u2228 x = z", "decl_tp": "\u2200 {x y z : Set}, x \u2208 {y, z} \u2194 x = y \u2228 x = z", "decl_nm": "Set.mem_pair"}
{"formal_statement": "theorem succ_above_right_injective {n : \u2115} {x : fin (n + 1)} :\n\tfunction.injective \u21d1(x.succ_above)", "decl_tp": "\u2200 {n : \u2115} {x : fin (n + 1)}, function.injective \u21d1(x.succ_above)", "decl_nm": "fin.succ_above_right_injective"}
{"formal_statement": "theorem nonneg_of_normalize_eq_self {z : \u2124} (hz : \u21d1normalize z = z) :\n\t0 \u2264 z", "decl_tp": "\u2200 {z : \u2124}, \u21d1normalize z = z \u2192 0 \u2264 z", "decl_nm": "int.nonneg_of_normalize_eq_self"}
{"formal_statement": "theorem mem_Icc_of_Ioc {\u03b1 : Type u} [preorder \u03b1] {a b x : \u03b1} (h : x \u2208 set.Ioc a b) :\n\tx \u2208 set.Icc a b", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : preorder \u03b1] {a b x : \u03b1}, x \u2208 set.Ioc a b \u2192 x \u2208 set.Icc a b", "decl_nm": "set.mem_Icc_of_Ioc"}
{"formal_statement": "theorem integral_undef {E : Type*} [measurable_space E] [normed_group E]\n\t[normed_space \u2102 E] [complete_space E] [borel_space E] [topological_space.second_countable_topology E]\n\t{f : \u2102 \u2192 E} {c : \u2102} {R : \u211d} (hf : \u00accircle_integrable f c R) :\n\t\u222e (z : \u2102) in C(c, R), f z = 0", "decl_tp": "\u2200 {E : Type u_1} [_inst_1 : measurable_space E] [_inst_2 : normed_group E] [_inst_3 : normed_space \u2102 E] [_inst_4 : complete_space E] [_inst_5 : borel_space E] [_inst_6 : topological_space.second_countable_topology E] {f : \u2102 \u2192 E} {c : \u2102} {R : \u211d}, \u00accircle_integrable f c R \u2192 \u222e (z : \u2102) in C(c, R), f z = 0", "decl_nm": "circle_integral.integral_undef"}
{"formal_statement": "theorem one_div_le_one_div_of_le {\u03b1 : Type*} [linear_ordered_field \u03b1] {a b : \u03b1}\n\t(ha : 0 < a) (h : a \u2264 b) :\n\t1 / b \u2264 1 / a", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : linear_ordered_field \u03b1] {a b : \u03b1}, 0 < a \u2192 a \u2264 b \u2192 1 / b \u2264 1 / a", "decl_nm": "one_div_le_one_div_of_le"}
{"formal_statement": "theorem measurable_circle_map (c : \u2102) (R : \u211d) :\n\tmeasurable (circle_map c R)", "decl_tp": "\u2200 (c : \u2102) (R : \u211d), measurable (circle_map c R)", "decl_nm": "measurable_circle_map"}
{"formal_statement": "theorem dgo_equiv_homological_complex_inverse {\u03b2 : Type*} [add_comm_group \u03b2]\n\t(b : \u03b2) (V : Type*) [category_theory.category V] [category_theory.limits.has_zero_morphisms V] :\n\t(homological_complex.dgo_equiv_homological_complex b V).inverse = homological_complex.homological_complex_to_dgo b V", "decl_tp": "\u2200 {\u03b2 : Type u_1} [_inst_1 : add_comm_group \u03b2] (b : \u03b2) (V : Type u_2) [_inst_2 : category_theory.category V] [_inst_3 : category_theory.limits.has_zero_morphisms V], (homological_complex.dgo_equiv_homological_complex b V).inverse = homological_complex.homological_complex_to_dgo b V", "decl_nm": "homological_complex.dgo_equiv_homological_complex_inverse"}
{"formal_statement": "theorem map_multiset_prod {R : Type u} {A : Type v} {B : Type w} [comm_semiring R]\n\t[comm_semiring A] [comm_semiring B] [algebra R A] [algebra R B] (\u03c6 : A \u2192\u2090[R] B)\n\t(s : multiset A) :\n\t\u21d1\u03c6 s.prod = (multiset.map \u21d1\u03c6 s).prod", "decl_tp": "\u2200 {R : Type u} {A : Type v} {B : Type w} [_inst_1 : comm_semiring R] [_inst_2 : comm_semiring A] [_inst_3 : comm_semiring B] [_inst_4 : algebra R A] [_inst_5 : algebra R B] (\u03c6 : A \u2192\u2090[R] B) (s : multiset A), \u21d1\u03c6 s.prod = (multiset.map \u21d1\u03c6 s).prod", "decl_nm": "alg_hom.map_multiset_prod"}
{"formal_statement": "theorem diagonal_map {n : Type*} {\u03b1 : Type v} {\u03b2 : Type w} [decidable_eq n]\n\t[has_zero \u03b1] [has_zero \u03b2] {f : \u03b1 \u2192 \u03b2} (h : f 0 = 0) (i : n) :\n\t\u2200 {d :  \u03b1}, (matrix.diagonal d).map f = matrix.diagonal (\u03bb (m : n), f (d m))", "decl_tp": "\u2200 {n : Type u_3} {\u03b1 : Type v} {\u03b2 : Type w} [_inst_1 : decidable_eq n] [_inst_2 : has_zero \u03b1] [_inst_3 : has_zero \u03b2] {f : \u03b1 \u2192 \u03b2}, f 0 = 0 \u2192 \u2200 {d : n \u2192 \u03b1}, (matrix.diagonal d).map f = matrix.diagonal (\u03bb (m : n), f (d m))", "decl_nm": "matrix.diagonal_map"}
{"formal_statement": "theorem of_finite_presentation {R A B : Type*} [comm_ring R] [comm_ring A]\n\t[comm_ring B] [algebra R A] [algebra R B] {f : A \u2192\u2090[R] B} (hf : f.finite_presentation) :\n\tf.finite_type", "decl_tp": "\u2200 {R : Type u_1} {A : Type u_2} {B : Type u_3} [_inst_1 : comm_ring R] [_inst_2 : comm_ring A] [_inst_3 : comm_ring B] [_inst_5 : algebra R A] [_inst_6 : algebra R B] {f : A \u2192\u2090[R] B}, f.finite_presentation \u2192 f.finite_type", "decl_nm": "alg_hom.finite_type.of_finite_presentation"}
{"formal_statement": "theorem fg_iff_mul_fg {N : Type*} [add_monoid N] :\n\tadd_monoid.fg N \u2194 monoid.fg (multiplicative N)", "decl_tp": "\u2200 {N : Type u_2} [_inst_2 : add_monoid N], add_monoid.fg N \u2194 monoid.fg (multiplicative N)", "decl_nm": "add_monoid.fg_iff_mul_fg"}
{"formal_statement": "theorem add_ne_top {a b : ennreal} :\n\ta + b \u2260 \u22a4 \u2194 a \u2260 \u22a4 \u2227 b \u2260 \u22a4", "decl_tp": "\u2200 {a b : ennreal}, a + b \u2260 \u22a4 \u2194 a \u2260 \u22a4 \u2227 b \u2260 \u22a4", "decl_nm": "ennreal.add_ne_top"}
{"formal_statement": "theorem eq_Icc_of_connected_compact {\u03b1 : Type*} [conditionally_complete_linear_order \u03b1]\n\t[topological_space \u03b1] [order_topology \u03b1] {s : set \u03b1} (h\u2081 : is_connected s)\n\t(h\u2082 : is_compact s) :\n\ts = set.Icc (has_Inf.Inf s) (has_Sup.Sup s)", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : conditionally_complete_linear_order \u03b1] [_inst_2 : topological_space \u03b1] [_inst_3 : order_topology \u03b1] {s : set \u03b1}, is_connected s \u2192 is_compact s \u2192 s = set.Icc (has_Inf.Inf s) (has_Sup.Sup s)", "decl_nm": "eq_Icc_of_connected_compact"}
{"formal_statement": "theorem det_coe {n : Type u} [decidable_eq n] [fintype n] {R : Type v}\n\t[comm_ring R] (A : matrix.special_linear_group n R) :\n\t\u2191A.det = 1", "decl_tp": "\u2200 {n : Type u} [_inst_1 : decidable_eq n] [_inst_2 : fintype n] {R : Type v} [_inst_3 : comm_ring R] (A : matrix.special_linear_group n R), \u2191A.det = 1", "decl_nm": "matrix.special_linear_group.det_coe"}
{"formal_statement": "theorem left_comparison {C : Type u\u2081} [category_theory.category C] {D : Type u\u2082}\n\t[category_theory.category D] {L : C \u2964 D} {R : D \u2964 C} (h : L \u22a3 R) :\n\tR \u22d9 category_theory.comonad.comparison h = h.to_comonad.cofree", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {D : Type u\u2082} [_inst_2 : category_theory.category D] {L : C \u2964 D} {R : D \u2964 C} (h : L \u22a3 R), R \u22d9 category_theory.comonad.comparison h = h.to_comonad.cofree", "decl_nm": "category_theory.comonad.left_comparison"}
{"formal_statement": "theorem CommMon_to_lax_braided_obj_to_lax_monoidal_functor_\u03b5 (C : Type u\u2081)\n\t[category_theory.category C] [category_theory.monoidal_category C] [category_theory.braided_category C]\n\t(A : CommMon_ C) :\n\t((CommMon_.equiv_lax_braided_functor_punit.CommMon_to_lax_braided C).obj A).to_lax_monoidal_functor.\u03b5 = A.to_Mon_.one", "decl_tp": "\u2200 (C : Type u\u2081) [_inst_1 : category_theory.category C] [_inst_2 : category_theory.monoidal_category C] [_inst_3 : category_theory.braided_category C] (A : CommMon_ C), ((CommMon_.equiv_lax_braided_functor_punit.CommMon_to_lax_braided C).obj A).to_lax_monoidal_functor.\u03b5 = A.to_Mon_.one", "decl_nm": "CommMon_.equiv_lax_braided_functor_punit.CommMon_to_lax_braided_obj_to_lax_monoidal_functor_\u03b5"}
{"formal_statement": "theorem abs_sin_le_one (x : \u211d) :\n\t|real.sin x| \u2264 1", "decl_tp": "\u2200 (x : \u211d), |real.sin x| \u2264 1", "decl_nm": "real.abs_sin_le_one"}
{"formal_statement": "theorem finite_range {\u03b1 : Type u} {\u03b9 : Sort w} (f : \u03b9 \u2192 \u03b1) [fintype (plift \u03b9)] :\n\t(set.range f).finite", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b9 : Sort w} (f : \u03b9 \u2192 \u03b1) [_inst_1 : fintype (plift \u03b9)], (set.range f).finite", "decl_nm": "set.finite_range"}
{"formal_statement": "theorem lhom_ext' {\u03b9 R : Type*} {M : \u03b9 \u2192 Type*} {N : Type*} [dec_\u03b9 : decidable_eq \u03b9]\n\t[semiring R] [\u03a0 (i : \u03b9), add_comm_monoid (M i)] [\u03a0 (i : \u03b9), module R (M i)]\n\t[add_comm_monoid N] [module R N] \u2983\u03c6 \u03c8 : (\u03a0\u2080 (i : \u03b9), M i) \u2192\u2097[R] N\u2984 :\n\t(\u2200 (i : \u03b9), \u03c6.comp (dfinsupp.lsingle i) = \u03c8.comp (dfinsupp.lsingle i)) \u2192 \u03c6 = \u03c8", "decl_tp": "\u2200 {\u03b9 : Type u_1} {R : Type u_2} {M : \u03b9 \u2192 Type u_4} {N : Type u_5} [dec_\u03b9 : decidable_eq \u03b9] [_inst_1 : semiring R] [_inst_2 : \u03a0 (i : \u03b9), add_comm_monoid (M i)] [_inst_3 : \u03a0 (i : \u03b9), module R (M i)] [_inst_4 : add_comm_monoid N] [_inst_5 : module R N] \u2983\u03c6 \u03c8 : (\u03a0\u2080 (i : \u03b9), M i) \u2192\u2097[R] N\u2984, (\u2200 (i : \u03b9), \u03c6.comp (dfinsupp.lsingle i) = \u03c8.comp (dfinsupp.lsingle i)) \u2192 \u03c6 = \u03c8", "decl_nm": "dfinsupp.lhom_ext'"}
{"formal_statement": "theorem quot_add (a b : pgame) :\n\t\u27e6a + b\u27e7 = \u27e6a\u27e7 + \u27e6b\u27e7", "decl_tp": "\u2200 (a b : pgame), \u27e6a + b\u27e7 = \u27e6a\u27e7 + \u27e6b\u27e7", "decl_nm": "pgame.quot_add"}
{"formal_statement": "theorem mono {\u03b1 : Type u} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {c c' : set \u03b1} :\n\tc' \u2286 c \u2192 zorn.chain r c \u2192 zorn.chain r c'", "decl_tp": "\u2200 {\u03b1 : Type u} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {c c' : set \u03b1}, c' \u2286 c \u2192 zorn.chain r c \u2192 zorn.chain r c'", "decl_nm": "zorn.chain.mono"}
{"formal_statement": "theorem tendsto_fract_right {\u03b1 : Type*} [linear_ordered_ring \u03b1] [floor_ring \u03b1]\n\t[topological_space \u03b1] [order_closed_topology \u03b1] [topological_add_group \u03b1]\n\t(n : \u2124) :\n\tfilter.tendsto int.fract (nhds_within \u2191n (set.Ici \u2191n)) (nhds_within 0 (set.Ici 0))", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : linear_ordered_ring \u03b1] [_inst_2 : floor_ring \u03b1] [_inst_3 : topological_space \u03b1] [_inst_4 : order_closed_topology \u03b1] [_inst_5 : topological_add_group \u03b1] (n : \u2124), filter.tendsto int.fract (nhds_within \u2191n (set.Ici \u2191n)) (nhds_within 0 (set.Ici 0))", "decl_nm": "tendsto_fract_right"}
{"formal_statement": "theorem coe_prod_comm {R S : Type*} [non_assoc_semiring R] [non_assoc_semiring S] :\n\t\u21d1ring_equiv.prod_comm = prod.swap", "decl_tp": "\u2200 {R : Type u_1} {S : Type u_3} [_inst_1 : non_assoc_semiring R] [_inst_2 : non_assoc_semiring S], \u21d1ring_equiv.prod_comm = prod.swap", "decl_nm": "ring_equiv.coe_prod_comm"}
{"formal_statement": "theorem add_zero_equiv (x : pgame) :\n\t(x + 0).equiv x", "decl_tp": "\u2200 (x : pgame), (x + 0).equiv x", "decl_nm": "pgame.add_zero_equiv"}
{"formal_statement": "theorem indicator_le_self {\u03b1 M : Type*} [canonically_ordered_add_monoid M]\n\t(s : set \u03b1) (f : \u03b1 \u2192 M) :\n\ts.indicator f \u2264 f", "decl_tp": "\u2200 {\u03b1 : Type u_1} {M : Type u_4} [_inst_1 : canonically_ordered_add_monoid M] (s : set \u03b1) (f : \u03b1 \u2192 M), s.indicator f \u2264 f", "decl_nm": "set.indicator_le_self"}
{"formal_statement": "theorem uniformity_symm {\u03b1 \u03b2 : Type*} [uniform_space \u03b1] {l : filter \u03b2}\n\t{f : \u03b2 \u2192 \u03b1 \u00d7 \u03b1} (h : filter.tendsto f l (uniformity \u03b1)) :\n\tfilter.tendsto (\u03bb (x : \u03b2), ((f x).snd, (f x).fst)) l (uniformity \u03b1)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : uniform_space \u03b1] {l : filter \u03b2} {f : \u03b2 \u2192 \u03b1 \u00d7 \u03b1}, filter.tendsto f l (uniformity \u03b1) \u2192 filter.tendsto (\u03bb (x : \u03b2), ((f x).snd, (f x).fst)) l (uniformity \u03b1)", "decl_nm": "filter.tendsto.uniformity_symm"}
{"formal_statement": "theorem map_of_le {X : Type*} [topological_space X] {Y : Type*} [topological_space Y]\n\t{f : Y \u2192 X} {cont : continuous f} {A : discrete_quotient Y} {B : discrete_quotient X}\n\t{C : discrete_quotient Y} (cond : discrete_quotient.le_comap cont A B)\n\t(h : C \u2264 A) :\n\tdiscrete_quotient.map _ = discrete_quotient.map cond \u2218 discrete_quotient.of_le h", "decl_tp": "\u2200 {X : Type u_1} [_inst_1 : topological_space X] {Y : Type u_2} [_inst_2 : topological_space Y] {f : Y \u2192 X} {cont : continuous f} {A : discrete_quotient Y} {B : discrete_quotient X} {C : discrete_quotient Y} (cond : discrete_quotient.le_comap cont A B) (h : C \u2264 A), discrete_quotient.map _ = discrete_quotient.map cond \u2218 discrete_quotient.of_le h", "decl_nm": "discrete_quotient.map_of_le"}
{"formal_statement": "theorem mul_le_left {x y : \u21a5unit_interval} :\n\tx * y \u2264 x", "decl_tp": "\u2200 {x y : \u21a5unit_interval}, x * y \u2264 x", "decl_nm": "unit_interval.mul_le_left"}
{"formal_statement": "theorem prod_comparison_nat_trans_app {C : Type u} [category_theory.category C]\n\t{D : Type u\u2082} [category_theory.category D] [category_theory.limits.has_binary_products C]\n\t[category_theory.limits.has_binary_products D] (F : C \u2964 D) (A B : C) :\n\t(category_theory.limits.prod_comparison_nat_trans F A).app B = category_theory.limits.prod_comparison F A B", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] {D : Type u\u2082} [_inst_2 : category_theory.category D] [_inst_7 : category_theory.limits.has_binary_products C] [_inst_8 : category_theory.limits.has_binary_products D] (F : C \u2964 D) (A B : C), (category_theory.limits.prod_comparison_nat_trans F A).app B = category_theory.limits.prod_comparison F A B", "decl_nm": "category_theory.limits.prod_comparison_nat_trans_app"}
{"formal_statement": "theorem colimits_from_coequalizers_and_coproducts {C : Type u} [category_theory.category C]\n\t[category_theory.limits.has_coproducts C] [category_theory.limits.has_coequalizers C] :\n\tcategory_theory.limits.has_colimits C", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] [_inst_4 : category_theory.limits.has_coproducts C] [_inst_5 : category_theory.limits.has_coequalizers C], category_theory.limits.has_colimits C", "decl_nm": "category_theory.limits.colimits_from_coequalizers_and_coproducts"}
{"formal_statement": "theorem sqrt {\u03b1 : Type*} [topological_space \u03b1] {f : \u03b1 \u2192 \u211d} {s : set \u03b1}\n\t(h : continuous_on f s) :\n\tcontinuous_on (\u03bb (x : \u03b1), real.sqrt (f x)) s", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : topological_space \u03b1] {f : \u03b1 \u2192 \u211d} {s : set \u03b1}, continuous_on f s \u2192 continuous_on (\u03bb (x : \u03b1), real.sqrt (f x)) s", "decl_nm": "continuous_on.sqrt"}
{"formal_statement": "theorem of_add_mul (a b : \u2124) :\n\t\u21d1multiplicative.of_add (a * b) = \u21d1multiplicative.of_add a ^ b", "decl_tp": "\u2200 (a b : \u2124), \u21d1multiplicative.of_add (a * b) = \u21d1multiplicative.of_add a ^ b", "decl_nm": "int.of_add_mul"}
{"formal_statement": "theorem field_range_subtype {K : Type u} [field K] (s : subfield K) :\n\ts.subtype.field_range = s", "decl_tp": "\u2200 {K : Type u} [_inst_1 : field K] (s : subfield K), s.subtype.field_range = s", "decl_nm": "subfield.field_range_subtype"}
{"formal_statement": "theorem add_lt_add_iff_right {\u03b1 : Type*} [has_add \u03b1] [has_lt \u03b1] [covariant_class \u03b1 \u03b1 (function.swap has_add.add) has_lt.lt]\n\t[contravariant_class \u03b1 \u03b1 (function.swap has_add.add) has_lt.lt] (a : \u03b1)\n\t{b c : \u03b1} :\n\tb + a < c + a \u2194 b < c", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : has_add \u03b1] [_inst_2 : has_lt \u03b1] [_inst_3 : covariant_class \u03b1 \u03b1 (function.swap has_add.add) has_lt.lt] [_inst_4 : contravariant_class \u03b1 \u03b1 (function.swap has_add.add) has_lt.lt] (a : \u03b1) {b c : \u03b1}, b + a < c + a \u2194 b < c", "decl_nm": "add_lt_add_iff_right"}
{"formal_statement": "theorem mem_image_of_mem {\u03b1 : Type u} {\u03b2 : Type v} (f : \u03b1 \u2192 \u03b2) {x : \u03b1}\n\t{a : set \u03b1} (h : x \u2208 a) :\n\tf x \u2208 f '' a", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} (f : \u03b1 \u2192 \u03b2) {x : \u03b1} {a : set \u03b1}, x \u2208 a \u2192 f x \u2208 f '' a", "decl_nm": "set.mem_image_of_mem"}
{"formal_statement": "theorem edist_triangle4 {\u03b1 : Type u} [pseudo_emetric_space \u03b1] (x y z t : \u03b1) :\n\thas_edist.edist x t \u2264 has_edist.edist x y + has_edist.edist y z + has_edist.edist z t", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : pseudo_emetric_space \u03b1] (x y z t : \u03b1), has_edist.edist x t \u2264 has_edist.edist x y + has_edist.edist y z + has_edist.edist z t", "decl_nm": "edist_triangle4"}
{"formal_statement": "theorem dvd_dioph {\u03b1 : Type} {f g : (\u03b1 \u2192 \u2115) \u2192 \u2115} (df : dioph.dioph_fn f)\n\t(dg : dioph.dioph_fn g) :\n\tdioph (\u03bb (v : \u03b1 \u2192 \u2115), f v \u2223 g v)", "decl_tp": "\u2200 {\u03b1 : Type} {f g : (\u03b1 \u2192 \u2115) \u2192 \u2115}, dioph.dioph_fn f \u2192 dioph.dioph_fn g \u2192 dioph (\u03bb (v : \u03b1 \u2192 \u2115), f v \u2223 g v)", "decl_nm": "dioph.dvd_dioph"}
{"formal_statement": "theorem diagonal_eq_range {\u03b1 : Type*} :\n\tset.diagonal \u03b1 = set.range (\u03bb (x : \u03b1), (x, x))", "decl_tp": "\u2200 {\u03b1 : Type u_1}, set.diagonal \u03b1 = set.range (\u03bb (x : \u03b1), (x, x))", "decl_nm": "set.diagonal_eq_range"}
{"formal_statement": "theorem smooth_add_right {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c] {H : Type*}\n\t[topological_space H] {E : Type*} [normed_group E] [normed_space \ud835\udd5c E]\n\t{I : model_with_corners \ud835\udd5c E H} {G : Type*} [has_add G] [topological_space G]\n\t[charted_space H G] [has_smooth_add I G] {a : G} :\n\tsmooth I I (\u03bb (b : G), b + a)", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {H : Type u_2} [_inst_2 : topological_space H] {E : Type u_3} [_inst_3 : normed_group E] [_inst_4 : normed_space \ud835\udd5c E] {I : model_with_corners \ud835\udd5c E H} {G : Type u_4} [_inst_5 : has_add G] [_inst_6 : topological_space G] [_inst_7 : charted_space H G] [_inst_8 : has_smooth_add I G] {a : G}, smooth I I (\u03bb (b : G), b + a)", "decl_nm": "smooth_add_right"}
{"formal_statement": "theorem add_right_inj {G : Type u} [add_left_cancel_semigroup G] (a : G)\n\t{b c : G} :\n\ta + b = a + c \u2194 b = c", "decl_tp": "\u2200 {G : Type u} [_inst_1 : add_left_cancel_semigroup G] (a : G) {b c : G}, a + b = a + c \u2194 b = c", "decl_nm": "add_right_inj"}
{"formal_statement": "theorem conj_transpose_circulant {\u03b1 n : Type*} [has_star \u03b1] [add_group n]\n\t(v : n \u2192 \u03b1) :\n\t(matrix.circulant v).conj_transpose = matrix.circulant (has_star.star (\u03bb (i : n), v (-i)))", "decl_tp": "\u2200 {\u03b1 : Type u_1} {n : Type u_4} [_inst_1 : has_star \u03b1] [_inst_2 : add_group n] (v : n \u2192 \u03b1), (matrix.circulant v).conj_transpose = matrix.circulant (has_star.star (\u03bb (i : n), v (-i)))", "decl_nm": "matrix.conj_transpose_circulant"}
{"formal_statement": "theorem real_of_complex {e : \u2102 \u2192 \u2102} {z : \u211d} {n : with_top \u2115} (h : times_cont_diff_at \u2102 n e \u2191z) :\n\ttimes_cont_diff_at \u211d n (\u03bb (x : \u211d), (e \u2191x).re) z", "decl_tp": "\u2200 {e : \u2102 \u2192 \u2102} {z : \u211d} {n : with_top \u2115}, times_cont_diff_at \u2102 n e \u2191z \u2192 times_cont_diff_at \u211d n (\u03bb (x : \u211d), (e \u2191x).re) z", "decl_nm": "times_cont_diff_at.real_of_complex"}
{"formal_statement": "theorem cast_nonneg {\u03b1 : Type*} [ordered_semiring \u03b1] (n : \u2115) :\n\t0 \u2264 \u2191n", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : ordered_semiring \u03b1] (n : \u2115), 0 \u2264 \u2191n", "decl_nm": "nat.cast_nonneg"}
{"formal_statement": "theorem exists_minimal_degree_vertex {V : Type u} (G : simple_graph V)\n\t[fintype V] [decidable_rel G.adj] [nonempty V] :\n\t\u2203 (v : V), G.min_degree = G.degree v", "decl_tp": "\u2200 {V : Type u} (G : simple_graph V) [_inst_1 : fintype V] [_inst_2 : decidable_rel G.adj] [_inst_3 : nonempty V], \u2203 (v : V), G.min_degree = G.degree v", "decl_nm": "simple_graph.exists_minimal_degree_vertex"}
{"formal_statement": "theorem add_right {S : Type*} [add_semigroup S] {a b c : S} (hab : add_commute a b)\n\t(hac : add_commute a c) :\n\tadd_commute a (b + c)", "decl_tp": "\u2200 {S : Type u_1} [_inst_1 : add_semigroup S] {a b c : S}, add_commute a b \u2192 add_commute a c \u2192 add_commute a (b + c)", "decl_nm": "add_commute.add_right"}
{"formal_statement": "theorem continuous_within_at_const {\u03b1 \u03b2 : Type*} [topological_space \u03b1]\n\t[topological_space \u03b2] {b : \u03b2} {s : set \u03b1} {x : \u03b1} :\n\tcontinuous_within_at (\u03bb (_x : \u03b1), b) s x", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : topological_space \u03b1] [_inst_2 : topological_space \u03b2] {b : \u03b2} {s : set \u03b1} {x : \u03b1}, continuous_within_at (\u03bb (_x : \u03b1), b) s x", "decl_nm": "continuous_within_at_const"}
{"formal_statement": "theorem min_is_minimal_of_total {\u03b1 : Type u} {\u03b2 : Type v} {lt : \u03b1 \u2192 \u03b1 \u2192 Prop}\n\t[is_strict_total_order \u03b1 lt] {k : \u03b1} {v : \u03b2} {m : rbmap \u03b1 \u03b2 lt} (h : m.min = option.some (k, v))\n\t(hm : k' \u2208 m) :\n\t\u2200 {k' : \u03b1},  k = k' \u2228 lt k k'", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {lt : \u03b1 \u2192 \u03b1 \u2192 Prop} [_inst_1 : is_strict_total_order \u03b1 lt] {k : \u03b1} {v : \u03b2} {m : rbmap \u03b1 \u03b2 lt}, m.min = option.some (k, v) \u2192 \u2200 {k' : \u03b1}, k' \u2208 m \u2192 k = k' \u2228 lt k k'", "decl_nm": "rbmap.min_is_minimal_of_total"}
{"formal_statement": "theorem coe_add {\u03c3 R : Type*} [comm_semiring R] (\u03c6 \u03c8 : mv_polynomial \u03c3 R) :\n\t\u2191(\u03c6 + \u03c8) = \u2191\u03c6 + \u2191\u03c8", "decl_tp": "\u2200 {\u03c3 : Type u_1} {R : Type u_2} [_inst_1 : comm_semiring R] (\u03c6 \u03c8 : mv_polynomial \u03c3 R), \u2191(\u03c6 + \u03c8) = \u2191\u03c6 + \u2191\u03c8", "decl_nm": "mv_polynomial.coe_add"}
{"formal_statement": "theorem ext'_iff {M : Type*} [has_add M] {c d : add_con M} :\n\tsetoid.r = setoid.r \u2194 c = d", "decl_tp": "\u2200 {M : Type u_1} [_inst_1 : has_add M] {c d : add_con M}, setoid.r = setoid.r \u2194 c = d", "decl_nm": "add_con.ext'_iff"}
{"formal_statement": "theorem mem_map {\u03b1 \u03b2 : Type*} {f : \u03b1 \u2192 \u03b2} {b : \u03b2} {s : multiset \u03b1} :\n\tb \u2208 multiset.map f s \u2194 \u2203 (a : \u03b1), a \u2208 s \u2227 f a = b", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {f : \u03b1 \u2192 \u03b2} {b : \u03b2} {s : multiset \u03b1}, b \u2208 multiset.map f s \u2194 \u2203 (a : \u03b1), a \u2208 s \u2227 f a = b", "decl_nm": "multiset.mem_map"}
{"formal_statement": "theorem compact_iff_totally_bounded_complete {\u03b1 : Type u} [uniform_space \u03b1]\n\t{s : set \u03b1} :\n\tis_compact s \u2194 totally_bounded s \u2227 is_complete s", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : uniform_space \u03b1] {s : set \u03b1}, is_compact s \u2194 totally_bounded s \u2227 is_complete s", "decl_nm": "compact_iff_totally_bounded_complete"}
{"formal_statement": "theorem map_id {X : Type*} [topological_space X] {x y : X} (\u03b3 : path x y) :\n\t\u03b3.map continuous_id = \u03b3", "decl_tp": "\u2200 {X : Type u_1} [_inst_1 : topological_space X] {x y : X} (\u03b3 : path x y), \u03b3.map continuous_id = \u03b3", "decl_nm": "path.map_id"}
{"formal_statement": "theorem id_to_nat_trans {C : Type u\u2081} [category_theory.category C] (T : category_theory.comonad C) :\n\t(\ud835\udfd9 T).to_nat_trans = \ud835\udfd9 \u2191T", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] (T : category_theory.comonad C), (\ud835\udfd9 T).to_nat_trans = \ud835\udfd9 \u2191T", "decl_nm": "category_theory.comonad_hom.id_to_nat_trans"}
{"formal_statement": "theorem nat_coe_nat (f : nat.arithmetic_function \u2115) :\n\t\u2191f = f", "decl_tp": "\u2200 (f : nat.arithmetic_function \u2115), \u2191f = f", "decl_nm": "nat.arithmetic_function.nat_coe_nat"}
{"formal_statement": "theorem to_Magma_iso_inv {X Y : Type u} [has_mul X] [has_mul Y] (e : X \u2243* Y) :\n\te.to_Magma_iso.inv = e.symm.to_mul_hom", "decl_tp": "\u2200 {X Y : Type u} [_inst_1 : has_mul X] [_inst_2 : has_mul Y] (e : X \u2243* Y), e.to_Magma_iso.inv = e.symm.to_mul_hom", "decl_nm": "mul_equiv.to_Magma_iso_inv"}
{"formal_statement": "theorem modify_nth_tail_modify_nth_tail_le {\u03b1 : Type u} {f g : list \u03b1 \u2192 list \u03b1}\n\t(m n : \u2115) (l : list \u03b1) (h : n \u2264 m) :\n\tlist.modify_nth_tail g m (list.modify_nth_tail f n l) = list.modify_nth_tail (\u03bb (l : list \u03b1), list.modify_nth_tail g (m - n)\n\t(f l)) n l", "decl_tp": "\u2200 {\u03b1 : Type u} {f g : list \u03b1 \u2192 list \u03b1} (m n : \u2115) (l : list \u03b1), n \u2264 m \u2192 list.modify_nth_tail g m (list.modify_nth_tail f n l) = list.modify_nth_tail (\u03bb (l : list \u03b1), list.modify_nth_tail g (m - n) (f l)) n l", "decl_nm": "list.modify_nth_tail_modify_nth_tail_le"}
{"formal_statement": "theorem sum_eq_top_iff {\u03b1 : Type*} {s : finset \u03b1} {f : \u03b1 \u2192 ennreal} :\n\ts.sum (\u03bb (x : \u03b1), f x) = \u22a4 \u2194 \u2203 (a : \u03b1) (H : a \u2208 s), f a = \u22a4", "decl_tp": "\u2200 {\u03b1 : Type u_1} {s : finset \u03b1} {f : \u03b1 \u2192 ennreal}, s.sum (\u03bb (x : \u03b1), f x) = \u22a4 \u2194 \u2203 (a : \u03b1) (H : a \u2208 s), f a = \u22a4", "decl_nm": "ennreal.sum_eq_top_iff"}
{"formal_statement": "theorem dist_pair_smul {\u03b1 \u03b2 : Type*} [pseudo_metric_space \u03b1] [pseudo_metric_space \u03b2]\n\t[has_zero \u03b1] [has_zero \u03b2] [has_scalar \u03b1 \u03b2] [has_bounded_smul \u03b1 \u03b2] (x\u2081 x\u2082 : \u03b1)\n\t(y : \u03b2) :\n\thas_dist.dist (x\u2081 \u2022 y) (x\u2082 \u2022 y) \u2264 has_dist.dist x\u2081 x\u2082 * has_dist.dist y 0", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : pseudo_metric_space \u03b1] [_inst_2 : pseudo_metric_space \u03b2] [_inst_3 : has_zero \u03b1] [_inst_4 : has_zero \u03b2] [_inst_5 : has_scalar \u03b1 \u03b2] [_inst_6 : has_bounded_smul \u03b1 \u03b2] (x\u2081 x\u2082 : \u03b1) (y : \u03b2), has_dist.dist (x\u2081 \u2022 y) (x\u2082 \u2022 y) \u2264 has_dist.dist x\u2081 x\u2082 * has_dist.dist y 0", "decl_nm": "dist_pair_smul"}
{"formal_statement": "theorem unop {\u03b1 : Type u} [has_mul \u03b1] {x y : \u03b1\u1d50\u1d52\u1d56} (h : commute x y) :\n\tcommute (mul_opposite.unop x) (mul_opposite.unop y)", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : has_mul \u03b1] {x y : \u03b1\u1d50\u1d52\u1d56}, commute x y \u2192 commute (mul_opposite.unop x) (mul_opposite.unop y)", "decl_nm": "mul_opposite.commute.unop"}
{"formal_statement": "theorem sub_mem {K : Type u} [field K] (s : subfield K) {x y : K} :\n\tx \u2208 s \u2192 y \u2208 s \u2192 x - y \u2208 s", "decl_tp": "\u2200 {K : Type u} [_inst_1 : field K] (s : subfield K) {x y : K}, x \u2208 s \u2192 y \u2208 s \u2192 x - y \u2208 s", "decl_nm": "subfield.sub_mem"}
{"formal_statement": "theorem dense_univ {\u03b1 : Type u} [topological_space \u03b1] :\n\tdense set.univ", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : topological_space \u03b1], dense set.univ", "decl_nm": "dense_univ"}
{"formal_statement": "theorem linear_equiv_refl {\u03b9 R : Type*} [semiring R] {\u03b2\u2081 : \u03b9 \u2192 Type*} [\u03a0 (i : \u03b9), add_comm_monoid (\u03b2\u2081 i)]\n\t[\u03a0 (i : \u03b9), module R (\u03b2\u2081 i)] :\n\tdfinsupp.map_range.linear_equiv (\u03bb (i : \u03b9), linear_equiv.refl R (\u03b2\u2081 i)) = linear_equiv.refl R (\u03a0\u2080 (i : \u03b9), \u03b2\u2081 i)", "decl_tp": "\u2200 {\u03b9 : Type u_1} {R : Type u_2} [_inst_1 : semiring R] {\u03b2\u2081 : \u03b9 \u2192 Type u_7} [_inst_7 : \u03a0 (i : \u03b9), add_comm_monoid (\u03b2\u2081 i)] [_inst_10 : \u03a0 (i : \u03b9), module R (\u03b2\u2081 i)], dfinsupp.map_range.linear_equiv (\u03bb (i : \u03b9), linear_equiv.refl R (\u03b2\u2081 i)) = linear_equiv.refl R (\u03a0\u2080 (i : \u03b9), \u03b2\u2081 i)", "decl_nm": "dfinsupp.map_range.linear_equiv_refl"}
{"formal_statement": "theorem prod_congr_left_apply {\u03b1\u2081 \u03b2\u2081 \u03b2\u2082 : Type*} (e : \u03b1\u2081 \u2192 \u03b2\u2081 \u2243 \u03b2\u2082) (b : \u03b2\u2081)\n\t(a : \u03b1\u2081) :\n\t\u21d1(equiv.prod_congr_left e) (b, a) = (\u21d1(e a) b, a)", "decl_tp": "\u2200 {\u03b1\u2081 : Type u_1} {\u03b2\u2081 : Type u_2} {\u03b2\u2082 : Type u_3} (e : \u03b1\u2081 \u2192 \u03b2\u2081 \u2243 \u03b2\u2082) (b : \u03b2\u2081) (a : \u03b1\u2081), \u21d1(equiv.prod_congr_left e) (b, a) = (\u21d1(e a) b, a)", "decl_nm": "equiv.prod_congr_left_apply"}
{"formal_statement": "theorem eq_top_or_lt_top {\u03b1 : Type u} [partial_order \u03b1] [order_top \u03b1] (a : \u03b1) :\n\ta = \u22a4 \u2228 a < \u22a4", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : partial_order \u03b1] [_inst_2 : order_top \u03b1] (a : \u03b1), a = \u22a4 \u2228 a < \u22a4", "decl_nm": "eq_top_or_lt_top"}
{"formal_statement": "theorem subtype_comp_cod_restrict {R R\u2082 M M\u2082 : Type*2} [semiring R] [semiring R\u2082]\n\t[add_comm_monoid M] [add_comm_monoid M\u2082] [module R M] [module R\u2082 M\u2082] {\u03c3\u2081\u2082 : R \u2192+* R\u2082}\n\t(f : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) (p : submodule R\u2082 M\u2082) (h : \u2200 (b : M), \u21d1f b \u2208 p) :\n\tp.subtype.comp (linear_map.cod_restrict p f h) = f", "decl_tp": "\u2200 {R : Type u_1} {R\u2082 : Type u_3} {M : Type u_9} {M\u2082 : Type u_12} [_inst_1 : semiring R] [_inst_2 : semiring R\u2082] [_inst_5 : add_comm_monoid M] [_inst_7 : add_comm_monoid M\u2082] [_inst_10 : module R M] [_inst_12 : module R\u2082 M\u2082] {\u03c3\u2081\u2082 : R \u2192+* R\u2082} (f : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) (p : submodule R\u2082 M\u2082) (h : \u2200 (b : M), \u21d1f b \u2208 p), p.subtype.comp (linear_map.cod_restrict p f h) = f", "decl_nm": "linear_map.subtype_comp_cod_restrict"}
{"formal_statement": "theorem to_Group_iso_hom {X Y : Type u} [group X] [group Y] (e : X \u2243* Y) :\n\te.to_Group_iso.hom = e.to_monoid_hom", "decl_tp": "\u2200 {X Y : Type u} [_inst_1 : group X] [_inst_2 : group Y] (e : X \u2243* Y), e.to_Group_iso.hom = e.to_monoid_hom", "decl_nm": "mul_equiv.to_Group_iso_hom"}
{"formal_statement": "theorem support_eq_verts {V : Type u} {G : simple_graph V} {M : G.subgraph}\n\t(h : M.is_matching) :\n\tM.support = M.verts", "decl_tp": "\u2200 {V : Type u} {G : simple_graph V} {M : G.subgraph}, M.is_matching \u2192 M.support = M.verts", "decl_nm": "simple_graph.subgraph.is_matching.support_eq_verts"}
{"formal_statement": "theorem inv\u2080_apply (G : Type*) [group_with_zero G] :\n\t\u21d1(equiv.inv\u2080 G) = has_inv.inv", "decl_tp": "\u2200 (G : Type u_1) [_inst_2 : group_with_zero G], \u21d1(equiv.inv\u2080 G) = has_inv.inv", "decl_nm": "equiv.inv\u2080_apply"}
{"formal_statement": "theorem inter_inter {\u03b1 : Type u} {\u03b2 : Type v} {s\u2081 s\u2082 : set \u03b1} {t\u2081 t\u2082 : set \u03b2}\n\t{f : \u03b1 \u2192 \u03b2} (h\u2081 : set.maps_to f s\u2081 t\u2081) (h\u2082 : set.maps_to f s\u2082 t\u2082) :\n\tset.maps_to f (s\u2081 \u2229 s\u2082) (t\u2081 \u2229 t\u2082)", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {s\u2081 s\u2082 : set \u03b1} {t\u2081 t\u2082 : set \u03b2} {f : \u03b1 \u2192 \u03b2}, set.maps_to f s\u2081 t\u2081 \u2192 set.maps_to f s\u2082 t\u2082 \u2192 set.maps_to f (s\u2081 \u2229 s\u2082) (t\u2081 \u2229 t\u2082)", "decl_nm": "set.maps_to.inter_inter"}
{"formal_statement": "theorem disjoint_iff_disjoint_coe {\u03b1 : Type*} {a b : finset \u03b1} [decidable_eq \u03b1] :\n\tdisjoint a b \u2194 disjoint \u2191a \u2191b", "decl_tp": "\u2200 {\u03b1 : Type u_1} {a b : finset \u03b1} [_inst_2 : decidable_eq \u03b1], disjoint a b \u2194 disjoint \u2191a \u2191b", "decl_nm": "finset.disjoint_iff_disjoint_coe"}
{"formal_statement": "theorem is_bounded_under_ge {\u03b1 : Type u} {\u03b2 : Type v} [semilattice_inf \u03b1]\n\t[topological_space \u03b1] [order_topology \u03b1] {f : filter \u03b2} {u : \u03b2 \u2192 \u03b1} {a : \u03b1}\n\t(h : filter.tendsto u f (nhds a)) :\n\tfilter.is_bounded_under ge f u", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : semilattice_inf \u03b1] [_inst_2 : topological_space \u03b1] [_inst_3 : order_topology \u03b1] {f : filter \u03b2} {u : \u03b2 \u2192 \u03b1} {a : \u03b1}, filter.tendsto u f (nhds a) \u2192 filter.is_bounded_under ge f u", "decl_nm": "filter.tendsto.is_bounded_under_ge"}
{"formal_statement": "theorem is_precomplete_iff {R : Type*} [comm_ring R] {I : ideal R} {M : Type*}\n\t[add_comm_group M] [module R M] :\n\tis_precomplete I M \u2194 \u2200 (f : \u2115 \u2192 M), (\u2200 {m n : \u2115}, m \u2264 n \u2192 f m \u2261 f n [SMOD I ^ m \u2022 \u22a4]) \u2192 (\u2203 (L : M), \u2200 (n : \u2115), f n \u2261 L [SMOD I ^ n \u2022 \u22a4])", "decl_tp": "\u2200 {R : Type u_1} [_inst_1 : comm_ring R] {I : ideal R} {M : Type u_2} [_inst_2 : add_comm_group M] [_inst_3 : module R M], is_precomplete I M \u2194 \u2200 (f : \u2115 \u2192 M), (\u2200 {m n : \u2115}, m \u2264 n \u2192 f m \u2261 f n [SMOD I ^ m \u2022 \u22a4]) \u2192 (\u2203 (L : M), \u2200 (n : \u2115), f n \u2261 L [SMOD I ^ n \u2022 \u22a4])", "decl_nm": "is_precomplete_iff"}
{"formal_statement": "theorem restrict_roots_of_unity_symm {R S : Type*} {k : \u2115+} [comm_ring R]\n\t[comm_ring S] (\u03c3 : R \u2243+* S) :\n\t(\u03c3.restrict_roots_of_unity k).symm = \u03c3.symm.restrict_roots_of_unity k", "decl_tp": "\u2200 {R : Type u_5} {S : Type u_6} {k : \u2115+} [_inst_5 : comm_ring R] [_inst_6 : comm_ring S] (\u03c3 : R \u2243+* S), (\u03c3.restrict_roots_of_unity k).symm = \u03c3.symm.restrict_roots_of_unity k", "decl_nm": "ring_equiv.restrict_roots_of_unity_symm"}
{"formal_statement": "theorem cInf_le_cSup {\u03b1 : Type*} [conditionally_complete_lattice \u03b1] {s : set \u03b1}\n\t(hb : bdd_below s) (ha : bdd_above s) (ne : s.nonempty) :\n\thas_Inf.Inf s \u2264 has_Sup.Sup s", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : conditionally_complete_lattice \u03b1] {s : set \u03b1}, bdd_below s \u2192 bdd_above s \u2192 s.nonempty \u2192 has_Inf.Inf s \u2264 has_Sup.Sup s", "decl_nm": "cInf_le_cSup"}
{"formal_statement": "theorem sub_le_self {\u03b1 : Type u} [add_group \u03b1] [has_le \u03b1] [covariant_class \u03b1 \u03b1 has_add.add has_le.le]\n\t[covariant_class \u03b1 \u03b1 (function.swap has_add.add) has_le.le] (a : \u03b1) {b : \u03b1} :\n\t0 \u2264 b \u2192 a - b \u2264 a", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : add_group \u03b1] [_inst_2 : has_le \u03b1] [_inst_3 : covariant_class \u03b1 \u03b1 has_add.add has_le.le] [_inst_4 : covariant_class \u03b1 \u03b1 (function.swap has_add.add) has_le.le] (a : \u03b1) {b : \u03b1}, 0 \u2264 b \u2192 a - b \u2264 a", "decl_nm": "sub_le_self"}
{"formal_statement": "theorem from_skeleton_obj (C : Type u\u2081) [category_theory.category C] (\u1fb0 : quotient (category_theory.is_isomorphic_setoid C)) :\n\t(category_theory.from_skeleton C).obj \u1fb0 = \u1fb0.out", "decl_tp": "\u2200 (C : Type u\u2081) [_inst_1 : category_theory.category C] (\u1fb0 : quotient (category_theory.is_isomorphic_setoid C)), (category_theory.from_skeleton C).obj \u1fb0 = \u1fb0.out", "decl_nm": "category_theory.from_skeleton_obj"}
{"formal_statement": "theorem mem_pointwise_smul_iff_inv_smul_mem\u2080 {\u03b1 A : Type*} [add_group A]\n\t[group_with_zero \u03b1] [distrib_mul_action \u03b1 A] {a : \u03b1} (ha : a \u2260 0) :\n\t\u2200 (S : add_subgroup A) (x : A), x \u2208 a \u2022 S \u2194 a\u207b\u00b9 \u2022 x \u2208 S", "decl_tp": "\u2200 {\u03b1 : Type u_1} {A : Type u_3} [_inst_2 : add_group A] [_inst_3 : group_with_zero \u03b1] [_inst_4 : distrib_mul_action \u03b1 A] {a : \u03b1}, a \u2260 0 \u2192 \u2200 (S : add_subgroup A) (x : A), x \u2208 a \u2022 S \u2194 a\u207b\u00b9 \u2022 x \u2208 S", "decl_nm": "add_subgroup.mem_pointwise_smul_iff_inv_smul_mem\u2080"}
{"formal_statement": "theorem sub_comp {C : Type u} [category_theory.category C] [category_theory.preadditive C]\n\t{P Q R : C} (f f' : P \u27f6 Q) (g : Q \u27f6 R) :\n\t(f - f') \u226b g = f \u226b g - f' \u226b g", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] [_inst_2 : category_theory.preadditive C] {P Q R : C} (f f' : P \u27f6 Q) (g : Q \u27f6 R), (f - f') \u226b g = f \u226b g - f' \u226b g", "decl_nm": "category_theory.preadditive.sub_comp"}
{"formal_statement": "theorem ne_top {R \u0393\u2080 \u0393'\u2080 : Type*} [linear_ordered_add_comm_monoid_with_top \u0393\u2080]\n\t[linear_ordered_add_comm_monoid_with_top \u0393'\u2080] [ring R] {v\u2081 : add_valuation R \u0393\u2080}\n\t{v\u2082 : add_valuation R \u0393'\u2080} (h : v\u2081.is_equiv v\u2082) :\n\t\u2200 {r : R}, \u21d1v\u2081 r \u2260 \u22a4 \u2194 \u21d1v\u2082 r \u2260 \u22a4", "decl_tp": "\u2200 {R : Type u_1} {\u0393\u2080 : Type u_2} {\u0393'\u2080 : Type u_3} [_inst_1 : linear_ordered_add_comm_monoid_with_top \u0393\u2080] [_inst_2 : linear_ordered_add_comm_monoid_with_top \u0393'\u2080] [_inst_3 : ring R] {v\u2081 : add_valuation R \u0393\u2080} {v\u2082 : add_valuation R \u0393'\u2080}, v\u2081.is_equiv v\u2082 \u2192 \u2200 {r : R}, \u21d1v\u2081 r \u2260 \u22a4 \u2194 \u21d1v\u2082 r \u2260 \u22a4", "decl_nm": "add_valuation.is_equiv.ne_top"}
{"formal_statement": "theorem coe_trans_symm {\u03b1 \u03b2 \u03b3 : Type*} (e : local_equiv \u03b1 \u03b2) (e' : local_equiv \u03b2 \u03b3) :\n\t\u21d1((e.trans e').symm) = \u21d1(e.symm) \u2218 \u21d1(e'.symm)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {\u03b3 : Type u_3} (e : local_equiv \u03b1 \u03b2) (e' : local_equiv \u03b2 \u03b3), \u21d1((e.trans e').symm) = \u21d1(e.symm) \u2218 \u21d1(e'.symm)", "decl_nm": "local_equiv.coe_trans_symm"}
{"formal_statement": "theorem map_bdd_below {\u03b1 : Type u} {\u03b2 : Type v} [preorder \u03b1] [preorder \u03b2]\n\t{f : \u03b1 \u2192 \u03b2} {s : set \u03b1} (hf : antitone f) :\n\tbdd_below s \u2192 bdd_above (f '' s)", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : preorder \u03b1] [_inst_2 : preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s : set \u03b1}, antitone f \u2192 bdd_below s \u2192 bdd_above (f '' s)", "decl_nm": "antitone.map_bdd_below"}
{"formal_statement": "theorem apply_coe {\u03b1 \u03b2 : Type*} [preorder \u03b1] [preorder \u03b2] (x : \u03b1) :\n\t\u21d1(order_hom.apply x) = function.eval x \u2218 coe_fn", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : preorder \u03b1] [_inst_2 : preorder \u03b2] (x : \u03b1), \u21d1(order_hom.apply x) = function.eval x \u2218 coe_fn", "decl_nm": "order_hom.apply_coe"}
{"formal_statement": "theorem gcd_mul_left_add_right (m n k : \u2115) :\n\tm.gcd (m * k + n) = m.gcd n", "decl_tp": "\u2200 (m n k : \u2115), m.gcd (m * k + n) = m.gcd n", "decl_nm": "nat.gcd_mul_left_add_right"}
{"formal_statement": "theorem restr_to_local_equiv {\u03b1 \u03b2 : Type*} [topological_space \u03b1] [topological_space \u03b2]\n\t(e : local_homeomorph \u03b1 \u03b2) (s : set \u03b1) :\n\t(e.restr s).to_local_equiv = e.to_local_equiv.restr (interior s)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : topological_space \u03b1] [_inst_2 : topological_space \u03b2] (e : local_homeomorph \u03b1 \u03b2) (s : set \u03b1), (e.restr s).to_local_equiv = e.to_local_equiv.restr (interior s)", "decl_nm": "local_homeomorph.restr_to_local_equiv"}
{"formal_statement": "theorem re_clm_coe :\n\t\u2191complex.re_clm = complex.re_lm", "decl_tp": "\u2191complex.re_clm = complex.re_lm", "decl_nm": "complex.re_clm_coe"}
{"formal_statement": "theorem faithful_of_comp {C : Type u\u2081} [category_theory.category C] {D : Type u\u2082}\n\t[category_theory.category D] {E : Type u\u2083} [category_theory.category E]\n\t{F : C \u2964 D} {G : D \u2964 E} {H : C \u2964 E} [\u210b : category_theory.faithful H] :\n\tF \u22d9 G = H \u2192 category_theory.faithful F", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {D : Type u\u2082} [_inst_2 : category_theory.category D] {E : Type u\u2083} [_inst_3 : category_theory.category E] {F : C \u2964 D} {G : D \u2964 E} {H : C \u2964 E} [\u210b : category_theory.faithful H], F \u22d9 G = H \u2192 category_theory.faithful F", "decl_nm": "eq.faithful_of_comp"}
{"formal_statement": "theorem set_integral_prod {\u03b1 \u03b2 E : Type*} [measurable_space \u03b1] [measurable_space \u03b2]\n\t{\u03bc : measure_theory.measure \u03b1} {\u03bd : measure_theory.measure \u03b2} [normed_group E]\n\t[measurable_space E] [measure_theory.sigma_finite \u03bd] [topological_space.second_countable_topology E]\n\t[normed_space \u211d E] [complete_space E] [borel_space E] [measure_theory.sigma_finite \u03bc]\n\t(f : \u03b1 \u00d7 \u03b2 \u2192 E) {s : set \u03b1} {t : set \u03b2} (hf : measure_theory.integrable_on f (s.prod t)\n\t(\u03bc.prod \u03bd)) :\n\t\u222b (z : \u03b1 \u00d7 \u03b2) in s.prod t, f z \u2202\u03bc.prod \u03bd = \u222b (x : \u03b1) in s, \u222b (y : \u03b2) in t, f (x, y) \u2202\u03bd \u2202\u03bc", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_3} {E : Type u_6} [_inst_1 : measurable_space \u03b1] [_inst_3 : measurable_space \u03b2] {\u03bc : measure_theory.measure \u03b1} {\u03bd : measure_theory.measure \u03b2} [_inst_6 : normed_group E] [_inst_7 : measurable_space E] [_inst_8 : measure_theory.sigma_finite \u03bd] [_inst_9 : topological_space.second_countable_topology E] [_inst_10 : normed_space \u211d E] [_inst_11 : complete_space E] [_inst_12 : borel_space E] [_inst_13 : measure_theory.sigma_finite \u03bc] (f : \u03b1 \u00d7 \u03b2 \u2192 E) {s : set \u03b1} {t : set \u03b2}, measure_theory.integrable_on f (s.prod t) (\u03bc.prod \u03bd) \u2192 \u222b (z : \u03b1 \u00d7 \u03b2) in s.prod t, f z \u2202\u03bc.prod \u03bd = \u222b (x : \u03b1) in s, \u222b (y : \u03b2) in t, f (x, y) \u2202\u03bd \u2202\u03bc", "decl_nm": "measure_theory.set_integral_prod"}
{"formal_statement": "theorem countable_bInter {\u03b9 \u03b1 : Type*} {l : filter \u03b1} [countable_Inter_filter l]\n\t{S : set \u03b9} (hS : S.countable) :\n\t\u2200 {s t : \u03a0 (i : \u03b9), i \u2208 S \u2192 set \u03b1}, (\u2200 (i : \u03b9) (H : i \u2208 S), s i H =\u1da0[l] t i H) \u2192 ((\u22c2 (i : \u03b9)\n\t(H : i \u2208 S), s i H) =\u1da0[l] \u22c2 (i : \u03b9) (H : i \u2208 S), t i H)", "decl_tp": "\u2200 {\u03b9 : Type u_1} {\u03b1 : Type u_2} {l : filter \u03b1} [_inst_1 : countable_Inter_filter l] {S : set \u03b9}, S.countable \u2192 \u2200 {s t : \u03a0 (i : \u03b9), i \u2208 S \u2192 set \u03b1}, (\u2200 (i : \u03b9) (H : i \u2208 S), s i H =\u1da0[l] t i H) \u2192 ((\u22c2 (i : \u03b9) (H : i \u2208 S), s i H) =\u1da0[l] \u22c2 (i : \u03b9) (H : i \u2208 S), t i H)", "decl_nm": "eventually_eq.countable_bInter"}
{"formal_statement": "theorem measurable_set_interval_oc {\u03b1 : Type*} [topological_space \u03b1] [measurable_space \u03b1]\n\t[opens_measurable_space \u03b1] [linear_order \u03b1] [order_closed_topology \u03b1]\n\t{a b : \u03b1} :\n\tmeasurable_set (set.interval_oc a b)", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : topological_space \u03b1] [_inst_2 : measurable_space \u03b1] [_inst_3 : opens_measurable_space \u03b1] [_inst_16 : linear_order \u03b1] [_inst_17 : order_closed_topology \u03b1] {a b : \u03b1}, measurable_set (set.interval_oc a b)", "decl_nm": "measurable_set_interval_oc"}
{"formal_statement": "theorem is_O_comm {\u03b1 F E' : Type*} [has_norm F] [normed_group E'] {g : \u03b1 \u2192 F}\n\t{l : filter \u03b1} {f\u2081 f\u2082 : \u03b1 \u2192 E'} :\n\tasymptotics.is_O (\u03bb (x : \u03b1), f\u2081 x - f\u2082 x) g l \u2194 asymptotics.is_O (\u03bb (x : \u03b1), f\u2082 x - f\u2081 x) g l", "decl_tp": "\u2200 {\u03b1 : Type u_1} {F : Type u_4} {E' : Type u_6} [_inst_2 : has_norm F] [_inst_4 : normed_group E'] {g : \u03b1 \u2192 F} {l : filter \u03b1} {f\u2081 f\u2082 : \u03b1 \u2192 E'}, asymptotics.is_O (\u03bb (x : \u03b1), f\u2081 x - f\u2082 x) g l \u2194 asymptotics.is_O (\u03bb (x : \u03b1), f\u2082 x - f\u2081 x) g l", "decl_nm": "asymptotics.is_O_comm"}
{"formal_statement": "theorem functor_map (C : Type u) [category_theory.category C] [category_theory.locally_small C]\n\t(X Y : C) (f : X \u27f6 Y) :\n\t(category_theory.shrink_homs.functor C).map f = \u21d1(equiv_shrink (X \u27f6 Y)) f", "decl_tp": "\u2200 (C : Type u) [_inst_1 : category_theory.category C] [_inst_2 : category_theory.locally_small C] (X Y : C) (f : X \u27f6 Y), (category_theory.shrink_homs.functor C).map f = \u21d1(equiv_shrink (X \u27f6 Y)) f", "decl_nm": "category_theory.shrink_homs.functor_map"}
{"formal_statement": "theorem pure_prod {\u03b1 : Type u} {\u03b2 : Type v} {a : \u03b1} {f : filter \u03b2} :\n\t(has_pure.pure a).prod f = filter.map (prod.mk a) f", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {a : \u03b1} {f : filter \u03b2}, (has_pure.pure a).prod f = filter.map (prod.mk a) f", "decl_nm": "filter.pure_prod"}
{"formal_statement": "theorem finrank_eq_one {K : Type u} {V : Type v} [field K] [add_comm_group V]\n\t[module K V] (v : V) (n : v \u2260 0) :\n\t(\u2200 (w : V), \u2203 (c : K), c \u2022 v = w) \u2192 finite_dimensional.finrank K V = 1", "decl_tp": "\u2200 {K : Type u} {V : Type v} [_inst_1 : field K] [_inst_2 : add_comm_group V] [_inst_3 : module K V] (v : V), v \u2260 0 \u2192 (\u2200 (w : V), \u2203 (c : K), c \u2022 v = w) \u2192 finite_dimensional.finrank K V = 1", "decl_nm": "finrank_eq_one"}
{"formal_statement": "theorem tendsto_at_bot_of_leading_coeff_nonpos {\ud835\udd5c : Type*} [normed_linear_ordered_field \ud835\udd5c]\n\t(P : polynomial \ud835\udd5c) [order_topology \ud835\udd5c] (hdeg : 1 \u2264 P.degree) (hnps : P.leading_coeff \u2264 0) :\n\tfilter.tendsto (\u03bb (x : \ud835\udd5c), polynomial.eval x P) filter.at_top filter.at_bot", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : normed_linear_ordered_field \ud835\udd5c] (P : polynomial \ud835\udd5c) [_inst_2 : order_topology \ud835\udd5c], 1 \u2264 P.degree \u2192 P.leading_coeff \u2264 0 \u2192 filter.tendsto (\u03bb (x : \ud835\udd5c), polynomial.eval x P) filter.at_top filter.at_bot", "decl_nm": "polynomial.tendsto_at_bot_of_leading_coeff_nonpos"}
{"formal_statement": "theorem eq_neg_self_iff {R : Type*} [ring R] [no_zero_divisors R] [char_zero R]\n\t{a : R} :\n\ta = -a \u2194 a = 0", "decl_tp": "\u2200 {R : Type u_1} [_inst_1 : ring R] [_inst_2 : no_zero_divisors R] [_inst_3 : char_zero R] {a : R}, a = -a \u2194 a = 0", "decl_nm": "eq_neg_self_iff"}
{"formal_statement": "theorem u_surjective {\u03b1 : Type u} {\u03b2 : Type v} {l : \u03b1 \u2192 \u03b2} {u : \u03b2 \u2192 \u03b1}\n\t[partial_order \u03b1] [preorder \u03b2] (gi : galois_coinsertion l u) :\n\tfunction.surjective u", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {l : \u03b1 \u2192 \u03b2} {u : \u03b2 \u2192 \u03b1} [_inst_1 : partial_order \u03b1] [_inst_2 : preorder \u03b2], galois_coinsertion l u \u2192 function.surjective u", "decl_nm": "galois_coinsertion.u_surjective"}
{"formal_statement": "theorem is_unit_mul_self_iff {M : Type*} [monoid M] {a : M} :\n\tis_unit (a * a) \u2194 is_unit a", "decl_tp": "\u2200 {M : Type u_1} [_inst_1 : monoid M] {a : M}, is_unit (a * a) \u2194 is_unit a", "decl_nm": "is_unit_mul_self_iff"}
{"formal_statement": "theorem exists_split_many_inf_eq_filter_of_finite {\u03b9 : Type*} {I : box_integral.box \u03b9}\n\t[fintype \u03b9] (s : set (box_integral.prepartition I)) (hs : s.finite) :\n\t(\u2203 (t : finset (\u03b9 \u00d7 \u211d)), \u2200 (\u03c0 : box_integral.prepartition I), \u03c0 \u2208 s \u2192 \u03c0 \u2293 box_integral.prepartition.split_many I t = (box_integral.prepartition.split_many I t).filter (\u03bb (J : box_integral.box \u03b9), \u2191J \u2286 \u03c0.Union))", "decl_tp": "\u2200 {\u03b9 : Type u_1} {I : box_integral.box \u03b9} [_inst_1 : fintype \u03b9] (s : set (box_integral.prepartition I)), s.finite \u2192 (\u2203 (t : finset (\u03b9 \u00d7 \u211d)), \u2200 (\u03c0 : box_integral.prepartition I), \u03c0 \u2208 s \u2192 \u03c0 \u2293 box_integral.prepartition.split_many I t = (box_integral.prepartition.split_many I t).filter (\u03bb (J : box_integral.box \u03b9), \u2191J \u2286 \u03c0.Union))", "decl_nm": "box_integral.prepartition.exists_split_many_inf_eq_filter_of_finite"}
{"formal_statement": "theorem card_lt_of_injective_not_surjective {\u03b1 \u03b2 : Type*} [fintype \u03b1] [fintype \u03b2]\n\t(f : \u03b1 \u2192 \u03b2) (h : function.injective f) (h' : \u00acfunction.surjective f) :\n\tfintype.card \u03b1 < fintype.card \u03b2", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : fintype \u03b1] [_inst_2 : fintype \u03b2] (f : \u03b1 \u2192 \u03b2), function.injective f \u2192 \u00acfunction.surjective f \u2192 fintype.card \u03b1 < fintype.card \u03b2", "decl_nm": "fintype.card_lt_of_injective_not_surjective"}
{"formal_statement": "theorem is_homogeneous_X {\u03c3 : Type*} (R : Type*) [comm_semiring R] (i : \u03c3) :\n\t(mv_polynomial.X i).is_homogeneous 1", "decl_tp": "\u2200 {\u03c3 : Type u_1} (R : Type u_3) [_inst_1 : comm_semiring R] (i : \u03c3), (mv_polynomial.X i).is_homogeneous 1", "decl_nm": "mv_polynomial.is_homogeneous_X"}
{"formal_statement": "theorem cauchy_seq_of_edist_le_geometric {\u03b1 : Type*} [pseudo_emetric_space \u03b1]\n\t(r C : ennreal) (hr : r < 1) (hC : C \u2260 \u22a4) :\n\t\u2200 {f : \u2115 \u2192 \u03b1}, (\u2200 (n : \u2115), has_edist.edist (f n) (f (n + 1)) \u2264 C * r ^ n) \u2192 cauchy_seq f", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : pseudo_emetric_space \u03b1] (r C : ennreal), r < 1 \u2192 C \u2260 \u22a4 \u2192 \u2200 {f : \u2115 \u2192 \u03b1}, (\u2200 (n : \u2115), has_edist.edist (f n) (f (n + 1)) \u2264 C * r ^ n) \u2192 cauchy_seq f", "decl_nm": "cauchy_seq_of_edist_le_geometric"}
{"formal_statement": "theorem map\u2082_right'_cons_cons {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} (f : option \u03b1 \u2192 \u03b2 \u2192 \u03b3)\n\t(a : \u03b1) (as : list \u03b1) (b : \u03b2) (bs : list \u03b2) :\n\tlist.map\u2082_right' f (a :: as) (b :: bs) = let rec : list \u03b3 \u00d7 list \u03b1 := list.map\u2082_right' f as bs in (f (option.some a) b :: rec.fst, rec.snd)", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} (f : option \u03b1 \u2192 \u03b2 \u2192 \u03b3) (a : \u03b1) (as : list \u03b1) (b : \u03b2) (bs : list \u03b2), list.map\u2082_right' f (a :: as) (b :: bs) = let rec : list \u03b3 \u00d7 list \u03b1 := list.map\u2082_right' f as bs in (f (option.some a) b :: rec.fst, rec.snd)", "decl_nm": "list.map\u2082_right'_cons_cons"}
{"formal_statement": "theorem initial_mono {C : Type u} [category_theory.category C] [category_theory.limits.has_finite_products C]\n\t{I : C} (B : C) (t : category_theory.limits.is_initial I) [category_theory.cartesian_closed C] :\n\tcategory_theory.mono (t.to B)", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] [_inst_2 : category_theory.limits.has_finite_products C] {I : C} (B : C) (t : category_theory.limits.is_initial I) [_inst_4 : category_theory.cartesian_closed C], category_theory.mono (t.to B)", "decl_nm": "category_theory.initial_mono"}
{"formal_statement": "theorem tendsto_at_top_of_monotone_of_subseq {\u03b9 \u03b9' \u03b1 : Type*} [preorder \u03b9]\n\t[preorder \u03b1] {u : \u03b9 \u2192 \u03b1} {\u03c6 : \u03b9' \u2192 \u03b9} (h : monotone u) (H : filter.tendsto (u \u2218 \u03c6) l filter.at_top) :\n\t\u2200 {l : filter \u03b9'} [l.ne_bot],  filter.tendsto u filter.at_top filter.at_top", "decl_tp": "\u2200 {\u03b9 : Type u_1} {\u03b9' : Type u_2} {\u03b1 : Type u_3} [_inst_1 : preorder \u03b9] [_inst_2 : preorder \u03b1] {u : \u03b9 \u2192 \u03b1} {\u03c6 : \u03b9' \u2192 \u03b9}, monotone u \u2192 \u2200 {l : filter \u03b9'} [_inst_3 : l.ne_bot], filter.tendsto (u \u2218 \u03c6) l filter.at_top \u2192 filter.tendsto u filter.at_top filter.at_top", "decl_nm": "filter.tendsto_at_top_of_monotone_of_subseq"}
{"formal_statement": "theorem antitone_on_of_deriv_nonpos {D : set \u211d} (hD : convex \u211d D) (hf : continuous_on f D)\n\t(hf' : differentiable_on \u211d f (interior D)) (x : \u211d) :\n\t\u2200 {f :  \u211d},   (\u2200 (x : \u211d), x \u2208 interior D \u2192 deriv f x \u2264 0) \u2192 antitone_on f D", "decl_tp": "\u2200 {D : set \u211d}, convex \u211d D \u2192 \u2200 {f : \u211d \u2192 \u211d}, continuous_on f D \u2192 differentiable_on \u211d f (interior D) \u2192 (\u2200 (x : \u211d), x \u2208 interior D \u2192 deriv f x \u2264 0) \u2192 antitone_on f D", "decl_nm": "convex.antitone_on_of_deriv_nonpos"}
{"formal_statement": "theorem integral_sin_pow_succ_le (n : \u2115) :\n\t\u222b (x : \u211d) in 0..real.pi, real.sin x ^ (n + 1) \u2264 \u222b (x : \u211d) in 0..real.pi, real.sin x ^ n", "decl_tp": "\u2200 (n : \u2115), \u222b (x : \u211d) in 0..real.pi, real.sin x ^ (n + 1) \u2264 \u222b (x : \u211d) in 0..real.pi, real.sin x ^ n", "decl_nm": "integral_sin_pow_succ_le"}
{"formal_statement": "theorem of_hom_inv_apply {R S : Type*} [non_assoc_semiring R] [non_assoc_semiring S]\n\t(hom : R \u2192+* S) (inv : S \u2192+* R) (hom_inv_id : inv.comp hom = ring_hom.id R)\n\t(inv_hom_id : hom.comp inv = ring_hom.id S) (r : R) :\n\t\u21d1(ring_equiv.of_hom_inv hom inv hom_inv_id inv_hom_id) r = \u21d1hom r", "decl_tp": "\u2200 {R : Type u_1} {S : Type u_2} [_inst_1 : non_assoc_semiring R] [_inst_2 : non_assoc_semiring S] (hom : R \u2192+* S) (inv : S \u2192+* R) (hom_inv_id : inv.comp hom = ring_hom.id R) (inv_hom_id : hom.comp inv = ring_hom.id S) (r : R), \u21d1(ring_equiv.of_hom_inv hom inv hom_inv_id inv_hom_id) r = \u21d1hom r", "decl_nm": "ring_equiv.of_hom_inv_apply"}
{"formal_statement": "theorem point_reflection_symm {\ud835\udd5c V P : Type*} [normed_field \ud835\udd5c] [semi_normed_group V]\n\t[semi_normed_space \ud835\udd5c V] [pseudo_metric_space P] [semi_normed_add_torsor V P]\n\t(x : P) :\n\t(affine_isometry_equiv.point_reflection \ud835\udd5c x).symm = affine_isometry_equiv.point_reflection \ud835\udd5c x", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} {V : Type u_2} {P : Type u_8} [_inst_1 : normed_field \ud835\udd5c] [_inst_2 : semi_normed_group V] [_inst_7 : semi_normed_space \ud835\udd5c V] [_inst_12 : pseudo_metric_space P] [_inst_17 : semi_normed_add_torsor V P] (x : P), (affine_isometry_equiv.point_reflection \ud835\udd5c x).symm = affine_isometry_equiv.point_reflection \ud835\udd5c x", "decl_nm": "affine_isometry_equiv.point_reflection_symm"}
{"formal_statement": "theorem pi_Iic_mem_nhds {\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} [fintype \u03b9] [\u03a0 (i : \u03b9), linear_order (\u03c0 i)]\n\t[\u03a0 (i : \u03b9), topological_space (\u03c0 i)] [\u2200 (i : \u03b9), order_topology (\u03c0 i)]\n\t{a x : \u03a0 (i : \u03b9), \u03c0 i} :\n\t(\u2200 (i : \u03b9), x i < a i) \u2192 set.Iic a \u2208 nhds x", "decl_tp": "\u2200 {\u03b9 : Type u_1} {\u03c0 : \u03b9 \u2192 Type u_2} [_inst_4 : fintype \u03b9] [_inst_5 : \u03a0 (i : \u03b9), linear_order (\u03c0 i)] [_inst_6 : \u03a0 (i : \u03b9), topological_space (\u03c0 i)] [_inst_7 : \u2200 (i : \u03b9), order_topology (\u03c0 i)] {a x : \u03a0 (i : \u03b9), \u03c0 i}, (\u2200 (i : \u03b9), x i < a i) \u2192 set.Iic a \u2208 nhds x", "decl_nm": "pi_Iic_mem_nhds"}
{"formal_statement": "theorem subset_erase_dup {\u03b1 : Type*} [decidable_eq \u03b1] (s : multiset \u03b1) :\n\ts \u2286 s.erase_dup", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : decidable_eq \u03b1] (s : multiset \u03b1), s \u2286 s.erase_dup", "decl_nm": "multiset.subset_erase_dup"}
{"formal_statement": "theorem mul_nonneg_iff {\u03b1 : Type u} [linear_ordered_ring \u03b1] {a b : \u03b1} :\n\t0 \u2264 a * b \u2194 0 \u2264 a \u2227 0 \u2264 b \u2228 a \u2264 0 \u2227 b \u2264 0", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : linear_ordered_ring \u03b1] {a b : \u03b1}, 0 \u2264 a * b \u2194 0 \u2264 a \u2227 0 \u2264 b \u2228 a \u2264 0 \u2227 b \u2264 0", "decl_nm": "mul_nonneg_iff"}
{"formal_statement": "theorem integrable_on_Icc {\u03b2 E : Type*} [measurable_space E] [normed_group E]\n\t[borel_space E] [preorder \u03b2] [topological_space \u03b2] [t2_space \u03b2] [compact_Icc_space \u03b2]\n\t[measurable_space \u03b2] [opens_measurable_space \u03b2] {\u03bc : measure_theory.measure \u03b2}\n\t[measure_theory.is_locally_finite_measure \u03bc] {a b : \u03b2} {f : \u03b2 \u2192 E} (hf : continuous f) :\n\tmeasure_theory.integrable_on f (set.Icc a b) \u03bc", "decl_tp": "\u2200 {\u03b2 : Type u_2} {E : Type u_3} [_inst_2 : measurable_space E] [_inst_3 : normed_group E] [_inst_4 : borel_space E] [_inst_5 : preorder \u03b2] [_inst_6 : topological_space \u03b2] [_inst_7 : t2_space \u03b2] [_inst_8 : compact_Icc_space \u03b2] [_inst_9 : measurable_space \u03b2] [_inst_10 : opens_measurable_space \u03b2] {\u03bc : measure_theory.measure \u03b2} [_inst_11 : measure_theory.is_locally_finite_measure \u03bc] {a b : \u03b2} {f : \u03b2 \u2192 E}, continuous f \u2192 measure_theory.integrable_on f (set.Icc a b) \u03bc", "decl_nm": "continuous.integrable_on_Icc"}
{"formal_statement": "theorem diff_univ {\u03b1 : Type u} (s : set \u03b1) :\n\ts \\ set.univ = \u2205", "decl_tp": "\u2200 {\u03b1 : Type u} (s : set \u03b1), s \\ set.univ = \u2205", "decl_nm": "set.diff_univ"}
{"formal_statement": "theorem coe_finset_basis_of_linear_independent_of_card_eq_finrank {K : Type u}\n\t{V : Type v} [field K] [add_comm_group V] [module K V] {s : finset V}\n\t(hs : s.nonempty) (lin_ind : linear_independent K coe) (card_eq : s.card = finite_dimensional.finrank K V) :\n\t\u21d1(finset_basis_of_linear_independent_of_card_eq_finrank hs lin_ind card_eq) = coe", "decl_tp": "\u2200 {K : Type u} {V : Type v} [_inst_1 : field K] [_inst_2 : add_comm_group V] [_inst_3 : module K V] {s : finset V} (hs : s.nonempty) (lin_ind : linear_independent K coe) (card_eq : s.card = finite_dimensional.finrank K V), \u21d1(finset_basis_of_linear_independent_of_card_eq_finrank hs lin_ind card_eq) = coe", "decl_nm": "coe_finset_basis_of_linear_independent_of_card_eq_finrank"}
{"formal_statement": "theorem has_neg_neg_im_k {R : Type*} [comm_ring R] {c\u2081 c\u2082 : R} (a : quaternion_algebra R c\u2081 c\u2082) :\n\t(-a).im_k = -a.im_k", "decl_tp": "\u2200 {R : Type u_1} [_inst_1 : comm_ring R] {c\u2081 c\u2082 : R} (a : quaternion_algebra R c\u2081 c\u2082), (-a).im_k = -a.im_k", "decl_nm": "quaternion_algebra.has_neg_neg_im_k"}
{"formal_statement": "theorem cantor_function_le {c : \u211d} {f g : \u2115 \u2192 bool} (h1 : 0 \u2264 c) (h2 : c < 1) :\n\t(\u2200 (n : \u2115), \u21a5(f n) \u2192 \u21a5(g n)) \u2192 cardinal.cantor_function c f \u2264 cardinal.cantor_function c g", "decl_tp": "\u2200 {c : \u211d} {f g : \u2115 \u2192 bool}, 0 \u2264 c \u2192 c < 1 \u2192 (\u2200 (n : \u2115), \u21a5(f n) \u2192 \u21a5(g n)) \u2192 cardinal.cantor_function c f \u2264 cardinal.cantor_function c g", "decl_nm": "cardinal.cantor_function_le"}
{"formal_statement": "theorem eq {\u03b1 : Type*} [topological_space \u03b1] [t1_space \u03b1] {x y : \u03b1} (h : x \u2933 y) :\n\tx = y", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : topological_space \u03b1] [_inst_3 : t1_space \u03b1] {x y : \u03b1}, x \u2933 y \u2192 x = y", "decl_nm": "specializes.eq"}
{"formal_statement": "theorem le_div_iff_mul_le {a b c : \u2124} (H : 0 < c) :\n\t(a \u2264 b / c \u2194 a * c \u2264 b)", "decl_tp": "\u2200 {a b c : \u2124}, 0 < c \u2192 (a \u2264 b / c \u2194 a * c \u2264 b)", "decl_nm": "int.le_div_iff_mul_le"}
{"formal_statement": "theorem map_bot {R R\u2082 M M\u2082 : Type*2} [semiring R] [semiring R\u2082] [add_comm_monoid M]\n\t[add_comm_monoid M\u2082] [module R M] [module R\u2082 M\u2082] {\u03c3\u2081\u2082 : R \u2192+* R\u2082} [ring_hom_surjective \u03c3\u2081\u2082]\n\t(f : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) :\n\tsubmodule.map f \u22a5 = \u22a5", "decl_tp": "\u2200 {R : Type u_1} {R\u2082 : Type u_3} {M : Type u_9} {M\u2082 : Type u_12} [_inst_1 : semiring R] [_inst_2 : semiring R\u2082] [_inst_4 : add_comm_monoid M] [_inst_5 : add_comm_monoid M\u2082] [_inst_8 : module R M] [_inst_10 : module R\u2082 M\u2082] {\u03c3\u2081\u2082 : R \u2192+* R\u2082} [_inst_15 : ring_hom_surjective \u03c3\u2081\u2082] (f : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082), submodule.map f \u22a5 = \u22a5", "decl_nm": "submodule.map_bot"}
{"formal_statement": "theorem strict_anti_nat_of_succ_lt {\u03b1 : Type u} [preorder \u03b1] {f : \u2115 \u2192 \u03b1} :\n\t(\u2200 (n : \u2115), f (n + 1) < f n) \u2192 strict_anti f", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : preorder \u03b1] {f : \u2115 \u2192 \u03b1}, (\u2200 (n : \u2115), f (n + 1) < f n) \u2192 strict_anti f", "decl_nm": "strict_anti_nat_of_succ_lt"}
{"formal_statement": "theorem mem_support_on_finset {\u03b1 M : Type*} [has_zero M] {s : finset \u03b1}\n\t{f : \u03b1 \u2192 M} (hf : \u2200 (a : \u03b1), f a \u2260 0 \u2192 a \u2208 s) {a : \u03b1} :\n\ta \u2208 (finsupp.on_finset s f hf).support \u2194 f a \u2260 0", "decl_tp": "\u2200 {\u03b1 : Type u_1} {M : Type u_5} [_inst_1 : has_zero M] {s : finset \u03b1} {f : \u03b1 \u2192 M} (hf : \u2200 (a : \u03b1), f a \u2260 0 \u2192 a \u2208 s) {a : \u03b1}, a \u2208 (finsupp.on_finset s f hf).support \u2194 f a \u2260 0", "decl_nm": "finsupp.mem_support_on_finset"}
{"formal_statement": "theorem card_zero :\n\t0.card = 0", "decl_tp": "0.card = 0", "decl_nm": "ordinal.card_zero"}
{"formal_statement": "theorem upper_semicontinuous_indicator {\u03b1 : Type*} [topological_space \u03b1]\n\t{\u03b2 : Type*} [preorder \u03b2] {s : set \u03b1} {y : \u03b2} [has_zero \u03b2] (hs : is_closed s)\n\t(hy : 0 \u2264 y) :\n\tupper_semicontinuous (s.indicator (\u03bb (x : \u03b1), y))", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : topological_space \u03b1] {\u03b2 : Type u_2} [_inst_2 : preorder \u03b2] {s : set \u03b1} {y : \u03b2} [_inst_3 : has_zero \u03b2], is_closed s \u2192 0 \u2264 y \u2192 upper_semicontinuous (s.indicator (\u03bb (x : \u03b1), y))", "decl_nm": "is_closed.upper_semicontinuous_indicator"}
{"formal_statement": "theorem whisker_\u03c0 {J : Type u\u2081} [category_theory.category J] {K : Type u\u2082}\n\t[category_theory.category K] {C : Type u\u2083} [category_theory.category C]\n\t{F : J \u2964 C} (E : K \u2964 J) (c : category_theory.limits.cone F) :\n\t(category_theory.limits.cone.whisker E c).\u03c0 = category_theory.whisker_left E c.\u03c0", "decl_tp": "\u2200 {J : Type u\u2081} [_inst_1 : category_theory.category J] {K : Type u\u2082} [_inst_2 : category_theory.category K] {C : Type u\u2083} [_inst_3 : category_theory.category C] {F : J \u2964 C} (E : K \u2964 J) (c : category_theory.limits.cone F), (category_theory.limits.cone.whisker E c).\u03c0 = category_theory.whisker_left E c.\u03c0", "decl_nm": "category_theory.limits.cone.whisker_\u03c0"}
{"formal_statement": "theorem cInf_of_not_bdd_below {s : set \u2124} (h : \u00acbdd_below s) :\n\thas_Inf.Inf s = 0", "decl_tp": "\u2200 {s : set \u2124}, \u00acbdd_below s \u2192 has_Inf.Inf s = 0", "decl_nm": "int.cInf_of_not_bdd_below"}
{"formal_statement": "theorem le_self_pow_two (b : \u2124) :\n\tb \u2264 b ^ 2", "decl_tp": "\u2200 (b : \u2124), b \u2264 b ^ 2", "decl_nm": "int.le_self_pow_two"}
{"formal_statement": "theorem tsum_mul_tsum_eq_tsum_sum_antidiagonal_of_summable_norm {\u03b1 : Type*}\n\t[normed_ring \u03b1] [complete_space \u03b1] {f g : \u2115 \u2192 \u03b1} (hf : summable (\u03bb (x : \u2115), \u2225f x\u2225))\n\t(hg : summable (\u03bb (x : \u2115), \u2225g x\u2225)) :\n\t(\u2211' (n : \u2115), f n) * \u2211' (n : \u2115), g n = \u2211' (n : \u2115), (finset.nat.antidiagonal n).sum (\u03bb (kl : \u2115 \u00d7 \u2115), f kl.fst * g kl.snd)", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : normed_ring \u03b1] [_inst_2 : complete_space \u03b1] {f g : \u2115 \u2192 \u03b1}, summable (\u03bb (x : \u2115), \u2225f x\u2225) \u2192 summable (\u03bb (x : \u2115), \u2225g x\u2225) \u2192 (\u2211' (n : \u2115), f n) * \u2211' (n : \u2115), g n = \u2211' (n : \u2115), (finset.nat.antidiagonal n).sum (\u03bb (kl : \u2115 \u00d7 \u2115), f kl.fst * g kl.snd)", "decl_nm": "tsum_mul_tsum_eq_tsum_sum_antidiagonal_of_summable_norm"}
{"formal_statement": "theorem ker_le_comap {R : Type u} {L : Type v} {L' : Type w\u2082} [comm_ring R]\n\t[lie_ring L] [lie_algebra R L] [lie_ring L'] [lie_algebra R L'] (f : L \u2192\u2097\u2045R\u2046 L')\n\t(J : lie_ideal R L') :\n\tf.ker \u2264 lie_ideal.comap f J", "decl_tp": "\u2200 {R : Type u} {L : Type v} {L' : Type w\u2082} [_inst_1 : comm_ring R] [_inst_2 : lie_ring L] [_inst_3 : lie_algebra R L] [_inst_4 : lie_ring L'] [_inst_5 : lie_algebra R L'] (f : L \u2192\u2097\u2045R\u2046 L') (J : lie_ideal R L'), f.ker \u2264 lie_ideal.comap f J", "decl_nm": "lie_hom.ker_le_comap"}
{"formal_statement": "theorem inv_on {\u03b1 \u03b2 : Type*} (e : local_equiv \u03b1 \u03b2) :\n\tset.inv_on \u21d1(e.symm) \u21d1e e.source e.target", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} (e : local_equiv \u03b1 \u03b2), set.inv_on \u21d1(e.symm) \u21d1e e.source e.target", "decl_nm": "local_equiv.inv_on"}
{"formal_statement": "theorem mem_right_coset_iff {\u03b1 : Type*} [group \u03b1] {s : set \u03b1} {x : \u03b1} (a : \u03b1) :\n\tx \u2208 right_coset s a \u2194 x * a\u207b\u00b9 \u2208 s", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : group \u03b1] {s : set \u03b1} {x : \u03b1} (a : \u03b1), x \u2208 right_coset s a \u2194 x * a\u207b\u00b9 \u2208 s", "decl_nm": "mem_right_coset_iff"}
{"formal_statement": "theorem lower_equivalence_unit_iso {C : Type u\u2081} [category_theory.category C]\n\t{D : Type u\u2082} [category_theory.category D] {A : C} {B : D} (e : category_theory.mono_over A \u224c category_theory.mono_over B) :\n\t(category_theory.subobject.lower_equivalence e).unit_iso = category_theory.eq_to_iso _", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {D : Type u\u2082} [_inst_2 : category_theory.category D] {A : C} {B : D} (e : category_theory.mono_over A \u224c category_theory.mono_over B), (category_theory.subobject.lower_equivalence e).unit_iso = category_theory.eq_to_iso _", "decl_nm": "category_theory.subobject.lower_equivalence_unit_iso"}
{"formal_statement": "theorem compl_bUnion {\u03b1 \u03b2 : Type*} (s : set \u03b1) (t : \u03b1 \u2192 set \u03b2) :\n\t(\u22c3 (i : \u03b1) (H : i \u2208 s), t i)\u1d9c = \u22c2 (i : \u03b1) (H : i \u2208 s), (t i)\u1d9c", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} (s : set \u03b1) (t : \u03b1 \u2192 set \u03b2), (\u22c3 (i : \u03b1) (H : i \u2208 s), t i)\u1d9c = \u22c2 (i : \u03b1) (H : i \u2208 s), (t i)\u1d9c", "decl_nm": "set.compl_bUnion"}
{"formal_statement": "theorem exists_eq_mul_left_of_dvd {\u03b1 : Type*} [comm_monoid \u03b1] {a b : \u03b1}\n\t(h : a \u2223 b) :\n\t(\u2203 (c : \u03b1), b = c * a)", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : comm_monoid \u03b1] {a b : \u03b1}, a \u2223 b \u2192 (\u2203 (c : \u03b1), b = c * a)", "decl_nm": "exists_eq_mul_left_of_dvd"}
{"formal_statement": "theorem mem_map_of_mem {R R\u2082 M M\u2082 : Type*2} [semiring R] [semiring R\u2082]\n\t[add_comm_monoid M] [add_comm_monoid M\u2082] [module R M] [module R\u2082 M\u2082] {\u03c3\u2081\u2082 : R \u2192+* R\u2082}\n\t[ring_hom_surjective \u03c3\u2081\u2082] {f : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082} {p : submodule R M} {r : M}\n\t(h : r \u2208 p) :\n\t\u21d1f r \u2208 submodule.map f p", "decl_tp": "\u2200 {R : Type u_1} {R\u2082 : Type u_3} {M : Type u_9} {M\u2082 : Type u_12} [_inst_1 : semiring R] [_inst_2 : semiring R\u2082] [_inst_4 : add_comm_monoid M] [_inst_5 : add_comm_monoid M\u2082] [_inst_8 : module R M] [_inst_10 : module R\u2082 M\u2082] {\u03c3\u2081\u2082 : R \u2192+* R\u2082} [_inst_15 : ring_hom_surjective \u03c3\u2081\u2082] {f : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082} {p : submodule R M} {r : M}, r \u2208 p \u2192 \u21d1f r \u2208 submodule.map f p", "decl_nm": "submodule.mem_map_of_mem"}
{"formal_statement": "theorem mul_iff {M : Type*} [comm_monoid M] {x y : M} :\n\tis_unit (x * y) \u2194 is_unit x \u2227 is_unit y", "decl_tp": "\u2200 {M : Type u_1} [_inst_1 : comm_monoid M] {x y : M}, is_unit (x * y) \u2194 is_unit x \u2227 is_unit y", "decl_nm": "is_unit.mul_iff"}
{"formal_statement": "theorem downward_closed {C : Type u\u2081} [category_theory.category C] {X Y Z : C}\n\t(S : category_theory.sieve X) {f : Y \u27f6 X} (hf : \u21d1S f) :\n\t\u2200 (g : Z \u27f6 Y), \u21d1S (g \u226b f)", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {X Y Z : C} (S : category_theory.sieve X) {f : Y \u27f6 X}, \u21d1S f \u2192 \u2200 (g : Z \u27f6 Y), \u21d1S (g \u226b f)", "decl_nm": "category_theory.sieve.downward_closed"}
{"formal_statement": "theorem inv_rotate_hom\u2081 {C : Type u} [category_theory.category C] [category_theory.preadditive C]\n\t[category_theory.has_shift C \u2124] {T\u2081 T\u2082 : category_theory.triangulated.triangle C}\n\t(f : category_theory.triangulated.triangle_morphism T\u2081 T\u2082) :\n\tf.inv_rotate.hom\u2081 = (category_theory.shift_functor C (-1)).map f.hom\u2083", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] [_inst_2 : category_theory.preadditive C] [_inst_3 : category_theory.has_shift C \u2124] {T\u2081 T\u2082 : category_theory.triangulated.triangle C} (f : category_theory.triangulated.triangle_morphism T\u2081 T\u2082), f.inv_rotate.hom\u2081 = (category_theory.shift_functor C (-1)).map f.hom\u2083", "decl_nm": "category_theory.triangulated.triangle_morphism.inv_rotate_hom\u2081"}
{"formal_statement": "theorem of_real_clm_apply (x : \u211d) :\n\t\u21d1complex.of_real_clm x = \u2191x", "decl_tp": "\u2200 (x : \u211d), \u21d1complex.of_real_clm x = \u2191x", "decl_nm": "complex.of_real_clm_apply"}
{"formal_statement": "theorem card_bot {G : Type*} [group G] {_x : fintype \u21a5\u22a5} :\n\tfintype.card \u21a5\u22a5 = 1", "decl_tp": "\u2200 {G : Type u_1} [_inst_1 : group G] {_x : fintype \u21a5\u22a5}, fintype.card \u21a5\u22a5 = 1", "decl_nm": "subgroup.card_bot"}
{"formal_statement": "theorem top_ne_coe {r : nnreal} :\n\t\u22a4 \u2260 \u2191r", "decl_tp": "\u2200 {r : nnreal}, \u22a4 \u2260 \u2191r", "decl_nm": "ennreal.top_ne_coe"}
{"formal_statement": "theorem split_drop_fun_last_fun {n : \u2115} {\u03b1 : typevec (n + 1)} {\u03b1' : typevec (n + 1)}\n\t(f : \u03b1.arrow \u03b1') :\n\ttypevec.split_fun (typevec.drop_fun f) (typevec.last_fun f) = f", "decl_tp": "\u2200 {n : \u2115} {\u03b1 : typevec (n + 1)} {\u03b1' : typevec (n + 1)} (f : \u03b1.arrow \u03b1'), typevec.split_fun (typevec.drop_fun f) (typevec.last_fun f) = f", "decl_nm": "typevec.split_drop_fun_last_fun"}
{"formal_statement": "theorem lift_hom_of {R : Type u} {S : Type v} [comm_ring R] (f : polynomial R)\n\t[comm_ring S] {a : S} [algebra R S] (hfx : \u21d1(polynomial.aeval a) f = 0)\n\t{x : R} :\n\t\u21d1(adjoin_root.lift_hom f a hfx) (\u21d1(adjoin_root.of f) x) = \u21d1(algebra_map R S) x", "decl_tp": "\u2200 {R : Type u} {S : Type v} [_inst_1 : comm_ring R] (f : polynomial R) [_inst_2 : comm_ring S] {a : S} [_inst_3 : algebra R S] (hfx : \u21d1(polynomial.aeval a) f = 0) {x : R}, \u21d1(adjoin_root.lift_hom f a hfx) (\u21d1(adjoin_root.of f) x) = \u21d1(algebra_map R S) x", "decl_nm": "adjoin_root.lift_hom_of"}
{"formal_statement": "theorem coe_sort_to_finset {\u03b1 : Type u} {s : set \u03b1} (h : s.finite) :\n\t\u21a5(h.to_finset) = \u21a5s", "decl_tp": "\u2200 {\u03b1 : Type u} {s : set \u03b1} (h : s.finite), \u21a5(h.to_finset) = \u21a5s", "decl_nm": "set.finite.coe_sort_to_finset"}
{"formal_statement": "theorem le_div_iff' {\u03b1 : Type*} [linear_ordered_field \u03b1] {a b c : \u03b1} (hc : 0 < c) :\n\t(a \u2264 b / c \u2194 c * a \u2264 b)", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : linear_ordered_field \u03b1] {a b c : \u03b1}, 0 < c \u2192 (a \u2264 b / c \u2194 c * a \u2264 b)", "decl_nm": "le_div_iff'"}
{"formal_statement": "theorem nonempty_equiv_iff_lift_dim_eq {K : Type u} {V : Type v} {V' : Type v'}\n\t[division_ring K] [add_comm_group V] [module K V] [add_comm_group V']\n\t[module K V'] :\n\tnonempty (V \u2243\u2097[K] V') \u2194 (module.rank K V).lift = (module.rank K V').lift", "decl_tp": "\u2200 {K : Type u} {V : Type v} {V' : Type v'} [_inst_1 : division_ring K] [_inst_2 : add_comm_group V] [_inst_3 : module K V] [_inst_6 : add_comm_group V'] [_inst_7 : module K V'], nonempty (V \u2243\u2097[K] V') \u2194 (module.rank K V).lift = (module.rank K V').lift", "decl_nm": "linear_equiv.nonempty_equiv_iff_lift_dim_eq"}
{"formal_statement": "theorem closure_closed_ball {\u03b1 : Type u} [pseudo_metric_space \u03b1] {x : \u03b1}\n\t{\u03b5 : \u211d} :\n\tclosure (metric.closed_ball x \u03b5) = metric.closed_ball x \u03b5", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : pseudo_metric_space \u03b1] {x : \u03b1} {\u03b5 : \u211d}, closure (metric.closed_ball x \u03b5) = metric.closed_ball x \u03b5", "decl_nm": "metric.closure_closed_ball"}
{"formal_statement": "theorem ortho_comm {R\u2081 M\u2081 : Type*} [ring R\u2081] [add_comm_group M\u2081] [module R\u2081 M\u2081]\n\t{B\u2081 : bilin_form R\u2081 M\u2081} (H : B\u2081.is_alt) :\n\t\u2200 {x y : M\u2081}, B\u2081.is_ortho x y \u2194 B\u2081.is_ortho y x", "decl_tp": "\u2200 {R\u2081 : Type u_3} {M\u2081 : Type u_4} [_inst_4 : ring R\u2081] [_inst_5 : add_comm_group M\u2081] [_inst_6 : module R\u2081 M\u2081] {B\u2081 : bilin_form R\u2081 M\u2081}, B\u2081.is_alt \u2192 \u2200 {x y : M\u2081}, B\u2081.is_ortho x y \u2194 B\u2081.is_ortho y x", "decl_nm": "bilin_form.is_alt.ortho_comm"}
{"formal_statement": "theorem base_g\u2082 {C : Type u} [category_theory.category C] {X Y : C} {J : category_theory.grothendieck_topology C}\n\t{f : Y \u27f6 X} {S : J.cover X} (I : (S.pullback f).relation) :\n\tI.base.g\u2082 = I.g\u2082", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] {X Y : C} {J : category_theory.grothendieck_topology C} {f : Y \u27f6 X} {S : J.cover X} (I : (S.pullback f).relation), I.base.g\u2082 = I.g\u2082", "decl_nm": "category_theory.grothendieck_topology.cover.relation.base_g\u2082"}
{"formal_statement": "theorem div_div_div_cancel_right' {G : Type u} [group G] (a b c : G) :\n\ta / c / (b / c) = a / b", "decl_tp": "\u2200 {G : Type u} [_inst_1 : group G] (a b c : G), a / c / (b / c) = a / b", "decl_nm": "div_div_div_cancel_right'"}
{"formal_statement": "theorem mul_inv_of_self {\u03b1 : Type u} [has_mul \u03b1] [has_one \u03b1] (a : \u03b1) [invertible a] :\n\ta * \u215f a = 1", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : has_mul \u03b1] [_inst_2 : has_one \u03b1] (a : \u03b1) [_inst_3 : invertible a], a * \u215f a = 1", "decl_nm": "mul_inv_of_self"}
{"formal_statement": "theorem add_eq_zero_iff_neg_eq {G : Type u} [add_group G] {a b : G} :\n\ta + b = 0 \u2194 -a = b", "decl_tp": "\u2200 {G : Type u} [_inst_1 : add_group G] {a b : G}, a + b = 0 \u2194 -a = b", "decl_nm": "add_eq_zero_iff_neg_eq"}
{"formal_statement": "theorem bodd_div2_eq (n : \u2115) :\n\tn.bodd_div2 = (n.bodd, n.div2)", "decl_tp": "\u2200 (n : \u2115), n.bodd_div2 = (n.bodd, n.div2)", "decl_nm": "nat.bodd_div2_eq"}
{"formal_statement": "theorem comap_of_range_mem {\u03b1 : Type u} {\u03b2 : Type v} {f : filter \u03b2} {m : \u03b1 \u2192 \u03b2}\n\t(hf : f.ne_bot) (hm : set.range m \u2208 f) :\n\t(filter.comap m f).ne_bot", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {f : filter \u03b2} {m : \u03b1 \u2192 \u03b2}, f.ne_bot \u2192 set.range m \u2208 f \u2192 (filter.comap m f).ne_bot", "decl_nm": "filter.ne_bot.comap_of_range_mem"}
{"formal_statement": "theorem up_map_down {C : Type u\u2081} [category_theory.category C] (X Y : C)\n\t(f : X \u27f6 Y) :\n\t(category_theory.as_small.up.map f).down = f", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] (X Y : C) (f : X \u27f6 Y), (category_theory.as_small.up.map f).down = f", "decl_nm": "category_theory.as_small.up_map_down"}
{"formal_statement": "theorem aleph_idx_le {a b : cardinal} :\n\ta.aleph_idx \u2264 b.aleph_idx \u2194 a \u2264 b", "decl_tp": "\u2200 {a b : cardinal}, a.aleph_idx \u2264 b.aleph_idx \u2194 a \u2264 b", "decl_nm": "cardinal.aleph_idx_le"}
{"formal_statement": "theorem lift_add_hom_comp_single {\u03b1 M N : Type*} [add_comm_monoid M] [add_comm_monoid N]\n\t(f : \u03b1 \u2192 M \u2192+ N) (a : \u03b1) :\n\t(\u21d1finsupp.lift_add_hom f).comp (finsupp.single_add_hom a) = f a", "decl_tp": "\u2200 {\u03b1 : Type u_1} {M : Type u_5} {N : Type u_7} [_inst_1 : add_comm_monoid M] [_inst_2 : add_comm_monoid N] (f : \u03b1 \u2192 M \u2192+ N) (a : \u03b1), (\u21d1finsupp.lift_add_hom f).comp (finsupp.single_add_hom a) = f a", "decl_nm": "finsupp.lift_add_hom_comp_single"}
{"formal_statement": "theorem of_has_finite_coproducts {C : Type u} [category_theory.category C]\n\t[category_theory.preadditive C] [category_theory.limits.has_finite_coproducts C] :\n\tcategory_theory.limits.has_finite_biproducts C", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] [_inst_2 : category_theory.preadditive C] [_inst_5 : category_theory.limits.has_finite_coproducts C], category_theory.limits.has_finite_biproducts C", "decl_nm": "category_theory.limits.has_finite_biproducts.of_has_finite_coproducts"}
{"formal_statement": "theorem to_affine_isometry_equiv_linear_isometry_equiv {\ud835\udd5c V V\u2082 : Type*}\n\t[normed_field \ud835\udd5c] [semi_normed_group V] [semi_normed_group V\u2082] [semi_normed_space \ud835\udd5c V]\n\t[semi_normed_space \ud835\udd5c V\u2082] (e : V \u2243\u2097\u1d62[\ud835\udd5c] V\u2082) :\n\te.to_affine_isometry_equiv.linear_isometry_equiv = e", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} {V : Type u_2} {V\u2082 : Type u_4} [_inst_1 : normed_field \ud835\udd5c] [_inst_2 : semi_normed_group V] [_inst_4 : semi_normed_group V\u2082] [_inst_7 : semi_normed_space \ud835\udd5c V] [_inst_9 : semi_normed_space \ud835\udd5c V\u2082] (e : V \u2243\u2097\u1d62[\ud835\udd5c] V\u2082), e.to_affine_isometry_equiv.linear_isometry_equiv = e", "decl_nm": "linear_isometry_equiv.to_affine_isometry_equiv_linear_isometry_equiv"}
{"formal_statement": "theorem is_sheaf_of_yoneda {C : Type u\u2081} [category_theory.category C] (J : category_theory.grothendieck_topology C)\n\t{P : C\u1d52\u1d56 \u2964 Type v\u2081} (hS : S \u2208 \u21d1J X) :\n\t(\u2200 {X : C} (S : category_theory.sieve X),  category_theory.presieve.yoneda_sheaf_condition P S) \u2192 category_theory.presieve.is_sheaf J P", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] (J : category_theory.grothendieck_topology C) {P : C\u1d52\u1d56 \u2964 Type v\u2081}, (\u2200 {X : C} (S : category_theory.sieve X), S \u2208 \u21d1J X \u2192 category_theory.presieve.yoneda_sheaf_condition P S) \u2192 category_theory.presieve.is_sheaf J P", "decl_nm": "category_theory.presieve.is_sheaf_of_yoneda"}
{"formal_statement": "theorem rpow_eq_nhds_of_pos {p : \u211d \u00d7 \u211d} (hp_fst : 0 < p.fst) :\n\t((\u03bb (x : \u211d \u00d7 \u211d), x.fst ^ x.snd) =\u1da0[nhds p] \u03bb (x : \u211d \u00d7 \u211d), real.exp (real.log x.fst * x.snd))", "decl_tp": "\u2200 {p : \u211d \u00d7 \u211d}, 0 < p.fst \u2192 ((\u03bb (x : \u211d \u00d7 \u211d), x.fst ^ x.snd) =\u1da0[nhds p] \u03bb (x : \u211d \u00d7 \u211d), real.exp (real.log x.fst * x.snd))", "decl_nm": "real.rpow_eq_nhds_of_pos"}
{"formal_statement": "theorem indicator_nonpos_le_indicator {\u03b1 \u03b2 : Type*} [linear_order \u03b2] [has_zero \u03b2]\n\t(s : set \u03b1) (f : \u03b1 \u2192 \u03b2) :\n\t{x : \u03b1 | f x \u2264 0}.indicator f \u2264 s.indicator f", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : linear_order \u03b2] [_inst_2 : has_zero \u03b2] (s : set \u03b1) (f : \u03b1 \u2192 \u03b2), {x : \u03b1 | f x \u2264 0}.indicator f \u2264 s.indicator f", "decl_nm": "set.indicator_nonpos_le_indicator"}
{"formal_statement": "theorem restrict_scalars_inj (S : Type u') (R : Type u) (M : Type v) [semiring R]\n\t[add_comm_monoid M] [semiring S] [module S M] [module R M] [has_scalar S R]\n\t[is_scalar_tower S R M] {V\u2081 V\u2082 : submodule R M} :\n\tsubmodule.restrict_scalars S V\u2081 = submodule.restrict_scalars S V\u2082 \u2194 V\u2081 = V\u2082", "decl_tp": "\u2200 (S : Type u') (R : Type u) (M : Type v) [_inst_1 : semiring R] [_inst_2 : add_comm_monoid M] [_inst_3 : semiring S] [_inst_4 : module S M] [_inst_5 : module R M] [_inst_6 : has_scalar S R] [_inst_7 : is_scalar_tower S R M] {V\u2081 V\u2082 : submodule R M}, submodule.restrict_scalars S V\u2081 = submodule.restrict_scalars S V\u2082 \u2194 V\u2081 = V\u2082", "decl_nm": "submodule.restrict_scalars_inj"}
{"formal_statement": "theorem nonarchimedean {p : \u2115} [hp : fact (nat.prime p)] (q r : \u211a_[p]) :\n\t\u2225q + r\u2225 \u2264 linear_order.max \u2225q\u2225 \u2225r\u2225", "decl_tp": "\u2200 {p : \u2115} [hp : fact (nat.prime p)] (q r : \u211a_[p]), \u2225q + r\u2225 \u2264 linear_order.max \u2225q\u2225 \u2225r\u2225", "decl_nm": "padic_norm_e.nonarchimedean"}
{"formal_statement": "theorem cos_nat_mul_two_pi_sub_pi (n : \u2115) :\n\treal.cos (\u2191n * (2 * real.pi) - real.pi) = -1", "decl_tp": "\u2200 (n : \u2115), real.cos (\u2191n * (2 * real.pi) - real.pi) = -1", "decl_nm": "real.cos_nat_mul_two_pi_sub_pi"}
{"formal_statement": "theorem subsingleton_of_empty_left {m n : Type*} [fintype m] [fintype n]\n\t{\u03b1 : m \u2192 n \u2192 Type v} [is_empty m] :\n\tsubsingleton (dmatrix m n \u03b1)", "decl_tp": "\u2200 {m : Type u_2} {n : Type u_3} [_inst_2 : fintype m] [_inst_3 : fintype n] {\u03b1 : m \u2192 n \u2192 Type v} [_inst_5 : is_empty m], subsingleton (dmatrix m n \u03b1)", "decl_nm": "dmatrix.subsingleton_of_empty_left"}
{"formal_statement": "theorem preimage_mul_const_Iic {k : Type u} [linear_ordered_field k] (a : k)\n\t{c : k} (h : 0 < c) :\n\t(\u03bb (x : k), x * c) \u207b\u00b9' set.Iic a = set.Iic (a / c)", "decl_tp": "\u2200 {k : Type u} [_inst_1 : linear_ordered_field k] (a : k) {c : k}, 0 < c \u2192 (\u03bb (x : k), x * c) \u207b\u00b9' set.Iic a = set.Iic (a / c)", "decl_nm": "set.preimage_mul_const_Iic"}
{"formal_statement": "theorem to_nat_eq_max (a : \u2124) :\n\t\u2191(a.to_nat) = linear_order.max a 0", "decl_tp": "\u2200 (a : \u2124), \u2191(a.to_nat) = linear_order.max a 0", "decl_nm": "int.to_nat_eq_max"}
{"formal_statement": "theorem map_pair_left {C : Type u} [category_theory.category C] {F G : category_theory.discrete category_theory.limits.walking_pair \u2964 C}\n\t(f : F.obj category_theory.limits.walking_pair.left \u27f6 G.obj category_theory.limits.walking_pair.left)\n\t(g : F.obj category_theory.limits.walking_pair.right \u27f6 G.obj category_theory.limits.walking_pair.right) :\n\t(category_theory.limits.map_pair f g).app category_theory.limits.walking_pair.left = f", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] {F G : category_theory.discrete category_theory.limits.walking_pair \u2964 C} (f : F.obj category_theory.limits.walking_pair.left \u27f6 G.obj category_theory.limits.walking_pair.left) (g : F.obj category_theory.limits.walking_pair.right \u27f6 G.obj category_theory.limits.walking_pair.right), (category_theory.limits.map_pair f g).app category_theory.limits.walking_pair.left = f", "decl_nm": "category_theory.limits.map_pair_left"}
{"formal_statement": "theorem empty_or_nonempty_of_Hausdorff_edist_ne_top {\u03b1 : Type u} [pseudo_emetric_space \u03b1]\n\t{s t : set \u03b1} (fin : emetric.Hausdorff_edist s t \u2260 \u22a4) :\n\ts = \u2205 \u2227 t = \u2205 \u2228 s.nonempty \u2227 t.nonempty", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : pseudo_emetric_space \u03b1] {s t : set \u03b1}, emetric.Hausdorff_edist s t \u2260 \u22a4 \u2192 s = \u2205 \u2227 t = \u2205 \u2228 s.nonempty \u2227 t.nonempty", "decl_nm": "emetric.empty_or_nonempty_of_Hausdorff_edist_ne_top"}
{"formal_statement": "theorem sum_subtype_of_mem {\u03b2 : Type u} {\u03b1 : Type v} {s : finset \u03b1} [add_comm_monoid \u03b2]\n\t(f : \u03b1 \u2192 \u03b2) {p : \u03b1 \u2192 Prop} [decidable_pred p] :\n\t(\u2200 (x : \u03b1), x \u2208 s \u2192 p x) \u2192 (finset.subtype p s).sum (\u03bb (x : subtype p), f \u2191x) = s.sum (\u03bb (x : \u03b1), f x)", "decl_tp": "\u2200 {\u03b2 : Type u} {\u03b1 : Type v} {s : finset \u03b1} [_inst_1 : add_comm_monoid \u03b2] (f : \u03b1 \u2192 \u03b2) {p : \u03b1 \u2192 Prop} [_inst_2 : decidable_pred p], (\u2200 (x : \u03b1), x \u2208 s \u2192 p x) \u2192 (finset.subtype p s).sum (\u03bb (x : subtype p), f \u2191x) = s.sum (\u03bb (x : \u03b1), f x)", "decl_nm": "finset.sum_subtype_of_mem"}
{"formal_statement": "theorem subset_Union {\u03b9 X : Type*} [topological_space X] [normal_space X]\n\t{u : \u03b9 \u2192 set X} {s : set X} (v : shrinking_lemma.partial_refinement u s) :\n\ts \u2286 \u22c3 (i : \u03b9), \u21d1v i", "decl_tp": "\u2200 {\u03b9 : Type u_1} {X : Type u_2} [_inst_1 : topological_space X] [_inst_2 : normal_space X] {u : \u03b9 \u2192 set X} {s : set X} (v : shrinking_lemma.partial_refinement u s), s \u2286 \u22c3 (i : \u03b9), \u21d1v i", "decl_nm": "shrinking_lemma.partial_refinement.subset_Union"}
{"formal_statement": "theorem inner_self_eq_zero {\ud835\udd5c F : Type*} [is_R_or_C \ud835\udd5c] [add_comm_group F]\n\t[module \ud835\udd5c F] [c : inner_product_space.core \ud835\udd5c F] {x : F} :\n\thas_inner.inner x x = 0 \u2194 x = 0", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} {F : Type u_3} [_inst_1 : is_R_or_C \ud835\udd5c] [_inst_2 : add_comm_group F] [_inst_3 : module \ud835\udd5c F] [c : inner_product_space.core \ud835\udd5c F] {x : F}, has_inner.inner x x = 0 \u2194 x = 0", "decl_nm": "inner_product_space.of_core.inner_self_eq_zero"}
{"formal_statement": "theorem insert_def {\u03b1 : Type*} [decidable_eq \u03b1] (a : \u03b1) (s : finset \u03b1) :\n\thas_insert.insert a s = {val := multiset.ndinsert a s.val, nodup := _}", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : decidable_eq \u03b1] (a : \u03b1) (s : finset \u03b1), has_insert.insert a s = {val := multiset.ndinsert a s.val, nodup := _}", "decl_nm": "finset.insert_def"}
{"formal_statement": "theorem abs {\u03b1 : Type u} {\u03b2 : Type v} [topological_space \u03b1] [linear_ordered_add_comm_group \u03b1]\n\t[order_topology \u03b1] {f : \u03b2 \u2192 \u03b1} [topological_space \u03b2] {b : \u03b2} {s : set \u03b2}\n\t(h : continuous_within_at f s b) :\n\tcontinuous_within_at (\u03bb (x : \u03b2), |f x|) s b", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : topological_space \u03b1] [_inst_2 : linear_ordered_add_comm_group \u03b1] [_inst_3 : order_topology \u03b1] {f : \u03b2 \u2192 \u03b1} [_inst_4 : topological_space \u03b2] {b : \u03b2} {s : set \u03b2}, continuous_within_at f s b \u2192 continuous_within_at (\u03bb (x : \u03b2), |f x|) s b", "decl_nm": "continuous_within_at.abs"}
{"formal_statement": "theorem with_density\u1d65_add' {\u03b1 : Type*} {m : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1}\n\t{E : Type*} [normed_group E] [measurable_space E] [topological_space.second_countable_topology E]\n\t[normed_space \u211d E] [complete_space E] [borel_space E] {f g : \u03b1 \u2192 E} (hf : measure_theory.integrable f \u03bc)\n\t(hg : measure_theory.integrable g \u03bc) :\n\t\u03bc.with_density\u1d65 (\u03bb (x : \u03b1), f x + g x) = \u03bc.with_density\u1d65 f + \u03bc.with_density\u1d65 g", "decl_tp": "\u2200 {\u03b1 : Type u_1} {m : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} {E : Type u_3} [_inst_1 : normed_group E] [_inst_2 : measurable_space E] [_inst_3 : topological_space.second_countable_topology E] [_inst_4 : normed_space \u211d E] [_inst_5 : complete_space E] [_inst_6 : borel_space E] {f g : \u03b1 \u2192 E}, measure_theory.integrable f \u03bc \u2192 measure_theory.integrable g \u03bc \u2192 \u03bc.with_density\u1d65 (\u03bb (x : \u03b1), f x + g x) = \u03bc.with_density\u1d65 f + \u03bc.with_density\u1d65 g", "decl_nm": "measure_theory.with_density\u1d65_add'"}
{"formal_statement": "theorem mul_nonneg_iff_right_nonneg_of_pos {\u03b1 : Type u} [linear_ordered_semiring \u03b1]\n\t{a b : \u03b1} (ha : 0 < a) :\n\t(0 \u2264 a * b \u2194 0 \u2264 b)", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : linear_ordered_semiring \u03b1] {a b : \u03b1}, 0 < a \u2192 (0 \u2264 a * b \u2194 0 \u2264 b)", "decl_nm": "mul_nonneg_iff_right_nonneg_of_pos"}
{"formal_statement": "theorem pair_comm {\u03b1 : Type u} (a b : \u03b1) :\n\t{a, b} = {b, a}", "decl_tp": "\u2200 {\u03b1 : Type u} (a b : \u03b1), {a, b} = {b, a}", "decl_nm": "set.pair_comm"}
{"formal_statement": "theorem coe_lt_coe_iff {x y : \u211d} :\n\t\u2191x < \u2191y \u2194 x < y", "decl_tp": "\u2200 {x y : \u211d}, \u2191x < \u2191y \u2194 x < y", "decl_nm": "ereal.coe_lt_coe_iff"}
{"formal_statement": "theorem eq_to_iso_refl {C : Type u\u2081} [category_theory.category C] {X : C}\n\t(p : X = X) :\n\tcategory_theory.eq_to_iso p = category_theory.iso.refl X", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {X : C} (p : X = X), category_theory.eq_to_iso p = category_theory.iso.refl X", "decl_nm": "category_theory.eq_to_iso_refl"}
{"formal_statement": "theorem image_mul_prod {\u03b1 : Type*} {s t : set \u03b1} [has_mul \u03b1] :\n\t(\u03bb (x : \u03b1 \u00d7 \u03b1), x.fst * x.snd) '' s.prod t = s * t", "decl_tp": "\u2200 {\u03b1 : Type u_1} {s t : set \u03b1} [_inst_1 : has_mul \u03b1], (\u03bb (x : \u03b1 \u00d7 \u03b1), x.fst * x.snd) '' s.prod t = s * t", "decl_nm": "set.image_mul_prod"}
{"formal_statement": "theorem is_scalar_tower {M N \u03b1 \u03b2 : Type*} [has_scalar M \u03b1] [has_scalar M \u03b2]\n\t[has_scalar \u03b1 \u03b2] [is_scalar_tower M \u03b1 \u03b2] (g : N \u2192 M) :\n\tis_scalar_tower N \u03b1 \u03b2", "decl_tp": "\u2200 {M : Type u_1} {N : Type u_2} {\u03b1 : Type u_6} {\u03b2 : Type u_7} [_inst_1 : has_scalar M \u03b1] [_inst_2 : has_scalar M \u03b2] [_inst_3 : has_scalar \u03b1 \u03b2] [_inst_4 : is_scalar_tower M \u03b1 \u03b2] (g : N \u2192 M), is_scalar_tower N \u03b1 \u03b2", "decl_nm": "has_scalar.comp.is_scalar_tower"}
{"formal_statement": "theorem at_bot_mul_at_bot {\u03b1 \u03b2 : Type*} [ordered_ring \u03b1] {l : filter \u03b2}\n\t{f g : \u03b2 \u2192 \u03b1} (hf : filter.tendsto f l filter.at_bot) (hg : filter.tendsto g l filter.at_bot) :\n\tfilter.tendsto (\u03bb (x : \u03b2), f x * g x) l filter.at_top", "decl_tp": "\u2200 {\u03b1 : Type u_3} {\u03b2 : Type u_4} [_inst_1 : ordered_ring \u03b1] {l : filter \u03b2} {f g : \u03b2 \u2192 \u03b1}, filter.tendsto f l filter.at_bot \u2192 filter.tendsto g l filter.at_bot \u2192 filter.tendsto (\u03bb (x : \u03b2), f x * g x) l filter.at_top", "decl_nm": "filter.tendsto.at_bot_mul_at_bot"}
{"formal_statement": "theorem div_zero (n : znum) :\n\tn / 0 = 0", "decl_tp": "\u2200 (n : znum), n / 0 = 0", "decl_nm": "znum.div_zero"}
{"formal_statement": "theorem coe_smul {X Y : Type*} [topological_space X] {R : Type*} [has_scalar R Y]\n\t(r : R) (f : locally_constant X Y) :\n\t\u21d1(r \u2022 f) = r \u2022 \u21d1f", "decl_tp": "\u2200 {X : Type u_1} {Y : Type u_2} [_inst_1 : topological_space X] {R : Type u_3} [_inst_2 : has_scalar R Y] (r : R) (f : locally_constant X Y), \u21d1(r \u2022 f) = r \u2022 \u21d1f", "decl_nm": "locally_constant.coe_smul"}
{"formal_statement": "theorem inter_compl_self {\u03b1 : Type u} (s : set \u03b1) :\n\ts \u2229 s\u1d9c = \u2205", "decl_tp": "\u2200 {\u03b1 : Type u} (s : set \u03b1), s \u2229 s\u1d9c = \u2205", "decl_nm": "set.inter_compl_self"}
{"formal_statement": "theorem prod_finset_coe {\u03b2 : Type u} {\u03b1 : Type v} [comm_monoid \u03b2] (f : \u03b1 \u2192 \u03b2)\n\t(s : finset \u03b1) :\n\tfinset.univ.prod (\u03bb (i : \u21a5\u2191s), f \u2191i) = s.prod (\u03bb (i : \u03b1), f i)", "decl_tp": "\u2200 {\u03b2 : Type u} {\u03b1 : Type v} [_inst_1 : comm_monoid \u03b2] (f : \u03b1 \u2192 \u03b2) (s : finset \u03b1), finset.univ.prod (\u03bb (i : \u21a5\u2191s), f \u2191i) = s.prod (\u03bb (i : \u03b1), f i)", "decl_nm": "finset.prod_finset_coe"}
{"formal_statement": "theorem closure_induction {K : Type u} [field K] {s : set K} {p : K \u2192 Prop}\n\t{x : K} (h : x \u2208 subfield.closure s) (H1 : p 1) :\n\t(\u2200 (x : K), x \u2208 s \u2192 p x) \u2192  (\u2200 (x y : K), p x \u2192 p y \u2192 p (x + y)) \u2192 (\u2200 (x : K), p x \u2192 p (-x)) \u2192 (\u2200 (x : K), p x \u2192 p x\u207b\u00b9) \u2192 (\u2200 (x y : K), p x \u2192 p y \u2192 p (x * y)) \u2192 p x", "decl_tp": "\u2200 {K : Type u} [_inst_1 : field K] {s : set K} {p : K \u2192 Prop} {x : K}, x \u2208 subfield.closure s \u2192 (\u2200 (x : K), x \u2208 s \u2192 p x) \u2192 p 1 \u2192 (\u2200 (x y : K), p x \u2192 p y \u2192 p (x + y)) \u2192 (\u2200 (x : K), p x \u2192 p (-x)) \u2192 (\u2200 (x : K), p x \u2192 p x\u207b\u00b9) \u2192 (\u2200 (x y : K), p x \u2192 p y \u2192 p (x * y)) \u2192 p x", "decl_nm": "subfield.closure_induction"}
{"formal_statement": "theorem inf'_eq_inf {\u03b1 \u03b2 : Type*} [semilattice_inf \u03b1] [order_top \u03b1] {s : finset \u03b2}\n\t(H : s.nonempty) (f : \u03b2 \u2192 \u03b1) :\n\ts.inf' H f = s.inf f", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : semilattice_inf \u03b1] [_inst_2 : order_top \u03b1] {s : finset \u03b2} (H : s.nonempty) (f : \u03b2 \u2192 \u03b1), s.inf' H f = s.inf f", "decl_nm": "finset.inf'_eq_inf"}
{"formal_statement": "theorem drop {\u03b1 : Type*} {R : \u03b1 \u2192 \u03b1 \u2192 Prop} {l : list \u03b1} {n : \u2115} (\u1fb0 : list.pairwise R l) :\n\tlist.pairwise R (list.drop n l)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {R : \u03b1 \u2192 \u03b1 \u2192 Prop} {l : list \u03b1} {n : \u2115}, list.pairwise R l \u2192 list.pairwise R (list.drop n l)", "decl_nm": "list.pairwise.drop"}
{"formal_statement": "theorem mul_indicator_of_mem {\u03b1 M : Type*} [has_one M] {s : set \u03b1} {a : \u03b1}\n\t(a : \u03b1) (h : a \u2208 s) :\n\t\u2200 (f :  M), s.mul_indicator f a = f a", "decl_tp": "\u2200 {\u03b1 : Type u_1} {M : Type u_4} [_inst_1 : has_one M] {s : set \u03b1} {a : \u03b1}, a \u2208 s \u2192 \u2200 (f : \u03b1 \u2192 M), s.mul_indicator f a = f a", "decl_nm": "set.mul_indicator_of_mem"}
{"formal_statement": "theorem nnnorm_tsum_le {\u03b9 E : Type*} [semi_normed_group E] {f : \u03b9 \u2192 E}\n\t(hf : summable (\u03bb (i : \u03b9), \u2225f i\u2225\u208a)) :\n\t\u2225\u2211' (i : \u03b9), f i\u2225\u208a \u2264 \u2211' (i : \u03b9), \u2225f i\u2225\u208a", "decl_tp": "\u2200 {\u03b9 : Type u_1} {E : Type u_3} [_inst_1 : semi_normed_group E] {f : \u03b9 \u2192 E}, summable (\u03bb (i : \u03b9), \u2225f i\u2225\u208a) \u2192 \u2225\u2211' (i : \u03b9), f i\u2225\u208a \u2264 \u2211' (i : \u03b9), \u2225f i\u2225\u208a", "decl_nm": "nnnorm_tsum_le"}
{"formal_statement": "theorem induction_on_union {\u03b1 : Type*} [decidable_eq \u03b1] (P : finset \u03b1 \u2192 finset \u03b1 \u2192 Prop) :\n\t(\u2200 {a b : finset \u03b1}, P a b \u2192 P b a) \u2192 (\u2200 {a : finset \u03b1}, P a \u2205) \u2192 (\u2200 {a b : \u03b1}, P {a}\n\t{b}) \u2192 (\u2200 {a b c : finset \u03b1}, P a c \u2192 P b c \u2192 P (a \u222a b) c) \u2192 \u2200 (a b : finset \u03b1), P a b", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : decidable_eq \u03b1] (P : finset \u03b1 \u2192 finset \u03b1 \u2192 Prop), (\u2200 {a b : finset \u03b1}, P a b \u2192 P b a) \u2192 (\u2200 {a : finset \u03b1}, P a \u2205) \u2192 (\u2200 {a b : \u03b1}, P {a} {b}) \u2192 (\u2200 {a b c : finset \u03b1}, P a c \u2192 P b c \u2192 P (a \u222a b) c) \u2192 \u2200 (a b : finset \u03b1), P a b", "decl_nm": "finset.induction_on_union"}
{"formal_statement": "theorem tendsto_nhds_iff {\u03b2 \u03b3 : Type*} [topological_space \u03b2] [topological_space \u03b3]\n\t{\u03b9 : Type*} {f : \u03b9 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3} {a : filter \u03b9} {b : \u03b2} (hg : open_embedding g) :\n\t(filter.tendsto f a (nhds b) \u2194 filter.tendsto (g \u2218 f) a (nhds (g b)))", "decl_tp": "\u2200 {\u03b2 : Type u_2} {\u03b3 : Type u_3} [_inst_2 : topological_space \u03b2] [_inst_3 : topological_space \u03b3] {\u03b9 : Type u_1} {f : \u03b9 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3} {a : filter \u03b9} {b : \u03b2}, open_embedding g \u2192 (filter.tendsto f a (nhds b) \u2194 filter.tendsto (g \u2218 f) a (nhds (g b)))", "decl_nm": "open_embedding.tendsto_nhds_iff"}
{"formal_statement": "theorem nat_abs_eq_of_dvd_dvd {s t : \u2124} (hst : s \u2223 t) (hts : t \u2223 s) :\n\ts.nat_abs = t.nat_abs", "decl_tp": "\u2200 {s t : \u2124}, s \u2223 t \u2192 t \u2223 s \u2192 s.nat_abs = t.nat_abs", "decl_nm": "int.nat_abs_eq_of_dvd_dvd"}
{"formal_statement": "theorem finsupp_total_repr (R : Type*) {M : Type*} [semiring R] [add_comm_monoid M]\n\t[module R M] {w : set M} (x : \u21a5(submodule.span R w)) :\n\t\u21d1(finsupp.total \u21a5w M R coe) (span.repr R w x) = \u2191x", "decl_tp": "\u2200 (R : Type u_1) {M : Type u_2} [_inst_1 : semiring R] [_inst_2 : add_comm_monoid M] [_inst_3 : module R M] {w : set M} (x : \u21a5(submodule.span R w)), \u21d1(finsupp.total \u21a5w M R coe) (span.repr R w x) = \u2191x", "decl_nm": "span.finsupp_total_repr"}
{"formal_statement": "theorem pairwise_lt_range' (s n : \u2115) :\n\tlist.pairwise has_lt.lt (list.range' s n)", "decl_tp": "\u2200 (s n : \u2115), list.pairwise has_lt.lt (list.range' s n)", "decl_nm": "list.pairwise_lt_range'"}
{"formal_statement": "theorem left_mul_subset {R : Type*} [ring R] [topological_space R] [nonarchimedean_ring R]\n\t(U : open_add_subgroup R) (r : R) :\n\t\u2203 (V : open_add_subgroup R), r \u2022 \u2191V \u2286 \u2191U", "decl_tp": "\u2200 {R : Type u_1} [_inst_1 : ring R] [_inst_2 : topological_space R] [_inst_3 : nonarchimedean_ring R] (U : open_add_subgroup R) (r : R), \u2203 (V : open_add_subgroup R), r \u2022 \u2191V \u2286 \u2191U", "decl_nm": "nonarchimedean_ring.left_mul_subset"}
{"formal_statement": "theorem Ico_zero_eq_range :\n\tfinset.Ico 0 = finset.range", "decl_tp": "finset.Ico 0 = finset.range", "decl_nm": "nat.Ico_zero_eq_range"}
{"formal_statement": "theorem hom_mk_left {C : Type u\u2081} [category_theory.category C] {D : Type u\u2082}\n\t[category_theory.category D] {S : D} {T : C \u2964 D} {f f' : category_theory.structured_arrow S T}\n\t(g : f.right \u27f6 f'.right) (w : f.hom \u226b T.map g = f'.hom) :\n\t(category_theory.structured_arrow.hom_mk g w).left = category_theory.eq_to_hom category_theory.structured_arrow.hom_mk._proof_1", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {D : Type u\u2082} [_inst_2 : category_theory.category D] {S : D} {T : C \u2964 D} {f f' : category_theory.structured_arrow S T} (g : f.right \u27f6 f'.right) (w : f.hom \u226b T.map g = f'.hom), (category_theory.structured_arrow.hom_mk g w).left = category_theory.eq_to_hom category_theory.structured_arrow.hom_mk._proof_1", "decl_nm": "category_theory.structured_arrow.hom_mk_left"}
{"formal_statement": "theorem continuous_of_locally_uniform_approx_of_continuous_at {\u03b1 \u03b2 : Type*}\n\t[uniform_space \u03b2] {f : \u03b1 \u2192 \u03b2} [topological_space \u03b1] :\n\t(\u2200 (x : \u03b1) (u : set (\u03b2 \u00d7 \u03b2)), u \u2208 uniformity \u03b2 \u2192 (\u2203 (t : set \u03b1) (H : t \u2208 nhds x)\n\t(F : \u03b1 \u2192 \u03b2), continuous_at F x \u2227 \u2200 (y : \u03b1), y \u2208 t \u2192 (f y, F y) \u2208 u)) \u2192 continuous f", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : uniform_space \u03b2] {f : \u03b1 \u2192 \u03b2} [_inst_2 : topological_space \u03b1], (\u2200 (x : \u03b1) (u : set (\u03b2 \u00d7 \u03b2)), u \u2208 uniformity \u03b2 \u2192 (\u2203 (t : set \u03b1) (H : t \u2208 nhds x) (F : \u03b1 \u2192 \u03b2), continuous_at F x \u2227 \u2200 (y : \u03b1), y \u2208 t \u2192 (f y, F y) \u2208 u)) \u2192 continuous f", "decl_nm": "continuous_of_locally_uniform_approx_of_continuous_at"}
{"formal_statement": "theorem arcsin_lt_pi_div_two {x : \u211d} :\n\treal.arcsin x < real.pi / 2 \u2194 x < 1", "decl_tp": "\u2200 {x : \u211d}, real.arcsin x < real.pi / 2 \u2194 x < 1", "decl_nm": "real.arcsin_lt_pi_div_two"}
{"formal_statement": "theorem preimage_neg_Ico {G : Type u} [ordered_add_comm_group G] (a b : G) :\n\t-set.Ico a b = set.Ioc (-b) (-a)", "decl_tp": "\u2200 {G : Type u} [_inst_1 : ordered_add_comm_group G] (a b : G), -set.Ico a b = set.Ioc (-b) (-a)", "decl_nm": "set.preimage_neg_Ico"}
{"formal_statement": "theorem mem_image_iff_bex {\u03b1 : Type u} {\u03b2 : Type v} {f : \u03b1 \u2192 \u03b2} {s : set \u03b1}\n\t{y : \u03b2} :\n\ty \u2208 f '' s \u2194 \u2203 (x : \u03b1) (_x : x \u2208 s), f x = y", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {f : \u03b1 \u2192 \u03b2} {s : set \u03b1} {y : \u03b2}, y \u2208 f '' s \u2194 \u2203 (x : \u03b1) (_x : x \u2208 s), f x = y", "decl_nm": "set.mem_image_iff_bex"}
{"formal_statement": "theorem open_segment_translate_preimage (\ud835\udd5c : Type*) {E : Type*} [ordered_ring \ud835\udd5c]\n\t[add_comm_group E] [module \ud835\udd5c E] (a b c : E) :\n\t(\u03bb (x : E), a + x) \u207b\u00b9' open_segment \ud835\udd5c (a + b) (a + c) = open_segment \ud835\udd5c b c", "decl_tp": "\u2200 (\ud835\udd5c : Type u_1) {E : Type u_2} [_inst_1 : ordered_ring \ud835\udd5c] [_inst_2 : add_comm_group E] [_inst_4 : module \ud835\udd5c E] (a b c : E), (\u03bb (x : E), a + x) \u207b\u00b9' open_segment \ud835\udd5c (a + b) (a + c) = open_segment \ud835\udd5c b c", "decl_nm": "open_segment_translate_preimage"}
{"formal_statement": "theorem mem_mk' {R : Type u} [non_assoc_semiring R] {s : set R} {sm : submonoid R}\n\t(hm : \u2191sm = s) {sa : add_submonoid R} (ha : \u2191sa = s) {x : R} :\n\tx \u2208 subsemiring.mk' s sm hm sa ha \u2194 x \u2208 s", "decl_tp": "\u2200 {R : Type u} [_inst_1 : non_assoc_semiring R] {s : set R} {sm : submonoid R} (hm : \u2191sm = s) {sa : add_submonoid R} (ha : \u2191sa = s) {x : R}, x \u2208 subsemiring.mk' s sm hm sa ha \u2194 x \u2208 s", "decl_nm": "subsemiring.mem_mk'"}
{"formal_statement": "theorem trop_add {R : Type u} [has_add R] (x y : R) :\n\ttropical.trop (x + y) = tropical.trop x * tropical.trop y", "decl_tp": "\u2200 {R : Type u} [_inst_1 : has_add R] (x y : R), tropical.trop (x + y) = tropical.trop x * tropical.trop y", "decl_nm": "tropical.trop_add"}
{"formal_statement": "theorem abs_nonneg {K : Type*} [is_R_or_C K] (z : K) :\n\t0 \u2264 is_R_or_C.abs z", "decl_tp": "\u2200 {K : Type u_1} [_inst_1 : is_R_or_C K] (z : K), 0 \u2264 is_R_or_C.abs z", "decl_nm": "is_R_or_C.abs_nonneg"}
{"formal_statement": "theorem abs_eq {\u03b1 : Type u} [linear_ordered_add_comm_group \u03b1] {a b : \u03b1}\n\t(hb : 0 \u2264 b) :\n\t(|a| = b \u2194 a = b \u2228 a = -b)", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : linear_ordered_add_comm_group \u03b1] {a b : \u03b1}, 0 \u2264 b \u2192 (|a| = b \u2194 a = b \u2228 a = -b)", "decl_nm": "abs_eq"}
{"formal_statement": "theorem one_lt_inv_of_inv {\u03b1 : Type u} [group \u03b1] [has_lt \u03b1] [covariant_class \u03b1 \u03b1 has_mul.mul has_lt.lt]\n\t{a : \u03b1} :\n\ta < 1 \u2192 1 < a\u207b\u00b9", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : group \u03b1] [_inst_2 : has_lt \u03b1] [_inst_3 : covariant_class \u03b1 \u03b1 has_mul.mul has_lt.lt] {a : \u03b1}, a < 1 \u2192 1 < a\u207b\u00b9", "decl_nm": "one_lt_inv_of_inv"}
{"formal_statement": "theorem ennreal_to_nnreal {\u03b1 : Type*} [measurable_space \u03b1] {f : \u03b1 \u2192 ennreal}\n\t(hf : measurable f) :\n\tmeasurable (\u03bb (x : \u03b1), (f x).to_nnreal)", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : measurable_space \u03b1] {f : \u03b1 \u2192 ennreal}, measurable f \u2192 measurable (\u03bb (x : \u03b1), (f x).to_nnreal)", "decl_nm": "measurable.ennreal_to_nnreal"}
{"formal_statement": "theorem and {\u03b1 : Type*} {R S : \u03b1 \u2192 \u03b1 \u2192 Prop} {l : list \u03b1} :\n\tlist.pairwise (\u03bb (a b : \u03b1), R a b \u2227 S a b) l \u2194 list.pairwise R l \u2227 list.pairwise S l", "decl_tp": "\u2200 {\u03b1 : Type u_1} {R S : \u03b1 \u2192 \u03b1 \u2192 Prop} {l : list \u03b1}, list.pairwise (\u03bb (a b : \u03b1), R a b \u2227 S a b) l \u2194 list.pairwise R l \u2227 list.pairwise S l", "decl_nm": "list.pairwise.and"}
{"formal_statement": "theorem disjoint_sdiff_iff_le {\u03b1 : Type u} {x y z : \u03b1} [generalized_boolean_algebra \u03b1]\n\t(hz : z \u2264 y) (hx : x \u2264 y) :\n\t(disjoint z (y \\ x) \u2194 z \u2264 x)", "decl_tp": "\u2200 {\u03b1 : Type u} {x y z : \u03b1} [_inst_1 : generalized_boolean_algebra \u03b1], z \u2264 y \u2192 x \u2264 y \u2192 (disjoint z (y \\ x) \u2194 z \u2264 x)", "decl_nm": "disjoint_sdiff_iff_le"}
{"formal_statement": "theorem csinh {f : \u2102 \u2192 \u2102} {f' x : \u2102} (hf : has_strict_deriv_at f f' x) :\n\thas_strict_deriv_at (\u03bb (x : \u2102), complex.sinh (f x)) (complex.cosh (f x) * f') x", "decl_tp": "\u2200 {f : \u2102 \u2192 \u2102} {f' x : \u2102}, has_strict_deriv_at f f' x \u2192 has_strict_deriv_at (\u03bb (x : \u2102), complex.sinh (f x)) (complex.cosh (f x) * f') x", "decl_nm": "has_strict_deriv_at.csinh"}
{"formal_statement": "theorem trans_apply {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} [pseudo_emetric_space \u03b1]\n\t[pseudo_emetric_space \u03b2] [pseudo_emetric_space \u03b3] (h\u2081 : \u03b1 \u2243\u1d62 \u03b2) (h\u2082 : \u03b2 \u2243\u1d62 \u03b3)\n\t(x : \u03b1) :\n\t\u21d1(h\u2081.trans h\u2082) x = \u21d1h\u2082 (\u21d1h\u2081 x)", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} [_inst_1 : pseudo_emetric_space \u03b1] [_inst_2 : pseudo_emetric_space \u03b2] [_inst_3 : pseudo_emetric_space \u03b3] (h\u2081 : \u03b1 \u2243\u1d62 \u03b2) (h\u2082 : \u03b2 \u2243\u1d62 \u03b3) (x : \u03b1), \u21d1(h\u2081.trans h\u2082) x = \u21d1h\u2082 (\u21d1h\u2081 x)", "decl_nm": "isometric.trans_apply"}
{"formal_statement": "theorem cond_to_bool {\u03b1 : Type*} (p : Prop) [decidable p] (t e : \u03b1) :\n\tcond (decidable.to_bool p) t e = ite p t e", "decl_tp": "\u2200 {\u03b1 : Type u_1} (p : Prop) [_inst_1 : decidable p] (t e : \u03b1), cond (decidable.to_bool p) t e = ite p t e", "decl_nm": "bool.cond_to_bool"}
{"formal_statement": "theorem restrict_mono {\u03b1 \u03b2 : Type*} [measurable_space \u03b1] [has_zero \u03b2] [preorder \u03b2]\n\t(s : set \u03b1) {f g : measure_theory.simple_func \u03b1 \u03b2} (H : f \u2264 g) :\n\tf.restrict s \u2264 g.restrict s", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : measurable_space \u03b1] [_inst_2 : has_zero \u03b2] [_inst_3 : preorder \u03b2] (s : set \u03b1) {f g : measure_theory.simple_func \u03b1 \u03b2}, f \u2264 g \u2192 f.restrict s \u2264 g.restrict s", "decl_nm": "measure_theory.simple_func.restrict_mono"}
{"formal_statement": "theorem comp_to_nat_trans {C : Type u\u2081} [category_theory.category C] {T\u2081 T\u2082 T\u2083 : category_theory.comonad C}\n\t(f : T\u2081 \u27f6 T\u2082) (g : T\u2082 \u27f6 T\u2083) :\n\t(f \u226b g).to_nat_trans = f.to_nat_trans \u226b g.to_nat_trans", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {T\u2081 T\u2082 T\u2083 : category_theory.comonad C} (f : T\u2081 \u27f6 T\u2082) (g : T\u2082 \u27f6 T\u2083), (f \u226b g).to_nat_trans = f.to_nat_trans \u226b g.to_nat_trans", "decl_nm": "category_theory.comp_to_nat_trans"}
{"formal_statement": "theorem congr_right {\u03b1 : Type u} {\u03b2 : Type v} {s : set \u03b1} {f\u2081 f\u2082 : \u03b1 \u2192 \u03b2}\n\t{f\u2081' : \u03b2 \u2192 \u03b1} (h\u2081 : set.left_inv_on f\u2081' f\u2081 s) (heq : set.eq_on f\u2081 f\u2082 s) :\n\tset.left_inv_on f\u2081' f\u2082 s", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {s : set \u03b1} {f\u2081 f\u2082 : \u03b1 \u2192 \u03b2} {f\u2081' : \u03b2 \u2192 \u03b1}, set.left_inv_on f\u2081' f\u2081 s \u2192 set.eq_on f\u2081 f\u2082 s \u2192 set.left_inv_on f\u2081' f\u2082 s", "decl_nm": "set.left_inv_on.congr_right"}
{"formal_statement": "theorem map\u2082_right'_nil_left {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} (f : option \u03b1 \u2192 \u03b2 \u2192 \u03b3)\n\t(bs : list \u03b2) :\n\tlist.map\u2082_right' f list.nil bs = (list.map (f option.none) bs, list.nil \u03b1)", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} (f : option \u03b1 \u2192 \u03b2 \u2192 \u03b3) (bs : list \u03b2), list.map\u2082_right' f list.nil bs = (list.map (f option.none) bs, list.nil \u03b1)", "decl_nm": "list.map\u2082_right'_nil_left"}
{"formal_statement": "theorem mul_indicator_finset_prod {\u03b1 \u03b9 M : Type*} [comm_monoid M] (I : finset \u03b9)\n\t(s : set \u03b1) (f : \u03b9 \u2192 \u03b1 \u2192 M) :\n\ts.mul_indicator (I.prod (\u03bb (i : \u03b9), f i)) = I.prod (\u03bb (i : \u03b9), s.mul_indicator (f i))", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b9 : Type u_3} {M : Type u_4} [_inst_1 : comm_monoid M] (I : finset \u03b9) (s : set \u03b1) (f : \u03b9 \u2192 \u03b1 \u2192 M), s.mul_indicator (I.prod (\u03bb (i : \u03b9), f i)) = I.prod (\u03bb (i : \u03b9), s.mul_indicator (f i))", "decl_nm": "set.mul_indicator_finset_prod"}
{"formal_statement": "theorem left_comp_retraction {C : Type u} [category_theory.category C]\n\t{A B : C} (f g : A \u27f6 B) [category_theory.is_coreflexive_pair f g] :\n\tf \u226b category_theory.common_retraction f g = \ud835\udfd9 A", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] {A B : C} (f g : A \u27f6 B) [_inst_3 : category_theory.is_coreflexive_pair f g], f \u226b category_theory.common_retraction f g = \ud835\udfd9 A", "decl_nm": "category_theory.left_comp_retraction"}
{"formal_statement": "theorem algebra_map_eq_one_iff {R : Type*} [comm_semiring R] {X : Type*}\n\t(x : R) :\n\t\u21d1(algebra_map R (free_algebra R X)) x = 1 \u2194 x = 1", "decl_tp": "\u2200 {R : Type u_1} [_inst_1 : comm_semiring R] {X : Type u_2} (x : R), \u21d1(algebra_map R (free_algebra R X)) x = 1 \u2194 x = 1", "decl_nm": "free_algebra.algebra_map_eq_one_iff"}
{"formal_statement": "theorem ne_zero_of_coprime {x y z : \u2124} (h : pythagorean_triple x y z) (hc : x.gcd y = 1) :\n\tz \u2260 0", "decl_tp": "\u2200 {x y z : \u2124}, pythagorean_triple x y z \u2192 x.gcd y = 1 \u2192 z \u2260 0", "decl_nm": "pythagorean_triple.ne_zero_of_coprime"}
{"formal_statement": "theorem surjective_untrop {R : Type u} :\n\tfunction.surjective tropical.untrop", "decl_tp": "\u2200 {R : Type u}, function.surjective tropical.untrop", "decl_nm": "tropical.surjective_untrop"}
{"formal_statement": "theorem cases_on {P : enat \u2192 Prop} (a : enat) :\n\tP \u22a4 \u2192 (\u2200 (n : \u2115), P \u2191n) \u2192 P a", "decl_tp": "\u2200 {P : enat \u2192 Prop} (a : enat), P \u22a4 \u2192 (\u2200 (n : \u2115), P \u2191n) \u2192 P a", "decl_nm": "enat.cases_on"}
{"formal_statement": "theorem insert {\u03b1 \u03b9 : Type*} [semilattice_inf \u03b1] [order_bot \u03b1] {s : set \u03b9}\n\t{f : \u03b9 \u2192 \u03b1} (hs : s.pairwise_disjoint f) :\n\t\u2200 {i : \u03b9}, (\u2200 (j : \u03b9), j \u2208 s \u2192 i \u2260 j \u2192 disjoint (f i) (f j)) \u2192 (has_insert.insert i s).pairwise_disjoint f", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b9 : Type u_2} [_inst_1 : semilattice_inf \u03b1] [_inst_2 : order_bot \u03b1] {s : set \u03b9} {f : \u03b9 \u2192 \u03b1}, s.pairwise_disjoint f \u2192 \u2200 {i : \u03b9}, (\u2200 (j : \u03b9), j \u2208 s \u2192 i \u2260 j \u2192 disjoint (f i) (f j)) \u2192 (has_insert.insert i s).pairwise_disjoint f", "decl_nm": "set.pairwise_disjoint.insert"}
{"formal_statement": "theorem mem_ball' {\u03b1 : Type u} [pseudo_emetric_space \u03b1] {x y : \u03b1} {\u03b5 : ennreal} :\n\ty \u2208 emetric.ball x \u03b5 \u2194 has_edist.edist x y < \u03b5", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : pseudo_emetric_space \u03b1] {x y : \u03b1} {\u03b5 : ennreal}, y \u2208 emetric.ball x \u03b5 \u2194 has_edist.edist x y < \u03b5", "decl_nm": "emetric.mem_ball'"}
{"formal_statement": "theorem map_iso_inv {C : Type u} [category_theory.category C] {W X Y Z : C}\n\t[category_theory.limits.has_binary_coproduct W X] [category_theory.limits.has_binary_coproduct Y Z]\n\t(f : W \u2245 Y) (g : X \u2245 Z) :\n\t(category_theory.limits.coprod.map_iso f g).inv = category_theory.limits.coprod.map f.inv g.inv", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] {W X Y Z : C} [_inst_2 : category_theory.limits.has_binary_coproduct W X] [_inst_3 : category_theory.limits.has_binary_coproduct Y Z] (f : W \u2245 Y) (g : X \u2245 Z), (category_theory.limits.coprod.map_iso f g).inv = category_theory.limits.coprod.map f.inv g.inv", "decl_nm": "category_theory.limits.coprod.map_iso_inv"}
{"formal_statement": "theorem functor_obj_map {C : Type u\u2081} [category_theory.category C] {D : Type u\u2082}\n\t[category_theory.category D] [category_theory.monoidal_category D] [category_theory.braided_category D]\n\t(A : CommMon_ (C \u2964 D)) {X Y : C} (\u1fb0 : X \u27f6 Y) :\n\t(category_theory.monoidal.CommMon_functor_category_equivalence.functor.obj A).map \u1fb0 = ((category_theory.monoidal.Mon_functor_category_equivalence C D).functor.obj A.to_Mon_).map \u1fb0", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {D : Type u\u2082} [_inst_2 : category_theory.category D] [_inst_3 : category_theory.monoidal_category D] [_inst_4 : category_theory.braided_category D] (A : CommMon_ (C \u2964 D)) {X Y : C} (\u1fb0 : X \u27f6 Y), (category_theory.monoidal.CommMon_functor_category_equivalence.functor.obj A).map \u1fb0 = ((category_theory.monoidal.Mon_functor_category_equivalence C D).functor.obj A.to_Mon_).map \u1fb0", "decl_nm": "category_theory.monoidal.CommMon_functor_category_equivalence.functor_obj_map"}
{"formal_statement": "theorem map_div {R : Type u} {A : Type v} {B : Type w} [comm_ring R] [division_ring A]\n\t[division_ring B] [algebra R A] [algebra R B] (\u03c6 : A \u2192\u2090[R] B) (x y : A) :\n\t\u21d1\u03c6 (x / y) = \u21d1\u03c6 x / \u21d1\u03c6 y", "decl_tp": "\u2200 {R : Type u} {A : Type v} {B : Type w} [_inst_1 : comm_ring R] [_inst_2 : division_ring A] [_inst_3 : division_ring B] [_inst_4 : algebra R A] [_inst_5 : algebra R B] (\u03c6 : A \u2192\u2090[R] B) (x y : A), \u21d1\u03c6 (x / y) = \u21d1\u03c6 x / \u21d1\u03c6 y", "decl_nm": "alg_hom.map_div"}
{"formal_statement": "theorem inr_snd_assoc {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C]\n\t{X Y : C} [category_theory.limits.has_binary_biproduct X Y] {X' : C} (f' : Y \u27f6 X') :\n\tcategory_theory.limits.biprod.inr \u226b category_theory.limits.biprod.snd \u226b f' = f'", "decl_tp": "\u2200 {C : Type u} [_inst_2 : category_theory.category C] [_inst_3 : category_theory.limits.has_zero_morphisms C] {X Y : C} [_inst_4 : category_theory.limits.has_binary_biproduct X Y] {X' : C} (f' : Y \u27f6 X'), category_theory.limits.biprod.inr \u226b category_theory.limits.biprod.snd \u226b f' = f'", "decl_nm": "category_theory.limits.biprod.inr_snd_assoc"}
{"formal_statement": "theorem map_vadd {\ud835\udd5c V V\u2082 P P\u2082 : Type*} [normed_field \ud835\udd5c] [semi_normed_group V]\n\t[semi_normed_group V\u2082] [semi_normed_space \ud835\udd5c V] [semi_normed_space \ud835\udd5c V\u2082]\n\t[pseudo_metric_space P] [pseudo_metric_space P\u2082] [semi_normed_add_torsor V P]\n\t[semi_normed_add_torsor V\u2082 P\u2082] (e : P \u2243\u1d43\u2071[\ud835\udd5c] P\u2082) (p : P) (v : V) :\n\t\u21d1e (v +\u1d65 p) = \u21d1(e.linear_isometry_equiv) v +\u1d65 \u21d1e p", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} {V : Type u_2} {V\u2082 : Type u_4} {P : Type u_8} {P\u2082 : Type u_9} [_inst_1 : normed_field \ud835\udd5c] [_inst_2 : semi_normed_group V] [_inst_4 : semi_normed_group V\u2082] [_inst_7 : semi_normed_space \ud835\udd5c V] [_inst_9 : semi_normed_space \ud835\udd5c V\u2082] [_inst_12 : pseudo_metric_space P] [_inst_14 : pseudo_metric_space P\u2082] [_inst_17 : semi_normed_add_torsor V P] [_inst_19 : semi_normed_add_torsor V\u2082 P\u2082] (e : P \u2243\u1d43\u2071[\ud835\udd5c] P\u2082) (p : P) (v : V), \u21d1e (v +\u1d65 p) = \u21d1(e.linear_isometry_equiv) v +\u1d65 \u21d1e p", "decl_nm": "affine_isometry_equiv.map_vadd"}
{"formal_statement": "theorem bit0_ne_zero (a : cardinal) :\n\t\u00acbit0 a = 0 \u2194 \u00aca = 0", "decl_tp": "\u2200 (a : cardinal), \u00acbit0 a = 0 \u2194 \u00aca = 0", "decl_nm": "cardinal.bit0_ne_zero"}
{"formal_statement": "theorem to_nnreal_le_iff_le_coe {r : \u211d} {p : nnreal} :\n\tr.to_nnreal \u2264 p \u2194 r \u2264 \u2191p", "decl_tp": "\u2200 {r : \u211d} {p : nnreal}, r.to_nnreal \u2264 p \u2194 r \u2264 \u2191p", "decl_nm": "real.to_nnreal_le_iff_le_coe"}
{"formal_statement": "theorem abs_lt_of_sq_lt_sq {R : Type*} [linear_ordered_ring R] {x y : R}\n\t(h : x ^ 2 < y ^ 2) (hy : 0 \u2264 y) :\n\t|x| < y", "decl_tp": "\u2200 {R : Type u_4} [_inst_1 : linear_ordered_ring R] {x y : R}, x ^ 2 < y ^ 2 \u2192 0 \u2264 y \u2192 |x| < y", "decl_nm": "abs_lt_of_sq_lt_sq"}
{"formal_statement": "theorem is_simple_group_of_surjective {G : Type*} [group G] {H : Type*}\n\t[group H] [is_simple_group G] [nontrivial H] (f : G \u2192* H) (hf : function.surjective \u21d1f) :\n\tis_simple_group H", "decl_tp": "\u2200 {G : Type u_1} [_inst_1 : group G] {H : Type u_2} [_inst_4 : group H] [_inst_5 : is_simple_group G] [_inst_6 : nontrivial H] (f : G \u2192* H), function.surjective \u21d1f \u2192 is_simple_group H", "decl_nm": "is_simple_group.is_simple_group_of_surjective"}
{"formal_statement": "theorem ite_continuous' {\u03b1 : Type u} {\u03b2 : Type v} [omega_complete_partial_order \u03b1]\n\t[omega_complete_partial_order \u03b2] {p : Prop} [hp : decidable p] (f g : \u03b1 \u2192 \u03b2)\n\t(hf : omega_complete_partial_order.continuous' f) (hg : omega_complete_partial_order.continuous' g) :\n\tomega_complete_partial_order.continuous' (\u03bb (x : \u03b1), ite p (f x) (g x))", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : omega_complete_partial_order \u03b1] [_inst_2 : omega_complete_partial_order \u03b2] {p : Prop} [hp : decidable p] (f g : \u03b1 \u2192 \u03b2), omega_complete_partial_order.continuous' f \u2192 omega_complete_partial_order.continuous' g \u2192 omega_complete_partial_order.continuous' (\u03bb (x : \u03b1), ite p (f x) (g x))", "decl_nm": "omega_complete_partial_order.continuous_hom.ite_continuous'"}
{"formal_statement": "theorem refl_target {\u03b1 : Type*} :\n\t(local_equiv.refl \u03b1).target = set.univ", "decl_tp": "\u2200 {\u03b1 : Type u_1}, (local_equiv.refl \u03b1).target = set.univ", "decl_nm": "local_equiv.refl_target"}
{"formal_statement": "theorem smul_eq_mul_aut_conj {G : Type*} [group G] (g : conj_act G) (h : G) :\n\tg \u2022 h = \u21d1(\u21d1mul_aut.conj (\u21d1conj_act.of_conj_act g)) h", "decl_tp": "\u2200 {G : Type u_1} [_inst_1 : group G] (g : conj_act G) (h : G), g \u2022 h = \u21d1(\u21d1mul_aut.conj (\u21d1conj_act.of_conj_act g)) h", "decl_nm": "conj_act.smul_eq_mul_aut_conj"}
{"formal_statement": "theorem le_multiplicity_of_pow_dvd {\u03b1 : Type*} [comm_monoid \u03b1] [decidable_rel has_dvd.dvd]\n\t{a b : \u03b1} {k : \u2115} (hk : a ^ k \u2223 b) :\n\t\u2191k \u2264 multiplicity a b", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : comm_monoid \u03b1] [_inst_2 : decidable_rel has_dvd.dvd] {a b : \u03b1} {k : \u2115}, a ^ k \u2223 b \u2192 \u2191k \u2264 multiplicity a b", "decl_nm": "multiplicity.le_multiplicity_of_pow_dvd"}
{"formal_statement": "theorem inv_zero {G\u2080 : Type u} [group_with_zero G\u2080] :\n\t0\u207b\u00b9 = 0", "decl_tp": "\u2200 {G\u2080 : Type u} [_inst_1 : group_with_zero G\u2080], 0\u207b\u00b9 = 0", "decl_nm": "inv_zero"}
{"formal_statement": "theorem is_Hausdorff_iff {R : Type*} [comm_ring R] {I : ideal R} {M : Type*}\n\t[add_comm_group M] [module R M] :\n\tis_Hausdorff I M \u2194 \u2200 (x : M), (\u2200 (n : \u2115), x \u2261 0 [SMOD I ^ n \u2022 \u22a4]) \u2192 x = 0", "decl_tp": "\u2200 {R : Type u_1} [_inst_1 : comm_ring R] {I : ideal R} {M : Type u_2} [_inst_2 : add_comm_group M] [_inst_3 : module R M], is_Hausdorff I M \u2194 \u2200 (x : M), (\u2200 (n : \u2115), x \u2261 0 [SMOD I ^ n \u2022 \u22a4]) \u2192 x = 0", "decl_nm": "is_Hausdorff_iff"}
{"formal_statement": "theorem tsum_nonneg {\u03b1 \u03b2 : Type*} [ordered_add_comm_monoid \u03b1] [topological_space \u03b1]\n\t[order_closed_topology \u03b1] {g : \u03b2 \u2192 \u03b1} :\n\t(\u2200 (b : \u03b2), 0 \u2264 g b) \u2192 0 \u2264 \u2211' (b : \u03b2), g b", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : ordered_add_comm_monoid \u03b1] [_inst_2 : topological_space \u03b1] [_inst_3 : order_closed_topology \u03b1] {g : \u03b2 \u2192 \u03b1}, (\u2200 (b : \u03b2), 0 \u2264 g b) \u2192 0 \u2264 \u2211' (b : \u03b2), g b", "decl_nm": "tsum_nonneg"}
{"formal_statement": "theorem disjoint_of_disjoint_of_mem {\u03b1 : Type u} {f g : filter \u03b1} {s t : set \u03b1}\n\t(h : disjoint s t) (hs : s \u2208 f) (ht : t \u2208 g) :\n\tdisjoint f g", "decl_tp": "\u2200 {\u03b1 : Type u} {f g : filter \u03b1} {s t : set \u03b1}, disjoint s t \u2192 s \u2208 f \u2192 t \u2208 g \u2192 disjoint f g", "decl_nm": "filter.disjoint_of_disjoint_of_mem"}
{"formal_statement": "theorem zip_map_left {\u03b1 : Type u} {\u03b2 \u03b3 : Type*} (f : \u03b1 \u2192 \u03b3) (l\u2081 : list \u03b1)\n\t(l\u2082 : list \u03b2) :\n\t(list.map f l\u2081).zip l\u2082 = list.map (prod.map f id) (l\u2081.zip l\u2082)", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type u_1} {\u03b3 : Type u_2} (f : \u03b1 \u2192 \u03b3) (l\u2081 : list \u03b1) (l\u2082 : list \u03b2), (list.map f l\u2081).zip l\u2082 = list.map (prod.map f id) (l\u2081.zip l\u2082)", "decl_nm": "list.zip_map_left"}
{"formal_statement": "theorem mk_hom_hom {J : Type v} {C : Type u} [category_theory.category C]\n\t{X Y : C} {f : J \u2192 (X \u27f6 Y)} [nonempty J] {s t : category_theory.limits.cotrident f}\n\t(k : s.X \u27f6 t.X) (w : s.\u03c0 \u226b k = t.\u03c0) :\n\t(category_theory.limits.cotrident.mk_hom k w).hom = k", "decl_tp": "\u2200 {J : Type v} {C : Type u} [_inst_1 : category_theory.category C] {X Y : C} {f : J \u2192 (X \u27f6 Y)} [_inst_2 : nonempty J] {s t : category_theory.limits.cotrident f} (k : s.X \u27f6 t.X) (w : s.\u03c0 \u226b k = t.\u03c0), (category_theory.limits.cotrident.mk_hom k w).hom = k", "decl_nm": "category_theory.limits.cotrident.mk_hom_hom"}
{"formal_statement": "theorem dimH_image_le {X Y : Type*} [emetric_space X] [emetric_space Y]\n\t{K : nnreal} {f : X \u2192 Y} (h : lipschitz_with K f) :\n\t\u2200 (s : set X), dimH (f '' s) \u2264 dimH s", "decl_tp": "\u2200 {X : Type u_2} {Y : Type u_3} [_inst_1 : emetric_space X] [_inst_2 : emetric_space Y] {K : nnreal} {f : X \u2192 Y}, lipschitz_with K f \u2192 \u2200 (s : set X), dimH (f '' s) \u2264 dimH s", "decl_nm": "lipschitz_with.dimH_image_le"}
{"formal_statement": "theorem left_mem_Ico {\u03b1 : Type*} [preorder \u03b1] [locally_finite_order \u03b1]\n\t{a b : \u03b1} :\n\ta \u2208 multiset.Ico a b \u2194 a < b", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : preorder \u03b1] [_inst_2 : locally_finite_order \u03b1] {a b : \u03b1}, a \u2208 multiset.Ico a b \u2194 a < b", "decl_nm": "multiset.left_mem_Ico"}
{"formal_statement": "theorem nonempty {\u03b1 : Type u} [preorder \u03b1] {s : set \u03b1} {a : \u03b1} (h : is_greatest s a) :\n\ts.nonempty", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : preorder \u03b1] {s : set \u03b1} {a : \u03b1}, is_greatest s a \u2192 s.nonempty", "decl_nm": "is_greatest.nonempty"}
{"formal_statement": "theorem ext_chart_at_map_nhds_within {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c]\n\t{E : Type*} [normed_group E] [normed_space \ud835\udd5c E] {H : Type*} [topological_space H]\n\t(I : model_with_corners \ud835\udd5c E H) {M : Type*} [topological_space M] [charted_space H M]\n\t(x : M) {s : set M} :\n\tfilter.map \u21d1(ext_chart_at I x) (nhds_within x s) = nhds_within (\u21d1(ext_chart_at I x) x)\n\t(\u21d1((ext_chart_at I x).symm) \u207b\u00b9' s \u2229 set.range \u21d1I)", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {H : Type u_3} [_inst_4 : topological_space H] (I : model_with_corners \ud835\udd5c E H) {M : Type u_4} [_inst_5 : topological_space M] [_inst_6 : charted_space H M] (x : M) {s : set M}, filter.map \u21d1(ext_chart_at I x) (nhds_within x s) = nhds_within (\u21d1(ext_chart_at I x) x) (\u21d1((ext_chart_at I x).symm) \u207b\u00b9' s \u2229 set.range \u21d1I)", "decl_nm": "ext_chart_at_map_nhds_within"}
{"formal_statement": "theorem neg_snd {q : \u2115+} (x : lucas_lehmer.X q) :\n\t(-x).snd = -x.snd", "decl_tp": "\u2200 {q : \u2115+} (x : lucas_lehmer.X q), (-x).snd = -x.snd", "decl_nm": "lucas_lehmer.X.neg_snd"}
{"formal_statement": "theorem sequential_closure_subset_closure {\u03b1 : Type*} [topological_space \u03b1]\n\t(M : set \u03b1) :\n\tsequential_closure M \u2286 closure M", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : topological_space \u03b1] (M : set \u03b1), sequential_closure M \u2286 closure M", "decl_nm": "sequential_closure_subset_closure"}
{"formal_statement": "theorem continuous_finprod {\u03b9 X M : Type*} [topological_space X] [topological_space M]\n\t[comm_monoid M] [has_continuous_mul M] {f : \u03b9 \u2192 X \u2192 M} (hf : locally_finite (\u03bb (i : \u03b9), function.mul_support (f i))) :\n\t(\u2200 (i : \u03b9), continuous (f i)) \u2192  continuous (\u03bb (x : X), finprod (\u03bb (i : \u03b9), f i x))", "decl_tp": "\u2200 {\u03b9 : Type u_1} {X : Type u_3} {M : Type u_4} [_inst_1 : topological_space X] [_inst_2 : topological_space M] [_inst_3 : comm_monoid M] [_inst_4 : has_continuous_mul M] {f : \u03b9 \u2192 X \u2192 M}, (\u2200 (i : \u03b9), continuous (f i)) \u2192 locally_finite (\u03bb (i : \u03b9), function.mul_support (f i)) \u2192 continuous (\u03bb (x : X), finprod (\u03bb (i : \u03b9), f i x))", "decl_nm": "continuous_finprod"}
{"formal_statement": "theorem lift_prop_at_chart_symm {H M : Type*} [topological_space H] [topological_space M]\n\t[charted_space H M] {G : structure_groupoid H} {x : M} {Q : (H \u2192 H) \u2192 set H \u2192 H \u2192 Prop}\n\t[has_groupoid M G] (hG : G.local_invariant_prop G Q) :\n\t(\u2200 (y : H), Q id set.univ y) \u2192 charted_space.lift_prop_at Q \u21d1((charted_space.chart_at H x).symm)\n\t(\u21d1(charted_space.chart_at H x) x)", "decl_tp": "\u2200 {H : Type u_1} {M : Type u_2} [_inst_1 : topological_space H] [_inst_2 : topological_space M] [_inst_3 : charted_space H M] {G : structure_groupoid H} {x : M} {Q : (H \u2192 H) \u2192 set H \u2192 H \u2192 Prop} [_inst_7 : has_groupoid M G], G.local_invariant_prop G Q \u2192 (\u2200 (y : H), Q id set.univ y) \u2192 charted_space.lift_prop_at Q \u21d1((charted_space.chart_at H x).symm) (\u21d1(charted_space.chart_at H x) x)", "decl_nm": "structure_groupoid.local_invariant_prop.lift_prop_at_chart_symm"}
{"formal_statement": "theorem symmetric {\u03b1 : Type*} :\n\tsymmetric equiv.perm.disjoint", "decl_tp": "\u2200 {\u03b1 : Type u_1}, symmetric equiv.perm.disjoint", "decl_nm": "equiv.perm.disjoint.symmetric"}
{"formal_statement": "theorem nodup_powerset {\u03b1 : Type*} {s : multiset \u03b1} :\n\ts.powerset.nodup \u2194 s.nodup", "decl_tp": "\u2200 {\u03b1 : Type u_1} {s : multiset \u03b1}, s.powerset.nodup \u2194 s.nodup", "decl_nm": "multiset.nodup_powerset"}
{"formal_statement": "theorem leading_coeff_zero {R : Type u} [semiring R] :\n\t0.leading_coeff = 0", "decl_tp": "\u2200 {R : Type u} [_inst_1 : semiring R], 0.leading_coeff = 0", "decl_nm": "polynomial.leading_coeff_zero"}
{"formal_statement": "theorem integrable_on_of_nhds_within {\u03b1 E : Type*} [measurable_space \u03b1]\n\t[measurable_space E] [normed_group E] [topological_space \u03b1] {\u03bc : measure_theory.measure \u03b1}\n\t{s : set \u03b1} (hs : is_compact s) :\n\t\u2200 {f : \u03b1 \u2192 E}, (\u2200 (x : \u03b1), x \u2208 s \u2192 measure_theory.integrable_at_filter f (nhds_within x s) \u03bc) \u2192 measure_theory.integrable_on f s \u03bc", "decl_tp": "\u2200 {\u03b1 : Type u_1} {E : Type u_3} [_inst_1 : measurable_space \u03b1] [_inst_2 : measurable_space E] [_inst_3 : normed_group E] [_inst_4 : topological_space \u03b1] {\u03bc : measure_theory.measure \u03b1} {s : set \u03b1}, is_compact s \u2192 \u2200 {f : \u03b1 \u2192 E}, (\u2200 (x : \u03b1), x \u2208 s \u2192 measure_theory.integrable_at_filter f (nhds_within x s) \u03bc) \u2192 measure_theory.integrable_on f s \u03bc", "decl_nm": "is_compact.integrable_on_of_nhds_within"}
{"formal_statement": "theorem inv {G : Type w} [topological_space G] [group G] [topological_group G]\n\t{s : set G} (hs : is_closed s) :\n\tis_closed s\u207b\u00b9", "decl_tp": "\u2200 {G : Type w} [_inst_1 : topological_space G] [_inst_2 : group G] [_inst_3 : topological_group G] {s : set G}, is_closed s \u2192 is_closed s\u207b\u00b9", "decl_nm": "is_closed.inv"}
{"formal_statement": "theorem lift_nc_single {k : Type u\u2081} {G : Type u\u2082} [semiring k] [mul_one_class G]\n\t{R : Type*} [semiring R] (f : k \u2192+ R) (g : G \u2192* R) (a : G) (b : k) :\n\t\u21d1(monoid_algebra.lift_nc f g) (finsupp.single a b) = \u21d1f b * \u21d1g a", "decl_tp": "\u2200 {k : Type u\u2081} {G : Type u\u2082} [_inst_1 : semiring k] [_inst_2 : mul_one_class G] {R : Type u_1} [_inst_3 : semiring R] (f : k \u2192+ R) (g : G \u2192* R) (a : G) (b : k), \u21d1(monoid_algebra.lift_nc f g) (finsupp.single a b) = \u21d1f b * \u21d1g a", "decl_nm": "monoid_algebra.lift_nc_single"}
{"formal_statement": "theorem zero_to_nat :\n\t\u21d1cardinal.to_nat 0 = 0", "decl_tp": "\u21d1cardinal.to_nat 0 = 0", "decl_nm": "cardinal.zero_to_nat"}
{"formal_statement": "theorem pos {c : cardinal} (H : c.is_regular) :\n\t0 < c", "decl_tp": "\u2200 {c : cardinal}, c.is_regular \u2192 0 < c", "decl_nm": "cardinal.is_regular.pos"}
{"formal_statement": "theorem mul_zero_eq_const {M\u2080 : Type*} [mul_zero_class M\u2080] :\n\t(\u03bb (_x : M\u2080), _x * 0) = function.const M\u2080 0", "decl_tp": "\u2200 {M\u2080 : Type u_1} [_inst_1 : mul_zero_class M\u2080], (\u03bb (_x : M\u2080), _x * 0) = function.const M\u2080 0", "decl_nm": "mul_zero_eq_const"}
{"formal_statement": "theorem endomorphism_simple_eq_smul_id {C : Type u} [category_theory.category C]\n\t[category_theory.preadditive C] (\ud835\udd5c : Type*) [field \ud835\udd5c] [is_alg_closed \ud835\udd5c]\n\t[category_theory.linear \ud835\udd5c C] [category_theory.limits.has_kernels C] {X : C}\n\t[category_theory.simple X] [I : finite_dimensional \ud835\udd5c (X \u27f6 X)] (f : X \u27f6 X) :\n\t\u2203 (c : \ud835\udd5c), c \u2022 \ud835\udfd9 X = f", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] [_inst_2 : category_theory.preadditive C] (\ud835\udd5c : Type u_1) [_inst_3 : field \ud835\udd5c] [_inst_4 : is_alg_closed \ud835\udd5c] [_inst_5 : category_theory.linear \ud835\udd5c C] [_inst_6 : category_theory.limits.has_kernels C] {X : C} [_inst_7 : category_theory.simple X] [I : finite_dimensional \ud835\udd5c (X \u27f6 X)] (f : X \u27f6 X), \u2203 (c : \ud835\udd5c), c \u2022 \ud835\udfd9 X = f", "decl_nm": "category_theory.endomorphism_simple_eq_smul_id"}
{"formal_statement": "theorem finrank_hom_simple_simple_eq_zero_of_not_iso {C : Type u} [category_theory.category C]\n\t[category_theory.preadditive C] (\ud835\udd5c : Type*) [field \ud835\udd5c] [category_theory.limits.has_kernels C]\n\t[category_theory.linear \ud835\udd5c C] {X Y : C} [category_theory.simple X] [category_theory.simple Y] :\n\t((X \u2245 Y) \u2192 false) \u2192 finite_dimensional.finrank \ud835\udd5c (X \u27f6 Y) = 0", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] [_inst_2 : category_theory.preadditive C] (\ud835\udd5c : Type u_1) [_inst_3 : field \ud835\udd5c] [_inst_4 : category_theory.limits.has_kernels C] [_inst_5 : category_theory.linear \ud835\udd5c C] {X Y : C} [_inst_6 : category_theory.simple X] [_inst_7 : category_theory.simple Y], ((X \u2245 Y) \u2192 false) \u2192 finite_dimensional.finrank \ud835\udd5c (X \u27f6 Y) = 0", "decl_nm": "category_theory.finrank_hom_simple_simple_eq_zero_of_not_iso"}
{"formal_statement": "theorem prod_product_right {\u03b2 : Type u} {\u03b1 : Type v} {\u03b3 : Type w} [comm_monoid \u03b2]\n\t{s : finset \u03b3} {t : finset \u03b1} {f : \u03b3 \u00d7 \u03b1 \u2192 \u03b2} :\n\t(s.product t).prod (\u03bb (x : \u03b3 \u00d7 \u03b1), f x) = t.prod (\u03bb (y : \u03b1), s.prod (\u03bb (x : \u03b3), f (x, y)))", "decl_tp": "\u2200 {\u03b2 : Type u} {\u03b1 : Type v} {\u03b3 : Type w} [_inst_1 : comm_monoid \u03b2] {s : finset \u03b3} {t : finset \u03b1} {f : \u03b3 \u00d7 \u03b1 \u2192 \u03b2}, (s.product t).prod (\u03bb (x : \u03b3 \u00d7 \u03b1), f x) = t.prod (\u03bb (y : \u03b1), s.prod (\u03bb (x : \u03b3), f (x, y)))", "decl_nm": "finset.prod_product_right"}
{"formal_statement": "theorem vsub {\u03b1 V P : Type*} [semi_normed_group V] [pseudo_metric_space P]\n\t[semi_normed_add_torsor V P] {l : filter \u03b1} {f g : \u03b1 \u2192 P} {x y : P} (hf : filter.tendsto f l (nhds x))\n\t(hg : filter.tendsto g l (nhds y)) :\n\tfilter.tendsto (f -\u1d65 g) l (nhds (x -\u1d65 y))", "decl_tp": "\u2200 {\u03b1 : Type u_1} {V : Type u_2} {P : Type u_3} [_inst_1 : semi_normed_group V] [_inst_2 : pseudo_metric_space P] [_inst_3 : semi_normed_add_torsor V P] {l : filter \u03b1} {f g : \u03b1 \u2192 P} {x y : P}, filter.tendsto f l (nhds x) \u2192 filter.tendsto g l (nhds y) \u2192 filter.tendsto (f -\u1d65 g) l (nhds (x -\u1d65 y))", "decl_nm": "filter.tendsto.vsub"}
{"formal_statement": "theorem restrict_scalars_embedding_apply (S : Type u') (R : Type u) (M : Type v)\n\t[semiring R] [add_comm_monoid M] [semiring S] [module S M] [module R M]\n\t[has_scalar S R] [is_scalar_tower S R M] (V : submodule R M) :\n\t\u21d1(submodule.restrict_scalars_embedding S R M) V = submodule.restrict_scalars S V", "decl_tp": "\u2200 (S : Type u') (R : Type u) (M : Type v) [_inst_1 : semiring R] [_inst_2 : add_comm_monoid M] [_inst_3 : semiring S] [_inst_4 : module S M] [_inst_5 : module R M] [_inst_6 : has_scalar S R] [_inst_7 : is_scalar_tower S R M] (V : submodule R M), \u21d1(submodule.restrict_scalars_embedding S R M) V = submodule.restrict_scalars S V", "decl_nm": "submodule.restrict_scalars_embedding_apply"}
{"formal_statement": "theorem injective {V : Type u} {G : simple_graph V} {x : G.subgraph} :\n\tfunction.injective \u21d1(x.map_top)", "decl_tp": "\u2200 {V : Type u} {G : simple_graph V} {x : G.subgraph}, function.injective \u21d1(x.map_top)", "decl_nm": "simple_graph.subgraph.map_top.injective"}
{"formal_statement": "theorem add_eq (x y : punit) :\n\tx + y = punit.star", "decl_tp": "\u2200 (x y : punit), x + y = punit.star", "decl_nm": "punit.add_eq"}
{"formal_statement": "theorem monoid_hom_congr_apply {M N P Q : Type*} [mul_one_class M] [mul_one_class N]\n\t[comm_monoid P] [comm_monoid Q] (f : M \u2243* N) (g : P \u2243* Q) (h : M \u2192* P) :\n\t\u21d1(f.monoid_hom_congr g) h = g.to_monoid_hom.comp (h.comp f.symm.to_monoid_hom)", "decl_tp": "\u2200 {M : Type u_1} {N : Type u_2} {P : Type u_3} {Q : Type u_4} [_inst_5 : mul_one_class M] [_inst_6 : mul_one_class N] [_inst_7 : comm_monoid P] [_inst_8 : comm_monoid Q] (f : M \u2243* N) (g : P \u2243* Q) (h : M \u2192* P), \u21d1(f.monoid_hom_congr g) h = g.to_monoid_hom.comp (h.comp f.symm.to_monoid_hom)", "decl_nm": "mul_equiv.monoid_hom_congr_apply"}
{"formal_statement": "theorem restrict_scalars_inj (R : Type*) {S M M\u2082 : Type*1} [semiring R]\n\t[semiring S] [add_comm_monoid M] [add_comm_monoid M\u2082] [module R M] [module R M\u2082]\n\t[module S M] [module S M\u2082] [linear_map.compatible_smul M M\u2082 R S] (f\u2097 g\u2097 : M \u2192\u2097[S] M\u2082) :\n\tlinear_map.restrict_scalars R f\u2097 = linear_map.restrict_scalars R g\u2097 \u2194 f\u2097 = g\u2097", "decl_tp": "\u2200 (R : Type u_1) {S : Type u_6} {M : Type u_9} {M\u2082 : Type u_11} [_inst_1 : semiring R] [_inst_2 : semiring S] [_inst_3 : add_comm_monoid M] [_inst_5 : add_comm_monoid M\u2082] [_inst_10 : module R M] [_inst_11 : module R M\u2082] [_inst_13 : module S M] [_inst_14 : module S M\u2082] [_inst_15 : linear_map.compatible_smul M M\u2082 R S] (f\u2097 g\u2097 : M \u2192\u2097[S] M\u2082), linear_map.restrict_scalars R f\u2097 = linear_map.restrict_scalars R g\u2097 \u2194 f\u2097 = g\u2097", "decl_nm": "linear_map.restrict_scalars_inj"}
{"formal_statement": "theorem ord_connected_dual {\u03b1 : Type*} [preorder \u03b1] {s : set \u03b1} :\n\t(\u21d1order_dual.of_dual \u207b\u00b9' s).ord_connected \u2194 s.ord_connected", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : preorder \u03b1] {s : set \u03b1}, (\u21d1order_dual.of_dual \u207b\u00b9' s).ord_connected \u2194 s.ord_connected", "decl_nm": "set.ord_connected_dual"}
{"formal_statement": "theorem differentiable_at_zpow {\ud835\udd5c : Type u} [nondiscrete_normed_field \ud835\udd5c]\n\t{x : \ud835\udd5c} {m : \u2124} :\n\tdifferentiable_at \ud835\udd5c (\u03bb (x : \ud835\udd5c), x ^ m) x \u2194 x \u2260 0 \u2228 0 \u2264 m", "decl_tp": "\u2200 {\ud835\udd5c : Type u} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {x : \ud835\udd5c} {m : \u2124}, differentiable_at \ud835\udd5c (\u03bb (x : \ud835\udd5c), x ^ m) x \u2194 x \u2260 0 \u2228 0 \u2264 m", "decl_nm": "differentiable_at_zpow"}
{"formal_statement": "theorem mul_left_inj {a b c : \u2115} (ha : 0 < a) :\n\t(b * a = c * a \u2194 b = c)", "decl_tp": "\u2200 {a b c : \u2115}, 0 < a \u2192 (b * a = c * a \u2194 b = c)", "decl_nm": "nat.mul_left_inj"}
{"formal_statement": "theorem mk_le_mk_of_comm {C : Type u\u2081} [category_theory.category C] {B A\u2081 A\u2082 : C}\n\t{f\u2081 : A\u2081 \u27f6 B} {f\u2082 : A\u2082 \u27f6 B} [category_theory.mono f\u2081] [category_theory.mono f\u2082]\n\t(g : A\u2081 \u27f6 A\u2082) (w : g \u226b f\u2082 = f\u2081) :\n\tcategory_theory.subobject.mk f\u2081 \u2264 category_theory.subobject.mk f\u2082", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {B A\u2081 A\u2082 : C} {f\u2081 : A\u2081 \u27f6 B} {f\u2082 : A\u2082 \u27f6 B} [_inst_3 : category_theory.mono f\u2081] [_inst_4 : category_theory.mono f\u2082] (g : A\u2081 \u27f6 A\u2082), g \u226b f\u2082 = f\u2081 \u2192 category_theory.subobject.mk f\u2081 \u2264 category_theory.subobject.mk f\u2082", "decl_nm": "category_theory.subobject.mk_le_mk_of_comm"}
{"formal_statement": "theorem sum_C_index {R : Type u} [semiring R] {a : R} {\u03b2 : Type*} [add_comm_monoid \u03b2]\n\t{f : \u2115 \u2192 R \u2192 \u03b2} (h : f 0 0 = 0) :\n\t(\u21d1polynomial.C a).sum f = f 0 a", "decl_tp": "\u2200 {R : Type u} [_inst_1 : semiring R] {a : R} {\u03b2 : Type u_1} [_inst_2 : add_comm_monoid \u03b2] {f : \u2115 \u2192 R \u2192 \u03b2}, f 0 0 = 0 \u2192 (\u21d1polynomial.C a).sum f = f 0 a", "decl_nm": "polynomial.sum_C_index"}
{"formal_statement": "theorem filter_not {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [decidable_pred p] [decidable_eq \u03b1]\n\t[decidable_pred (\u03bb (a : \u03b1), \u00acp a)] (s : finset \u03b1) :\n\tfinset.filter (\u03bb (a : \u03b1), \u00acp a) s = s \\ finset.filter p s", "decl_tp": "\u2200 {\u03b1 : Type u_1} (p : \u03b1 \u2192 Prop) [_inst_1 : decidable_pred p] [_inst_3 : decidable_eq \u03b1] [_inst_4 : decidable_pred (\u03bb (a : \u03b1), \u00acp a)] (s : finset \u03b1), finset.filter (\u03bb (a : \u03b1), \u00acp a) s = s \\ finset.filter p s", "decl_nm": "finset.filter_not"}
{"formal_statement": "theorem find_mem {\u03b1 : Type u} {p : \u03b1 \u2192 Prop} [decidable_pred p] {l : list \u03b1}\n\t{a : \u03b1} (H : list.find p l = option.some a) :\n\ta \u2208 l", "decl_tp": "\u2200 {\u03b1 : Type u} {p : \u03b1 \u2192 Prop} [_inst_1 : decidable_pred p] {l : list \u03b1} {a : \u03b1}, list.find p l = option.some a \u2192 a \u2208 l", "decl_nm": "list.find_mem"}
{"formal_statement": "theorem chain'_singleton {\u03b1 : Type u} {R : \u03b1 \u2192 \u03b1 \u2192 Prop} (a : \u03b1) :\n\tlist.chain' R [a]", "decl_tp": "\u2200 {\u03b1 : Type u} {R : \u03b1 \u2192 \u03b1 \u2192 Prop} (a : \u03b1), list.chain' R [a]", "decl_nm": "list.chain'_singleton"}
{"formal_statement": "theorem vector_allp_cons {\u03b1 : Type*} {n : \u2115} (p : \u03b1 \u2192 Prop) (x : \u03b1) (v : vector3 \u03b1 n) :\n\tvector_allp p (x::v) \u2194 p x \u2227 vector_allp p v", "decl_tp": "\u2200 {\u03b1 : Type u_1} {n : \u2115} (p : \u03b1 \u2192 Prop) (x : \u03b1) (v : vector3 \u03b1 n), vector_allp p (x::v) \u2194 p x \u2227 vector_allp p v", "decl_nm": "vector_allp_cons"}
{"formal_statement": "theorem set_bUnion_option_to_finset {\u03b1 \u03b2 : Type*} (o : option \u03b1) (f : \u03b1 \u2192 set \u03b2) :\n\t(\u22c3 (x : \u03b1) (H : x \u2208 o.to_finset), f x) = \u22c3 (x : \u03b1) (H : x \u2208 o), f x", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} (o : option \u03b1) (f : \u03b1 \u2192 set \u03b2), (\u22c3 (x : \u03b1) (H : x \u2208 o.to_finset), f x) = \u22c3 (x : \u03b1) (H : x \u2208 o), f x", "decl_nm": "finset.set_bUnion_option_to_finset"}
{"formal_statement": "theorem mul_mem {R : Type u} {A : Type v} [comm_semiring R] [semiring A]\n\t[algebra R A] (S : subalgebra R A) {x y : A} (hx : x \u2208 S) (hy : y \u2208 S) :\n\tx * y \u2208 S", "decl_tp": "\u2200 {R : Type u} {A : Type v} [_inst_1 : comm_semiring R] [_inst_2 : semiring A] [_inst_3 : algebra R A] (S : subalgebra R A) {x y : A}, x \u2208 S \u2192 y \u2208 S \u2192 x * y \u2208 S", "decl_nm": "subalgebra.mul_mem"}
{"formal_statement": "theorem restrict_ite {\u03b1 : Type u} {\u03b2 : Type v} (f g : \u03b1 \u2192 \u03b2) (s : set \u03b1)\n\t[\u03a0 (x : \u03b1), decidable (x \u2208 s)] :\n\tset.restrict (\u03bb (a : \u03b1), ite (a \u2208 s) (f a) (g a)) s = set.restrict f s", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} (f g : \u03b1 \u2192 \u03b2) (s : set \u03b1) [_inst_1 : \u03a0 (x : \u03b1), decidable (x \u2208 s)], set.restrict (\u03bb (a : \u03b1), ite (a \u2208 s) (f a) (g a)) s = set.restrict f s", "decl_nm": "set.restrict_ite"}
{"formal_statement": "theorem get_eq_iff_eq_some {a : enat} {ha : a.dom} {b : \u2115} :\n\ta.get ha = b \u2194 a = enat.some b", "decl_tp": "\u2200 {a : enat} {ha : a.dom} {b : \u2115}, a.get ha = b \u2194 a = enat.some b", "decl_nm": "enat.get_eq_iff_eq_some"}
{"formal_statement": "theorem not_ball {\u03b1 : Sort u_1} {p : \u03b1 \u2192 Prop} {P : \u03a0 (x : \u03b1), p x \u2192 Prop} :\n\t(\u00ac\u2200 (x : \u03b1) (h : p x), P x h) \u2194 \u2203 (x : \u03b1) (h : p x), \u00acP x h", "decl_tp": "\u2200 {\u03b1 : Sort u_1} {p : \u03b1 \u2192 Prop} {P : \u03a0 (x : \u03b1), p x \u2192 Prop}, (\u00ac\u2200 (x : \u03b1) (h : p x), P x h) \u2194 \u2203 (x : \u03b1) (h : p x), \u00acP x h", "decl_nm": "not_ball"}
{"formal_statement": "theorem closure_image_subset {\u03b1 \u03b2 : Type*} [topological_space \u03b1] [topological_space \u03b2]\n\t{f : \u03b1 \u2192 \u03b2} (hf : is_closed_map f) :\n\t\u2200 (s : set \u03b1), closure (f '' s) \u2286 f '' closure s", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : topological_space \u03b1] [_inst_2 : topological_space \u03b2] {f : \u03b1 \u2192 \u03b2}, is_closed_map f \u2192 \u2200 (s : set \u03b1), closure (f '' s) \u2286 f '' closure s", "decl_nm": "is_closed_map.closure_image_subset"}
{"formal_statement": "theorem arsinh_sinh (x : \u211d) :\n\treal.arsinh (real.sinh x) = x", "decl_tp": "\u2200 (x : \u211d), real.arsinh (real.sinh x) = x", "decl_nm": "real.arsinh_sinh"}
{"formal_statement": "theorem vadd_set_union {\u03b1 \u03b2 : Type*} {a : \u03b1} [has_vadd \u03b1 \u03b2] {s t : set \u03b2} :\n\ta +\u1d65 (s \u222a t) = a +\u1d65 s \u222a (a +\u1d65 t)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {a : \u03b1} [_inst_1 : has_vadd \u03b1 \u03b2] {s t : set \u03b2}, a +\u1d65 (s \u222a t) = a +\u1d65 s \u222a (a +\u1d65 t)", "decl_nm": "set.vadd_set_union"}
{"formal_statement": "theorem subset_closure {\u03b1 : Type u} [topological_space \u03b1] {s t : set \u03b1}\n\t(H : is_connected s) (Kst : s \u2286 t) (Ktcs : t \u2286 closure s) :\n\tis_connected t", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : topological_space \u03b1] {s t : set \u03b1}, is_connected s \u2192 s \u2286 t \u2192 t \u2286 closure s \u2192 is_connected t", "decl_nm": "is_connected.subset_closure"}
{"formal_statement": "theorem Iio_eq_range :\n\tfinset.Iio = finset.range", "decl_tp": "finset.Iio = finset.range", "decl_nm": "nat.Iio_eq_range"}
{"formal_statement": "theorem map_powers {M : Type*} [monoid M] {N : Type*} [monoid N] (f : M \u2192* N)\n\t(m : M) :\n\tsubmonoid.map f (submonoid.powers m) = submonoid.powers (\u21d1f m)", "decl_tp": "\u2200 {M : Type u_1} [_inst_1 : monoid M] {N : Type u_2} [_inst_2 : monoid N] (f : M \u2192* N) (m : M), submonoid.map f (submonoid.powers m) = submonoid.powers (\u21d1f m)", "decl_nm": "submonoid.map_powers"}
{"formal_statement": "theorem erase_add_single {\u03b1 M : Type*} [add_zero_class M] (a : \u03b1) (f : \u03b1 \u2192\u2080 M) :\n\tfinsupp.erase a f + finsupp.single a (\u21d1f a) = f", "decl_tp": "\u2200 {\u03b1 : Type u_1} {M : Type u_5} [_inst_1 : add_zero_class M] (a : \u03b1) (f : \u03b1 \u2192\u2080 M), finsupp.erase a f + finsupp.single a (\u21d1f a) = f", "decl_nm": "finsupp.erase_add_single"}
{"formal_statement": "theorem generate_has_subset_generate_measurable {\u03b1 : Type*} {C : set (set \u03b1)}\n\t{s : set \u03b1} (hs : (measurable_space.dynkin_system.generate C).has s) :\n\t(measurable_space.generate_from C).measurable_set' s", "decl_tp": "\u2200 {\u03b1 : Type u_1} {C : set (set \u03b1)} {s : set \u03b1}, (measurable_space.dynkin_system.generate C).has s \u2192 (measurable_space.generate_from C).measurable_set' s", "decl_nm": "measurable_space.dynkin_system.generate_has_subset_generate_measurable"}
{"formal_statement": "theorem roots_zero {R : Type u} [comm_ring R] [is_domain R] :\n\t0.roots = 0", "decl_tp": "\u2200 {R : Type u} [_inst_1 : comm_ring R] [_inst_2 : is_domain R], 0.roots = 0", "decl_nm": "polynomial.roots_zero"}
{"formal_statement": "theorem coe_of (X : Type u) [uniform_space X] :\n\t\u21a5(UniformSpace.of X) = X", "decl_tp": "\u2200 (X : Type u) [_inst_1 : uniform_space X], \u21a5(UniformSpace.of X) = X", "decl_nm": "UniformSpace.coe_of"}
{"formal_statement": "theorem is_empty_ring_equiv_symm_apply_to_fun (R : Type u) (\u03c3 : Type*)\n\t[comm_semiring R] [he : is_empty \u03c3] (\u1fb0 : R) (a' : \u03c3 \u2192\u2080 \u2115) :\n\t\u21d1(\u21d1((mv_polynomial.is_empty_ring_equiv R \u03c3).symm) \u1fb0) a' = ite (0 = a') \u1fb0 0", "decl_tp": "\u2200 (R : Type u) (\u03c3 : Type u_1) [_inst_1 : comm_semiring R] [he : is_empty \u03c3] (\u1fb0 : R) (a' : \u03c3 \u2192\u2080 \u2115), \u21d1(\u21d1((mv_polynomial.is_empty_ring_equiv R \u03c3).symm) \u1fb0) a' = ite (0 = a') \u1fb0 0", "decl_nm": "mv_polynomial.is_empty_ring_equiv_symm_apply_to_fun"}
{"formal_statement": "theorem ext_on {R\u2081 R\u2082 : Type*} [semiring R\u2081] [semiring R\u2082] {\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082}\n\t{M\u2081 : Type*} [topological_space M\u2081] [add_comm_monoid M\u2081] {M\u2082 : Type*}\n\t[topological_space M\u2082] [add_comm_monoid M\u2082] [module R\u2081 M\u2081] [module R\u2082 M\u2082]\n\t[t2_space M\u2082] {s : set M\u2081} (hs : dense \u2191(submodule.span R\u2081 s)) (h : set.eq_on \u21d1f \u21d1g s) :\n\t\u2200 {f g : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082},  f = g", "decl_tp": "\u2200 {R\u2081 : Type u_1} {R\u2082 : Type u_2} [_inst_1 : semiring R\u2081] [_inst_2 : semiring R\u2082] {\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082} {M\u2081 : Type u_4} [_inst_4 : topological_space M\u2081] [_inst_5 : add_comm_monoid M\u2081] {M\u2082 : Type u_6} [_inst_8 : topological_space M\u2082] [_inst_9 : add_comm_monoid M\u2082] [_inst_14 : module R\u2081 M\u2081] [_inst_16 : module R\u2082 M\u2082] [_inst_18 : t2_space M\u2082] {s : set M\u2081}, dense \u2191(submodule.span R\u2081 s) \u2192 \u2200 {f g : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082}, set.eq_on \u21d1f \u21d1g s \u2192 f = g", "decl_nm": "continuous_linear_map.ext_on"}
{"formal_statement": "theorem monic (G : Type u) [group G] (F : Type v) [field F] [mul_semiring_action G F]\n\t[fintype G] (x : F) :\n\t(fixed_points.minpoly G F x).monic", "decl_tp": "\u2200 (G : Type u) [_inst_2 : group G] (F : Type v) [_inst_3 : field F] [_inst_5 : mul_semiring_action G F] [_inst_6 : fintype G] (x : F), (fixed_points.minpoly G F x).monic", "decl_nm": "fixed_points.minpoly.monic"}
{"formal_statement": "theorem ite {\u03b1 \u03b2 : Type*} [measurable_space \u03b1] [measurable_space \u03b2] {p : \u03b1 \u2192 Prop}\n\t{_x : decidable_pred p} {f g : \u03b1 \u2192 \u03b2} (hp : measurable_set {a : \u03b1 | p a})\n\t(hf : measurable f) (hg : measurable g) :\n\tmeasurable (\u03bb (x : \u03b1), ite (p x) (f x) (g x))", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : measurable_space \u03b1] [_inst_2 : measurable_space \u03b2] {p : \u03b1 \u2192 Prop} {_x : decidable_pred p} {f g : \u03b1 \u2192 \u03b2}, measurable_set {a : \u03b1 | p a} \u2192 measurable f \u2192 measurable g \u2192 measurable (\u03bb (x : \u03b1), ite (p x) (f x) (g x))", "decl_nm": "measurable.ite"}
{"formal_statement": "theorem times_cont_diff_within_at {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c]\n\t{E : Type*} [normed_group E] [normed_space \ud835\udd5c E] {F : Type*} [normed_group F]\n\t[normed_space \ud835\udd5c F] {s : set E} {f : E \u2192 F} {x : E} {n : with_top \u2115} (h : times_cont_diff \ud835\udd5c n f) :\n\ttimes_cont_diff_within_at \ud835\udd5c n f s x", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {F : Type u_3} [_inst_4 : normed_group F] [_inst_5 : normed_space \ud835\udd5c F] {s : set E} {f : E \u2192 F} {x : E} {n : with_top \u2115}, times_cont_diff \ud835\udd5c n f \u2192 times_cont_diff_within_at \ud835\udd5c n f s x", "decl_nm": "times_cont_diff.times_cont_diff_within_at"}
{"formal_statement": "theorem piecewise_cases {\u03b1 : Type*} {\u03b4 : \u03b1 \u2192 Sort u_4} (s : finset \u03b1) (f g : \u03a0 (i : \u03b1), \u03b4 i)\n\t[\u03a0 (j : \u03b1), decidable (j \u2208 s)] {i : \u03b1} (p : \u03b4 i \u2192 Prop) (hf : p (f i))\n\t(hg : p (g i)) :\n\tp (s.piecewise f g i)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b4 : \u03b1 \u2192 Sort u_4} (s : finset \u03b1) (f g : \u03a0 (i : \u03b1), \u03b4 i) [_inst_1 : \u03a0 (j : \u03b1), decidable (j \u2208 s)] {i : \u03b1} (p : \u03b4 i \u2192 Prop), p (f i) \u2192 p (g i) \u2192 p (s.piecewise f g i)", "decl_nm": "finset.piecewise_cases"}
{"formal_statement": "theorem Ioo {\u03b1 \u03b2 : Type*} [preorder \u03b1] [preorder \u03b2] {f g : \u03b1 \u2192 \u03b2} (hf : antitone f)\n\t(hg : monotone g) :\n\tmonotone (\u03bb (x : \u03b1), set.Ioo (f x) (g x))", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : preorder \u03b1] [_inst_2 : preorder \u03b2] {f g : \u03b1 \u2192 \u03b2}, antitone f \u2192 monotone g \u2192 monotone (\u03bb (x : \u03b1), set.Ioo (f x) (g x))", "decl_nm": "antitone.Ioo"}
{"formal_statement": "theorem whiskering_obj_2 (C : Type u) [category_theory.category C] (D : Type*)\n\t[category_theory.category D] (F : C \u2964 D) :\n\t(category_theory.simplicial_object.augmented.whiskering C D).obj F = category_theory.simplicial_object.augmented.whiskering_obj C D F", "decl_tp": "\u2200 (C : Type u) [_inst_1 : category_theory.category C] (D : Type u_1) [_inst_2 : category_theory.category D] (F : C \u2964 D), (category_theory.simplicial_object.augmented.whiskering C D).obj F = category_theory.simplicial_object.augmented.whiskering_obj C D F", "decl_nm": "category_theory.simplicial_object.augmented.whiskering_obj_2"}
{"formal_statement": "theorem add_comm {G : Type u} [add_comm_semigroup G] (a b : G) :\n\ta + b = b + a", "decl_tp": "\u2200 {G : Type u} [_inst_1 : add_comm_semigroup G] (a b : G), a + b = b + a", "decl_nm": "add_comm"}
{"formal_statement": "theorem local_triv_at_apply {R B F : Type*} [semiring R] [topological_space F]\n\t[add_comm_monoid F] [module R F] [topological_space B] {\u03b9 : Type*} (Z : topological_vector_bundle_core R B F \u03b9)\n\t(b : B) (a : F) :\n\t\u21d1(Z.local_triv_at b) \u27e8b, a\u27e9 = (b, a)", "decl_tp": "\u2200 {R : Type u_1} {B : Type u_2} {F : Type u_3} [_inst_1 : semiring R] [_inst_4 : topological_space F] [_inst_5 : add_comm_monoid F] [_inst_6 : module R F] [_inst_8 : topological_space B] {\u03b9 : Type u_5} (Z : topological_vector_bundle_core R B F \u03b9) (b : B) (a : F), \u21d1(Z.local_triv_at b) \u27e8b, a\u27e9 = (b, a)", "decl_nm": "topological_vector_bundle_core.local_triv_at_apply"}
{"formal_statement": "theorem unop_add {\u03b1 : Type u} [has_add \u03b1] (x y : \u03b1\u1d50\u1d52\u1d56) :\n\tmul_opposite.unop (x + y) = mul_opposite.unop x + mul_opposite.unop y", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : has_add \u03b1] (x y : \u03b1\u1d50\u1d52\u1d56), mul_opposite.unop (x + y) = mul_opposite.unop x + mul_opposite.unop y", "decl_nm": "mul_opposite.unop_add"}
{"formal_statement": "theorem edist_le_zero {\u03b3 : Type w} [emetric_space \u03b3] {x y : \u03b3} :\n\thas_edist.edist x y \u2264 0 \u2194 x = y", "decl_tp": "\u2200 {\u03b3 : Type w} [_inst_2 : emetric_space \u03b3] {x y : \u03b3}, has_edist.edist x y \u2264 0 \u2194 x = y", "decl_nm": "edist_le_zero"}
{"formal_statement": "theorem card_image_of_injective {\u03b1 \u03b2 : Type*} {f : \u03b1 \u2192 \u03b2} [decidable_eq \u03b2]\n\t(s : finset \u03b1) (H : function.injective f) :\n\t(finset.image f s).card = s.card", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {f : \u03b1 \u2192 \u03b2} [_inst_1 : decidable_eq \u03b2] (s : finset \u03b1), function.injective f \u2192 (finset.image f s).card = s.card", "decl_nm": "finset.card_image_of_injective"}
{"formal_statement": "theorem coe_nat_val {d : \u2124} (n : \u2115) :\n\t\u2191n = {re := \u2191n, im := 0}", "decl_tp": "\u2200 {d : \u2124} (n : \u2115), \u2191n = {re := \u2191n, im := 0}", "decl_nm": "zsqrtd.coe_nat_val"}
{"formal_statement": "theorem disjoint_right_iff {\u03b1 : Type u} [distrib_lattice \u03b1] [bounded_order \u03b1]\n\t{x y z : \u03b1} (h : is_compl y z) :\n\t(disjoint x z \u2194 x \u2264 y)", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : distrib_lattice \u03b1] [_inst_2 : bounded_order \u03b1] {x y z : \u03b1}, is_compl y z \u2192 (disjoint x z \u2194 x \u2264 y)", "decl_nm": "is_compl.disjoint_right_iff"}
{"formal_statement": "theorem integral_condexp {\u03b1 F' : Type*} [normed_group F'] [measurable_space F']\n\t[borel_space F'] [topological_space.second_countable_topology F'] [normed_space \u211d F']\n\t[complete_space F'] {m m0 : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1}\n\t{hm : m \u2264 m0} [measure_theory.sigma_finite (\u03bc.trim hm)] {f : \u03b1 \u2192 F'} (hf : measure_theory.integrable f \u03bc) :\n\t\u222b (x : \u03b1), measure_theory.condexp m hm \u03bc f x \u2202\u03bc = \u222b (x : \u03b1), f x \u2202\u03bc", "decl_tp": "\u2200 {\u03b1 : Type u_1} {F' : Type u_7} [_inst_18 : normed_group F'] [_inst_20 : measurable_space F'] [_inst_21 : borel_space F'] [_inst_22 : topological_space.second_countable_topology F'] [_inst_23 : normed_space \u211d F'] [_inst_24 : complete_space F'] {m m0 : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} {hm : m \u2264 m0} [_inst_37 : measure_theory.sigma_finite (\u03bc.trim hm)] {f : \u03b1 \u2192 F'}, measure_theory.integrable f \u03bc \u2192 \u222b (x : \u03b1), measure_theory.condexp m hm \u03bc f x \u2202\u03bc = \u222b (x : \u03b1), f x \u2202\u03bc", "decl_nm": "measure_theory.integral_condexp"}
{"formal_statement": "theorem bounded_image {\u03b1 : Type u} {\u03b2 : Type v} [topological_space \u03b1] [metric_space \u03b2]\n\t(f : bounded_continuous_function \u03b1 \u03b2) (s : set \u03b1) :\n\tmetric.bounded (\u21d1f '' s)", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : topological_space \u03b1] [_inst_2 : metric_space \u03b2] (f : bounded_continuous_function \u03b1 \u03b2) (s : set \u03b1), metric.bounded (\u21d1f '' s)", "decl_nm": "bounded_continuous_function.bounded_image"}
{"formal_statement": "theorem op_inv {C : Type u\u2081} [category_theory.category C] {X Y : C} (\u03b1 : X \u2245 Y) :\n\t\u03b1.op.inv = \u03b1.inv.op", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {X Y : C} (\u03b1 : X \u2245 Y), \u03b1.op.inv = \u03b1.inv.op", "decl_nm": "category_theory.iso.op_inv"}
{"formal_statement": "theorem subtype_coe {\u03b1 : Type*} [pseudo_emetric_space \u03b1] (s : set \u03b1) :\n\tantilipschitz_with 1 coe", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : pseudo_emetric_space \u03b1] (s : set \u03b1), antilipschitz_with 1 coe", "decl_nm": "antilipschitz_with.subtype_coe"}
{"formal_statement": "theorem extend_apply_coe {X : Type u} {Y : Type v} [topological_space X]\n\t[topological_space Y] {f\u2080 f\u2081 : C(X, Y)} (F : f\u2080.homotopy f\u2081) (t : \u21a5unit_interval)\n\t(x : X) :\n\t\u21d1(\u21d1(F.extend) \u2191t) x = \u21d1F (t, x)", "decl_tp": "\u2200 {X : Type u} {Y : Type v} [_inst_1 : topological_space X] [_inst_2 : topological_space Y] {f\u2080 f\u2081 : C(X, Y)} (F : f\u2080.homotopy f\u2081) (t : \u21a5unit_interval) (x : X), \u21d1(\u21d1(F.extend) \u2191t) x = \u21d1F (t, x)", "decl_nm": "continuous_map.homotopy.extend_apply_coe"}
{"formal_statement": "theorem associator_map_inl_inr (C : Type u) [category_theory.category C]\n\t(D : Type u) [category_theory.category D] (E : Type u) [category_theory.category E]\n\t{X Y : D} (f : sum.inl (sum.inr X) \u27f6 sum.inl (sum.inr Y)) :\n\t(category_theory.sum.associator C D E).map f = f", "decl_tp": "\u2200 (C : Type u) [_inst_1 : category_theory.category C] (D : Type u) [_inst_2 : category_theory.category D] (E : Type u) [_inst_3 : category_theory.category E] {X Y : D} (f : sum.inl (sum.inr X) \u27f6 sum.inl (sum.inr Y)), (category_theory.sum.associator C D E).map f = f", "decl_nm": "category_theory.sum.associator_map_inl_inr"}
{"formal_statement": "theorem pi_update_of_not_mem {\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} {\u03b2 : \u03b9 \u2192 Type*}\n\t{s : set \u03b9} {i : \u03b9} [decidable_eq \u03b9] (hi : i \u2209 s) (f : \u03a0 (j : \u03b9), \u03b1 j) :\n\t\u2200 (f : \u03a0 (j : \u03b9), \u03b1 j) (a : \u03b1 i) (t :  set (\u03b2 j)), s.pi (\u03bb (j : \u03b9), t j (function.update f i a j)) = s.pi (\u03bb (j : \u03b9), t j (f j))", "decl_tp": "\u2200 {\u03b9 : Type u_1} {\u03b1 : \u03b9 \u2192 Type u_2} {\u03b2 : \u03b9 \u2192 Type u_3} {s : set \u03b9} {i : \u03b9} [_inst_1 : decidable_eq \u03b9], i \u2209 s \u2192 \u2200 (f : \u03a0 (j : \u03b9), \u03b1 j) (a : \u03b1 i) (t : \u03a0 (j : \u03b9), \u03b1 j \u2192 set (\u03b2 j)), s.pi (\u03bb (j : \u03b9), t j (function.update f i a j)) = s.pi (\u03bb (j : \u03b9), t j (f j))", "decl_nm": "set.pi_update_of_not_mem"}
{"formal_statement": "theorem comp_monotone {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} [preorder \u03b1]\n\t[preorder \u03b2] [preorder \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2} (hg : antitone g) (hf : monotone f) :\n\tantitone (g \u2218 f)", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} [_inst_1 : preorder \u03b1] [_inst_2 : preorder \u03b2] [_inst_3 : preorder \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}, antitone g \u2192 monotone f \u2192 antitone (g \u2218 f)", "decl_nm": "antitone.comp_monotone"}
{"formal_statement": "theorem interval_subset_interval_union_interval {\u03b1 : Type u} [linear_order \u03b1]\n\t{a b c : \u03b1} :\n\tset.interval a c \u2286 set.interval a b \u222a set.interval b c", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : linear_order \u03b1] {a b c : \u03b1}, set.interval a c \u2286 set.interval a b \u222a set.interval b c", "decl_nm": "set.interval_subset_interval_union_interval"}
{"formal_statement": "theorem forall_2_true_iff {\u03b1 : Sort u_1} {\u03b2 : \u03b1 \u2192 Sort u_2} :\n\t(\u2200 (a : \u03b1), \u03b2 a \u2192 true) \u2194 true", "decl_tp": "\u2200 {\u03b1 : Sort u_1} {\u03b2 : \u03b1 \u2192 Sort u_2}, (\u2200 (a : \u03b1), \u03b2 a \u2192 true) \u2194 true", "decl_nm": "forall_2_true_iff"}
{"formal_statement": "theorem clog_of_left_le_one {b : \u2115} (hb : b \u2264 1) :\n\t\u2200 (n : \u2115), nat.clog b n = 0", "decl_tp": "\u2200 {b : \u2115}, b \u2264 1 \u2192 \u2200 (n : \u2115), nat.clog b n = 0", "decl_nm": "nat.clog_of_left_le_one"}
{"formal_statement": "theorem Ioc_union_Ioc_left {\u03b1 : Type u} [linear_order \u03b1] {a b c : \u03b1} :\n\tset.Ioc a c \u222a set.Ioc b c = set.Ioc (linear_order.min a b) c", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : linear_order \u03b1] {a b c : \u03b1}, set.Ioc a c \u222a set.Ioc b c = set.Ioc (linear_order.min a b) c", "decl_nm": "set.Ioc_union_Ioc_left"}
{"formal_statement": "theorem intermediate_value_Iio {X : Type u} {\u03b1 : Type v} [topological_space X]\n\t[linear_order \u03b1] [topological_space \u03b1] [order_closed_topology \u03b1] {s : set X}\n\t(hs : is_preconnected s) (hl\u2081 : l\u2081 \u2264 filter.principal s) (hl\u2082 : l\u2082 \u2264 filter.principal s)\n\t(hf : continuous_on f s) (ht\u2081 : filter.tendsto f l\u2081 filter.at_bot) (ht\u2082 : filter.tendsto f l\u2082 (nhds v)) :\n\t\u2200 {l\u2081 l\u2082 : filter X} [l\u2081.ne_bot] [l\u2082.ne_bot],   \u2200 {f : X \u2192 \u03b1},  \u2200 {v : \u03b1},   set.Iio v \u2286 f '' s", "decl_tp": "\u2200 {X : Type u} {\u03b1 : Type v} [_inst_1 : topological_space X] [_inst_2 : linear_order \u03b1] [_inst_3 : topological_space \u03b1] [_inst_4 : order_closed_topology \u03b1] {s : set X}, is_preconnected s \u2192 \u2200 {l\u2081 l\u2082 : filter X} [_inst_5 : l\u2081.ne_bot] [_inst_6 : l\u2082.ne_bot], l\u2081 \u2264 filter.principal s \u2192 l\u2082 \u2264 filter.principal s \u2192 \u2200 {f : X \u2192 \u03b1}, continuous_on f s \u2192 \u2200 {v : \u03b1}, filter.tendsto f l\u2081 filter.at_bot \u2192 filter.tendsto f l\u2082 (nhds v) \u2192 set.Iio v \u2286 f '' s", "decl_nm": "is_preconnected.intermediate_value_Iio"}
{"formal_statement": "theorem last_cases_last {n : \u2115} {C : fin (n + 1) \u2192 Sort u_1} (hlast : C (fin.last n))\n\t(hcast : \u03a0 (i : fin n), C (\u21d1fin.cast_succ i)) :\n\tfin.last_cases hlast hcast (fin.last n) = hlast", "decl_tp": "\u2200 {n : \u2115} {C : fin (n + 1) \u2192 Sort u_1} (hlast : C (fin.last n)) (hcast : \u03a0 (i : fin n), C (\u21d1fin.cast_succ i)), fin.last_cases hlast hcast (fin.last n) = hlast", "decl_nm": "fin.last_cases_last"}
{"formal_statement": "theorem cocones_equiv_counit_iso {C : Type v} [category_theory.small_category C]\n\t{D : Type v} [category_theory.small_category D] (F : C \u2964 D) [F.final]\n\t{E : Type u} [category_theory.category E] (G : D \u2964 E) :\n\t(category_theory.functor.final.cocones_equiv F G).counit_iso = category_theory.nat_iso.of_components (\u03bb (c : category_theory.limits.cocone G), category_theory.limits.cocones.ext (category_theory.iso.refl ((category_theory.limits.cocones.whiskering F \u22d9 category_theory.functor.final.extend_cocone).obj c).X) _) _", "decl_tp": "\u2200 {C : Type v} [_inst_1 : category_theory.small_category C] {D : Type v} [_inst_2 : category_theory.small_category D] (F : C \u2964 D) [_inst_3 : F.final] {E : Type u} [_inst_4 : category_theory.category E] (G : D \u2964 E), (category_theory.functor.final.cocones_equiv F G).counit_iso = category_theory.nat_iso.of_components (\u03bb (c : category_theory.limits.cocone G), category_theory.limits.cocones.ext (category_theory.iso.refl ((category_theory.limits.cocones.whiskering F \u22d9 category_theory.functor.final.extend_cocone).obj c).X) _) _", "decl_nm": "category_theory.functor.final.cocones_equiv_counit_iso"}
{"formal_statement": "theorem of_quotient_map_compose {\u03b1 \u03b2 \u03b3 : Type*} [topological_space \u03b1] [topological_space \u03b2]\n\t[topological_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2} (hf : continuous f) (hg : continuous g)\n\t(hgf : quotient_map (g \u2218 f)) :\n\tquotient_map g", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {\u03b3 : Type u_3} [_inst_1 : topological_space \u03b1] [_inst_2 : topological_space \u03b2] [_inst_3 : topological_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}, continuous f \u2192 continuous g \u2192 quotient_map (g \u2218 f) \u2192 quotient_map g", "decl_nm": "quotient_map.of_quotient_map_compose"}
{"formal_statement": "theorem map_eq_iff {\ud835\udd5c V V\u2082 P P\u2082 : Type*} [normed_field \ud835\udd5c] [semi_normed_group V]\n\t[semi_normed_group V\u2082] [semi_normed_space \ud835\udd5c V] [semi_normed_space \ud835\udd5c V\u2082]\n\t[pseudo_metric_space P] [pseudo_metric_space P\u2082] [semi_normed_add_torsor V P]\n\t[semi_normed_add_torsor V\u2082 P\u2082] (e : P \u2243\u1d43\u2071[\ud835\udd5c] P\u2082) {x y : P} :\n\t\u21d1e x = \u21d1e y \u2194 x = y", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} {V : Type u_2} {V\u2082 : Type u_4} {P : Type u_8} {P\u2082 : Type u_9} [_inst_1 : normed_field \ud835\udd5c] [_inst_2 : semi_normed_group V] [_inst_4 : semi_normed_group V\u2082] [_inst_7 : semi_normed_space \ud835\udd5c V] [_inst_9 : semi_normed_space \ud835\udd5c V\u2082] [_inst_12 : pseudo_metric_space P] [_inst_14 : pseudo_metric_space P\u2082] [_inst_17 : semi_normed_add_torsor V P] [_inst_19 : semi_normed_add_torsor V\u2082 P\u2082] (e : P \u2243\u1d43\u2071[\ud835\udd5c] P\u2082) {x y : P}, \u21d1e x = \u21d1e y \u2194 x = y", "decl_nm": "affine_isometry_equiv.map_eq_iff"}
{"formal_statement": "theorem norm_eq {\u03b9 : Type*} [fintype \u03b9] {p : \u211d} [fact (1 \u2264 p)] {\u03b2 : \u03b9 \u2192 Type*}\n\t[\u03a0 (i : \u03b9), semi_normed_group (\u03b2 i)] (f : pi_Lp p \u03b2) :\n\t\u2225f\u2225 = finset.univ.sum (\u03bb (i : \u03b9), \u2225f i\u2225 ^ p) ^ (1 / p)", "decl_tp": "\u2200 {\u03b9 : Type u_1} [_inst_1 : fintype \u03b9] {p : \u211d} [_inst_2 : fact (1 \u2264 p)] {\u03b2 : \u03b9 \u2192 Type u_2} [_inst_3 : \u03a0 (i : \u03b9), semi_normed_group (\u03b2 i)] (f : pi_Lp p \u03b2), \u2225f\u2225 = finset.univ.sum (\u03bb (i : \u03b9), \u2225f i\u2225 ^ p) ^ (1 / p)", "decl_nm": "pi_Lp.norm_eq"}
{"formal_statement": "theorem multiset_prod_mem {K L : Type*} [field K] [field L] [algebra K L]\n\t(S : intermediate_field K L) (m : multiset L) :\n\t(\u2200 (a : L), a \u2208 m \u2192 a \u2208 S) \u2192 m.prod \u2208 S", "decl_tp": "\u2200 {K : Type u_1} {L : Type u_2} [_inst_1 : field K] [_inst_2 : field L] [_inst_3 : algebra K L] (S : intermediate_field K L) (m : multiset L), (\u2200 (a : L), a \u2208 m \u2192 a \u2208 S) \u2192 m.prod \u2208 S", "decl_nm": "intermediate_field.multiset_prod_mem"}
{"formal_statement": "theorem cast_zero' {\u03b1 : Type*} [has_zero \u03b1] [has_one \u03b1] [has_add \u03b1] :\n\t\u2191num.zero = 0", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : has_zero \u03b1] [_inst_2 : has_one \u03b1] [_inst_3 : has_add \u03b1], \u2191num.zero = 0", "decl_nm": "num.cast_zero'"}
{"formal_statement": "theorem inv_le_of_inv_le' {\u03b1 : Type u} [group \u03b1] [has_le \u03b1] [covariant_class \u03b1 \u03b1 has_mul.mul has_le.le]\n\t[covariant_class \u03b1 \u03b1 (function.swap has_mul.mul) has_le.le] {a b : \u03b1} :\n\ta\u207b\u00b9 \u2264 b \u2192 b\u207b\u00b9 \u2264 a", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : group \u03b1] [_inst_2 : has_le \u03b1] [_inst_3 : covariant_class \u03b1 \u03b1 has_mul.mul has_le.le] [_inst_4 : covariant_class \u03b1 \u03b1 (function.swap has_mul.mul) has_le.le] {a b : \u03b1}, a\u207b\u00b9 \u2264 b \u2192 b\u207b\u00b9 \u2264 a", "decl_nm": "inv_le_of_inv_le'"}
{"formal_statement": "theorem subtype_preimage_symm_apply_coe_pos {\u03b1 : Sort u} {\u03b2 : Sort v} (p : \u03b1 \u2192 Prop)\n\t[decidable_pred p] (x\u2080 : {a // p a} \u2192 \u03b2) (x : {a // \u00acp a} \u2192 \u03b2) (a : \u03b1)\n\t(h : p a) :\n\t\u2191(\u21d1((equiv.subtype_preimage p x\u2080).symm) x) a = x\u2080 \u27e8a, h\u27e9", "decl_tp": "\u2200 {\u03b1 : Sort u} {\u03b2 : Sort v} (p : \u03b1 \u2192 Prop) [_inst_1 : decidable_pred p] (x\u2080 : {a // p a} \u2192 \u03b2) (x : {a // \u00acp a} \u2192 \u03b2) (a : \u03b1) (h : p a), \u2191(\u21d1((equiv.subtype_preimage p x\u2080).symm) x) a = x\u2080 \u27e8a, h\u27e9", "decl_nm": "equiv.subtype_preimage_symm_apply_coe_pos"}
{"formal_statement": "theorem coe_to_homeomorph {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c] {E : Type*}\n\t[normed_group E] [normed_space \ud835\udd5c E] {F : Type*} [normed_group F] [normed_space \ud835\udd5c F]\n\t{H : Type*} [topological_space H] {G : Type*} [topological_space G] {I : model_with_corners \ud835\udd5c E H}\n\t{J : model_with_corners \ud835\udd5c F G} {M : Type*} [topological_space M] [charted_space H M]\n\t{N : Type*0} [topological_space N] [charted_space G N] {n : with_top \u2115}\n\t(h : diffeomorph I J M N n) :\n\t\u21d1(h.to_homeomorph) = \u21d1h", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {F : Type u_4} [_inst_6 : normed_group F] [_inst_7 : normed_space \ud835\udd5c F] {H : Type u_5} [_inst_8 : topological_space H] {G : Type u_7} [_inst_10 : topological_space G] {I : model_with_corners \ud835\udd5c E H} {J : model_with_corners \ud835\udd5c F G} {M : Type u_8} [_inst_11 : topological_space M] [_inst_12 : charted_space H M] {N : Type u_10} [_inst_15 : topological_space N] [_inst_16 : charted_space G N] {n : with_top \u2115} (h : diffeomorph I J M N n), \u21d1(h.to_homeomorph) = \u21d1h", "decl_nm": "diffeomorph.coe_to_homeomorph"}
{"formal_statement": "theorem lower_equivalence_functor {C : Type u\u2081} [category_theory.category C]\n\t{D : Type u\u2082} [category_theory.category D] {A : C} {B : D} (e : category_theory.mono_over A \u224c category_theory.mono_over B) :\n\t(category_theory.subobject.lower_equivalence e).functor = category_theory.subobject.lower e.functor", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {D : Type u\u2082} [_inst_2 : category_theory.category D] {A : C} {B : D} (e : category_theory.mono_over A \u224c category_theory.mono_over B), (category_theory.subobject.lower_equivalence e).functor = category_theory.subobject.lower e.functor", "decl_nm": "category_theory.subobject.lower_equivalence_functor"}
{"formal_statement": "theorem smooth_const {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c] {E : Type*}\n\t[normed_group E] [normed_space \ud835\udd5c E] {H : Type*} [topological_space H]\n\t{I : model_with_corners \ud835\udd5c E H} {M : Type*} [topological_space M] [charted_space H M]\n\t{E' : Type*} [normed_group E'] [normed_space \ud835\udd5c E'] {H' : Type*} [topological_space H']\n\t{I' : model_with_corners \ud835\udd5c E' H'} {M' : Type*} [topological_space M']\n\t[charted_space H' M'] {c : M'} :\n\tsmooth I I' (\u03bb (x : M), c)", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {H : Type u_3} [_inst_4 : topological_space H] {I : model_with_corners \ud835\udd5c E H} {M : Type u_4} [_inst_5 : topological_space M] [_inst_6 : charted_space H M] {E' : Type u_5} [_inst_7 : normed_group E'] [_inst_8 : normed_space \ud835\udd5c E'] {H' : Type u_6} [_inst_9 : topological_space H'] {I' : model_with_corners \ud835\udd5c E' H'} {M' : Type u_7} [_inst_10 : topological_space M'] [_inst_11 : charted_space H' M'] {c : M'}, smooth I I' (\u03bb (x : M), c)", "decl_nm": "smooth_const"}
{"formal_statement": "theorem val_min_abs_def_pos {n : \u2115} [fact (0 < n)] (x : zmod n) :\n\tx.val_min_abs = ite (x.val \u2264 n / 2) \u2191(x.val) (\u2191(x.val) - \u2191n)", "decl_tp": "\u2200 {n : \u2115} [_inst_1 : fact (0 < n)] (x : zmod n), x.val_min_abs = ite (x.val \u2264 n / 2) \u2191(x.val) (\u2191(x.val) - \u2191n)", "decl_nm": "zmod.val_min_abs_def_pos"}
{"formal_statement": "theorem gcd_dvd_gcd_mul_right_right (m n k : \u2115) :\n\tm.gcd n \u2223 m.gcd (n * k)", "decl_tp": "\u2200 (m n k : \u2115), m.gcd n \u2223 m.gcd (n * k)", "decl_nm": "nat.gcd_dvd_gcd_mul_right_right"}
{"formal_statement": "theorem map_hom_comp {\u03b1 : Type u} {\u03b2 : Type v} [monoid \u03b1] [monoid \u03b2] (f : \u03b1 \u2192* \u03b2)\n\t{\u03b3 : Type w} [monoid \u03b3] (g : \u03b2 \u2192* \u03b3) :\n\t\u21d1(category_theory.single_obj.map_hom \u03b1 \u03b3) (g.comp f) = \u21d1(category_theory.single_obj.map_hom \u03b1 \u03b2) f \u22d9 \u21d1(category_theory.single_obj.map_hom \u03b2 \u03b3) g", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : monoid \u03b1] [_inst_2 : monoid \u03b2] (f : \u03b1 \u2192* \u03b2) {\u03b3 : Type w} [_inst_3 : monoid \u03b3] (g : \u03b2 \u2192* \u03b3), \u21d1(category_theory.single_obj.map_hom \u03b1 \u03b3) (g.comp f) = \u21d1(category_theory.single_obj.map_hom \u03b1 \u03b2) f \u22d9 \u21d1(category_theory.single_obj.map_hom \u03b2 \u03b3) g", "decl_nm": "category_theory.single_obj.map_hom_comp"}
{"formal_statement": "theorem top_mem_closed {\u03b1 : Type*} [partial_order \u03b1] [order_top \u03b1] (c : closure_operator \u03b1) :\n\t\u22a4 \u2208 c.closed", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : partial_order \u03b1] [_inst_2 : order_top \u03b1] (c : closure_operator \u03b1), \u22a4 \u2208 c.closed", "decl_nm": "closure_operator.top_mem_closed"}
{"formal_statement": "theorem ext_iff {\u03b1 : Type u} (x y : has_le \u03b1) :\n\tx = y \u2194 has_le.le = has_le.le", "decl_tp": "\u2200 {\u03b1 : Type u} (x y : has_le \u03b1), x = y \u2194 has_le.le = has_le.le", "decl_nm": "has_le.ext_iff"}
{"formal_statement": "theorem fst_Y {C : Type u} [category_theory.category C] {X : C} {J : category_theory.grothendieck_topology C}\n\t{S : J.cover X} (I : S.relation) :\n\tI.fst.Y = I.Y\u2081", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] {X : C} {J : category_theory.grothendieck_topology C} {S : J.cover X} (I : S.relation), I.fst.Y = I.Y\u2081", "decl_nm": "category_theory.grothendieck_topology.cover.relation.fst_Y"}
{"formal_statement": "theorem eq_of_mem_of_mem {\u03b1 : Type*} {a : \u03b1} {o1 o2 : option \u03b1} (h1 : a \u2208 o1)\n\t(h2 : a \u2208 o2) :\n\to1 = o2", "decl_tp": "\u2200 {\u03b1 : Type u_1} {a : \u03b1} {o1 o2 : option \u03b1}, a \u2208 o1 \u2192 a \u2208 o2 \u2192 o1 = o2", "decl_nm": "option.eq_of_mem_of_mem"}
{"formal_statement": "theorem left_neg_left_neg_eq {M : Type*} [add_monoid M] (S : add_submonoid M)\n\t(S : add_submonoid M) :\n\tS \u2264 is_add_unit. S.left_neg.left_neg = S", "decl_tp": "\u2200 {M : Type u_1} [_inst_1 : add_monoid M] (S : add_submonoid M), S \u2264 is_add_unit.add_submonoid M \u2192 S.left_neg.left_neg = S", "decl_nm": "add_submonoid.left_neg_left_neg_eq"}
{"formal_statement": "theorem map_zero {M N : Type*} [add_zero_class M] [add_zero_class N] (f : M \u2192+ N) :\n\t\u21d1f 0 = 0", "decl_tp": "\u2200 {M : Type u_1} {N : Type u_2} [_inst_1 : add_zero_class M] [_inst_2 : add_zero_class N] (f : M \u2192+ N), \u21d1f 0 = 0", "decl_nm": "add_monoid_hom.map_zero"}
{"formal_statement": "theorem rec_iff {\u03b1 : Type*} [preorder \u03b1] [pred_order \u03b1] [is_pred_archimedean \u03b1]\n\t{p : \u03b1 \u2192 Prop} (h : a \u2264 b) :\n\t(\u2200 (a : \u03b1), p a \u2194 p (pred_order.pred a)) \u2192 \u2200 {a b : \u03b1},  (p a \u2194 p b)", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : preorder \u03b1] [_inst_2 : pred_order \u03b1] [_inst_3 : is_pred_archimedean \u03b1] {p : \u03b1 \u2192 Prop}, (\u2200 (a : \u03b1), p a \u2194 p (pred_order.pred a)) \u2192 \u2200 {a b : \u03b1}, a \u2264 b \u2192 (p a \u2194 p b)", "decl_nm": "pred.rec_iff"}
{"formal_statement": "theorem prod_equiv_apply {R : Type*} [semiring R] {M : Type*} [topological_space M]\n\t[add_comm_monoid M] [module R M] {N\u2082 : Type*} [topological_space N\u2082] [add_comm_monoid N\u2082]\n\t[module R N\u2082] {N\u2083 : Type*0} [topological_space N\u2083] [add_comm_monoid N\u2083]\n\t[module R N\u2083] (f : (M \u2192L[R] N\u2082) \u00d7 (M \u2192L[R] N\u2083)) :\n\t\u21d1continuous_linear_map.prod_equiv f = f.fst.prod f.snd", "decl_tp": "\u2200 {R : Type u_1} [_inst_1 : semiring R] {M : Type u_6} [_inst_8 : topological_space M] [_inst_9 : add_comm_monoid M] [_inst_10 : module R M] {N\u2082 : Type u_9} [_inst_17 : topological_space N\u2082] [_inst_18 : add_comm_monoid N\u2082] [_inst_19 : module R N\u2082] {N\u2083 : Type u_10} [_inst_20 : topological_space N\u2083] [_inst_21 : add_comm_monoid N\u2083] [_inst_22 : module R N\u2083] (f : (M \u2192L[R] N\u2082) \u00d7 (M \u2192L[R] N\u2083)), \u21d1continuous_linear_map.prod_equiv f = f.fst.prod f.snd", "decl_nm": "continuous_linear_map.prod_equiv_apply"}
{"formal_statement": "theorem map_id {L : first_order.language} {M : Type*} [L.Structure M] (S : L.substructure M) :\n\tfirst_order.language.substructure.map (first_order.language.hom.id L M) S = S", "decl_tp": "\u2200 {L : first_order.language} {M : Type u_3} [_inst_1 : L.Structure M] (S : L.substructure M), first_order.language.substructure.map (first_order.language.hom.id L M) S = S", "decl_nm": "first_order.language.substructure.map_id"}
{"formal_statement": "theorem cones_equiv_functor {C : Type v} [category_theory.small_category C]\n\t{D : Type v} [category_theory.small_category D] (F : C \u2964 D) [F.initial]\n\t{E : Type u} [category_theory.category E] (G : D \u2964 E) :\n\t(category_theory.functor.initial.cones_equiv F G).functor = category_theory.functor.initial.extend_cone", "decl_tp": "\u2200 {C : Type v} [_inst_1 : category_theory.small_category C] {D : Type v} [_inst_2 : category_theory.small_category D] (F : C \u2964 D) [_inst_3 : F.initial] {E : Type u} [_inst_4 : category_theory.category E] (G : D \u2964 E), (category_theory.functor.initial.cones_equiv F G).functor = category_theory.functor.initial.extend_cone", "decl_nm": "category_theory.functor.initial.cones_equiv_functor"}
{"formal_statement": "theorem compl_Iio {\u03b1 : Type u} [linear_order \u03b1] {a : \u03b1} :\n\t(set.Iio a)\u1d9c = set.Ici a", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : linear_order \u03b1] {a : \u03b1}, (set.Iio a)\u1d9c = set.Ici a", "decl_nm": "set.compl_Iio"}
{"formal_statement": "theorem filter_erase {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [decidable_pred p] [decidable_eq \u03b1]\n\t(a : \u03b1) (s : finset \u03b1) :\n\tfinset.filter p (s.erase a) = (finset.filter p s).erase a", "decl_tp": "\u2200 {\u03b1 : Type u_1} (p : \u03b1 \u2192 Prop) [_inst_1 : decidable_pred p] [_inst_3 : decidable_eq \u03b1] (a : \u03b1) (s : finset \u03b1), finset.filter p (s.erase a) = (finset.filter p s).erase a", "decl_nm": "finset.filter_erase"}
{"formal_statement": "theorem tendsto_const {\u03b1 \u03b2 : Type*} [normed_group \u03b2] {u : \u03b1 \u2192 \u03b2} {l : filter \u03b1}\n\t{c : \u03b2} (hu : asymptotics.is_equivalent u (function.const \u03b1 c) l) :\n\tfilter.tendsto u l (nhds c)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : normed_group \u03b2] {u : \u03b1 \u2192 \u03b2} {l : filter \u03b1} {c : \u03b2}, asymptotics.is_equivalent u (function.const \u03b1 c) l \u2192 filter.tendsto u l (nhds c)", "decl_nm": "asymptotics.is_equivalent.tendsto_const"}
{"formal_statement": "theorem nontrivial {\u03b1 \u03b2 : Type*} [nontrivial \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : function.surjective f) :\n\tnontrivial \u03b1", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : nontrivial \u03b2] {f : \u03b1 \u2192 \u03b2}, function.surjective f \u2192 nontrivial \u03b1", "decl_nm": "function.surjective.nontrivial"}
{"formal_statement": "theorem mk_snd {C : Type u} [category_theory.category C] {X Y Z : C} {f : X \u27f6 Z}\n\t{g : Y \u27f6 Z} {W : C} (fst : W \u27f6 X) (snd : W \u27f6 Y) (eq_1 : fst \u226b f = snd \u226b g) :\n\t(category_theory.limits.pullback_cone.mk fst snd eq_1).snd = snd", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] {X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} {W : C} (fst : W \u27f6 X) (snd : W \u27f6 Y) (eq_1 : fst \u226b f = snd \u226b g), (category_theory.limits.pullback_cone.mk fst snd eq_1).snd = snd", "decl_nm": "category_theory.limits.pullback_cone.mk_snd"}
{"formal_statement": "theorem eval_neg_hom_X {A : Type*} [comm_ring A] :\n\t\u21d1power_series.eval_neg_hom power_series.X = -power_series.X", "decl_tp": "\u2200 {A : Type u_2} [_inst_1 : comm_ring A], \u21d1power_series.eval_neg_hom power_series.X = -power_series.X", "decl_nm": "power_series.eval_neg_hom_X"}
{"formal_statement": "theorem preimage_neg_Ioc {G : Type u} [ordered_add_comm_group G] (a b : G) :\n\t-set.Ioc a b = set.Ico (-b) (-a)", "decl_tp": "\u2200 {G : Type u} [_inst_1 : ordered_add_comm_group G] (a b : G), -set.Ioc a b = set.Ico (-b) (-a)", "decl_nm": "set.preimage_neg_Ioc"}
{"formal_statement": "theorem tendsto_nhds_nhds {\u03b1 : Type u} {\u03b2 : Type v} [pseudo_metric_space \u03b1]\n\t[pseudo_metric_space \u03b2] {f : \u03b1 \u2192 \u03b2} {a : \u03b1} {b : \u03b2} :\n\tfilter.tendsto f (nhds a) (nhds b) \u2194 \u2200 (\u03b5 : \u211d), \u03b5 > 0 \u2192 (\u2203 (\u03b4 : \u211d) (H : \u03b4 > 0), \u2200 {x : \u03b1}, has_dist.dist x a < \u03b4 \u2192 has_dist.dist (f x) b < \u03b5)", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : pseudo_metric_space \u03b1] [_inst_2 : pseudo_metric_space \u03b2] {f : \u03b1 \u2192 \u03b2} {a : \u03b1} {b : \u03b2}, filter.tendsto f (nhds a) (nhds b) \u2194 \u2200 (\u03b5 : \u211d), \u03b5 > 0 \u2192 (\u2203 (\u03b4 : \u211d) (H : \u03b4 > 0), \u2200 {x : \u03b1}, has_dist.dist x a < \u03b4 \u2192 has_dist.dist (f x) b < \u03b5)", "decl_nm": "metric.tendsto_nhds_nhds"}
{"formal_statement": "theorem adjoin_nat {F : Type*} [field F] {E : Type*} [field E] [algebra F E]\n\t(n : \u2115) :\n\tF\u27ee\u2191n\u27ef = \u22a5", "decl_tp": "\u2200 {F : Type u_1} [_inst_1 : field F] {E : Type u_2} [_inst_2 : field E] [_inst_3 : algebra F E] (n : \u2115), F\u27ee\u2191n\u27ef = \u22a5", "decl_nm": "intermediate_field.adjoin_nat"}
{"formal_statement": "theorem is_unit {A K : Type*} [comm_ring A] [field K] [is_domain A] [algebra A K]\n\t[is_fraction_ring A K] (h : is_dedekind_domain_inv A) (hI : I \u2260 0) :\n\t\u2200 {I : fractional_ideal (non_zero_divisors A) K},  is_unit I", "decl_tp": "\u2200 {A : Type u_2} {K : Type u_3} [_inst_2 : comm_ring A] [_inst_3 : field K] [_inst_4 : is_domain A] [_inst_5 : algebra A K] [_inst_6 : is_fraction_ring A K], is_dedekind_domain_inv A \u2192 \u2200 {I : fractional_ideal (non_zero_divisors A) K}, I \u2260 0 \u2192 is_unit I", "decl_nm": "is_dedekind_domain_inv.is_unit"}
{"formal_statement": "theorem of_eq {\u03b1 \u03c3 : Type*} [primcodable \u03b1] [primcodable \u03c3] {f g : \u03b1 \u2192 \u03c3}\n\t(hf : computable f) :\n\t(\u2200 (n : \u03b1), f n = g n) \u2192 computable g", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03c3 : Type u_4} [_inst_1 : primcodable \u03b1] [_inst_4 : primcodable \u03c3] {f g : \u03b1 \u2192 \u03c3}, computable f \u2192 (\u2200 (n : \u03b1), f n = g n) \u2192 computable g", "decl_nm": "computable.of_eq"}
{"formal_statement": "theorem matches_star_def {\u03b1 : Type u} (P : regular_expression \u03b1) :\n\tP.star.matches = P.matches.star", "decl_tp": "\u2200 {\u03b1 : Type u} (P : regular_expression \u03b1), P.star.matches = P.matches.star", "decl_nm": "regular_expression.matches_star_def"}
{"formal_statement": "theorem transpose_add_equiv_symm {m n : Type*} {\u03b1 : Type v} [has_add \u03b1] :\n\tmatrix.transpose_add_equiv.symm = matrix.transpose_add_equiv", "decl_tp": "\u2200 {m : Type u_2} {n : Type u_3} {\u03b1 : Type v} [_inst_1 : has_add \u03b1], matrix.transpose_add_equiv.symm = matrix.transpose_add_equiv", "decl_nm": "matrix.transpose_add_equiv_symm"}
{"formal_statement": "theorem add_even {m n : \u2124} (hm : odd m) (hn : even n) :\n\todd (m + n)", "decl_tp": "\u2200 {m n : \u2124}, odd m \u2192 even n \u2192 odd (m + n)", "decl_nm": "int.odd.add_even"}
{"formal_statement": "theorem power_lt_power_iff_right {a b c : ordinal} (a1 : 1 < a) :\n\t(a ^ b < a ^ c \u2194 b < c)", "decl_tp": "\u2200 {a b c : ordinal}, 1 < a \u2192 (a ^ b < a ^ c \u2194 b < c)", "decl_nm": "ordinal.power_lt_power_iff_right"}
{"formal_statement": "theorem prod_map_def {M N : Type*} [mul_one_class M] [mul_one_class N]\n\t{M' N' : Type*} [mul_one_class M'] [mul_one_class N'] (f : M \u2192* M') (g : N \u2192* N') :\n\tf.prod_map g = (f.comp (monoid_hom.fst M N)).prod (g.comp (monoid_hom.snd M N))", "decl_tp": "\u2200 {M : Type u_5} {N : Type u_6} [_inst_1 : mul_one_class M] [_inst_2 : mul_one_class N] {M' : Type u_8} {N' : Type u_9} [_inst_3 : mul_one_class M'] [_inst_4 : mul_one_class N'] (f : M \u2192* M') (g : N \u2192* N'), f.prod_map g = (f.comp (monoid_hom.fst M N)).prod (g.comp (monoid_hom.snd M N))", "decl_nm": "monoid_hom.prod_map_def"}
{"formal_statement": "theorem bit0_apply {m : Type*} {\u03b1 : Type v} [has_add \u03b1] (M : matrix m m \u03b1)\n\t(i j : m) :\n\tbit0 M i j = bit0 (M i j)", "decl_tp": "\u2200 {m : Type u_2} {\u03b1 : Type v} [_inst_2 : has_add \u03b1] (M : matrix m m \u03b1) (i j : m), bit0 M i j = bit0 (M i j)", "decl_nm": "matrix.bit0_apply"}
{"formal_statement": "theorem of_rat_apply (x : \u211a) :\n\t\u21d1real.of_rat x = \u27e8cau_seq.completion.of_rat x\u27e9", "decl_tp": "\u2200 (x : \u211a), \u21d1real.of_rat x = \u27e8cau_seq.completion.of_rat x\u27e9", "decl_nm": "real.of_rat_apply"}
{"formal_statement": "theorem le_def {k V P : Type*} [ring k] [add_comm_group V] [module k V]\n\t[S : add_torsor V P] (s1 s2 : affine_subspace k P) :\n\ts1 \u2264 s2 \u2194 \u2191s1 \u2286 \u2191s2", "decl_tp": "\u2200 {k : Type u_1} {V : Type u_2} {P : Type u_3} [_inst_1 : ring k] [_inst_2 : add_comm_group V] [_inst_3 : module k V] [S : add_torsor V P] (s1 s2 : affine_subspace k P), s1 \u2264 s2 \u2194 \u2191s1 \u2286 \u2191s2", "decl_nm": "affine_subspace.le_def"}
{"formal_statement": "theorem ord_le {c : cardinal} {o : ordinal} :\n\tc.ord \u2264 o \u2194 c \u2264 o.card", "decl_tp": "\u2200 {c : cardinal} {o : ordinal}, c.ord \u2264 o \u2194 c \u2264 o.card", "decl_nm": "cardinal.ord_le"}
{"formal_statement": "theorem zpow {G\u2080 : Type*} [group_with_zero G\u2080] [topological_space G\u2080] [has_continuous_inv\u2080 G\u2080]\n\t[has_continuous_mul G\u2080] {X : Type*} [topological_space X] {a : X} {f : X \u2192 G\u2080}\n\t(hf : continuous_at f a) (h : f a \u2260 0 \u2228 0 \u2264 m) :\n\t\u2200 (m : \u2124),  continuous_at (\u03bb (x : X), f x ^ m) a", "decl_tp": "\u2200 {G\u2080 : Type u_3} [_inst_1 : group_with_zero G\u2080] [_inst_2 : topological_space G\u2080] [_inst_3 : has_continuous_inv\u2080 G\u2080] [_inst_4 : has_continuous_mul G\u2080] {X : Type u_4} [_inst_5 : topological_space X] {a : X} {f : X \u2192 G\u2080}, continuous_at f a \u2192 \u2200 (m : \u2124), f a \u2260 0 \u2228 0 \u2264 m \u2192 continuous_at (\u03bb (x : X), f x ^ m) a", "decl_nm": "continuous_at.zpow"}
{"formal_statement": "theorem to_linear_map_injective {R S M M\u2082 : Type*} [semiring R] [semiring S]\n\t[add_comm_monoid M] [add_comm_monoid M\u2082] [module R M] [module S M\u2082] {\u03c3 : R \u2192+* S}\n\t{\u03c3' : S \u2192+* R} [ring_hom_inv_pair \u03c3 \u03c3'] [ring_hom_inv_pair \u03c3' \u03c3] :\n\tfunction.injective coe", "decl_tp": "\u2200 {R : Type u_1} {S : Type u_6} {M : Type u_7} {M\u2082 : Type u_9} [_inst_1 : semiring R] [_inst_2 : semiring S] [_inst_3 : add_comm_monoid M] [_inst_5 : add_comm_monoid M\u2082] [_inst_6 : module R M] [_inst_7 : module S M\u2082] {\u03c3 : R \u2192+* S} {\u03c3' : S \u2192+* R} [_inst_8 : ring_hom_inv_pair \u03c3 \u03c3'] [_inst_9 : ring_hom_inv_pair \u03c3' \u03c3], function.injective coe", "decl_nm": "linear_equiv.to_linear_map_injective"}
{"formal_statement": "theorem singleton_smooth_manifold_with_corners {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c]\n\t{E : Type*} [normed_group E] [normed_space \ud835\udd5c E] {H : Type*} [topological_space H]\n\t(I : model_with_corners \ud835\udd5c E H) {M : Type*} [topological_space M] (e : local_homeomorph M H)\n\t(h : e.to_local_equiv.source = set.univ) :\n\tsmooth_manifold_with_corners I M", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {H : Type u_3} [_inst_4 : topological_space H] (I : model_with_corners \ud835\udd5c E H) {M : Type u_4} [_inst_5 : topological_space M] (e : local_homeomorph M H) (h : e.to_local_equiv.source = set.univ), smooth_manifold_with_corners I M", "decl_nm": "local_homeomorph.singleton_smooth_manifold_with_corners"}
{"formal_statement": "theorem cod_restrict {\u03b1 \u03b2 : Type*} [pseudo_emetric_space \u03b1] [pseudo_emetric_space \u03b2]\n\t{K : nnreal} {f : \u03b1 \u2192 \u03b2} (hf : antilipschitz_with K f) :\n\t\u2200 {s : set \u03b2} (hs : \u2200 (x : \u03b1), f x \u2208 s), antilipschitz_with K (set.cod_restrict f s hs)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : pseudo_emetric_space \u03b1] [_inst_2 : pseudo_emetric_space \u03b2] {K : nnreal} {f : \u03b1 \u2192 \u03b2}, antilipschitz_with K f \u2192 \u2200 {s : set \u03b2} (hs : \u2200 (x : \u03b1), f x \u2208 s), antilipschitz_with K (set.cod_restrict f s hs)", "decl_nm": "antilipschitz_with.cod_restrict"}
{"formal_statement": "theorem of_\u03c0_X {C : Type u} [category_theory.category C] (I : category_theory.limits.multispan_index C)\n\t(P : C) (\u03c0 : \u03a0 (b : I.R), I.right b \u27f6 P) (w : \u2200 (a : I.L), I.fst a \u226b \u03c0 (I.fst_from a) = I.snd a \u226b \u03c0 (I.snd_from a)) :\n\t(category_theory.limits.multicofork.of_\u03c0 I P \u03c0 w).X = P", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] (I : category_theory.limits.multispan_index C) (P : C) (\u03c0 : \u03a0 (b : I.R), I.right b \u27f6 P) (w : \u2200 (a : I.L), I.fst a \u226b \u03c0 (I.fst_from a) = I.snd a \u226b \u03c0 (I.snd_from a)), (category_theory.limits.multicofork.of_\u03c0 I P \u03c0 w).X = P", "decl_nm": "category_theory.limits.multicofork.of_\u03c0_X"}
{"formal_statement": "theorem sin_sub_int_mul_two_pi (x : \u2102) (n : \u2124) :\n\tcomplex.sin (x - \u2191n * (2 * \u2191real.pi)) = complex.sin x", "decl_tp": "\u2200 (x : \u2102) (n : \u2124), complex.sin (x - \u2191n * (2 * \u2191real.pi)) = complex.sin x", "decl_nm": "complex.sin_sub_int_mul_two_pi"}
{"formal_statement": "theorem smul_left {R M : Type*} [semiring R] [add_comm_monoid M] [module R M]\n\t{B : bilin_form R M} (a : R) (x y : M) :\n\t\u21d1B (a \u2022 x) y = a * \u21d1B x y", "decl_tp": "\u2200 {R : Type u_1} {M : Type u_2} [_inst_1 : semiring R] [_inst_2 : add_comm_monoid M] [_inst_3 : module R M] {B : bilin_form R M} (a : R) (x y : M), \u21d1B (a \u2022 x) y = a * \u21d1B x y", "decl_nm": "bilin_form.smul_left"}
{"formal_statement": "theorem inf {\u03b1 : Type u} {\u03b2 : Type v} [semilattice_inf \u03b2] {f g : \u03b1 \u2192 \u03b2}\n\t{a : \u03b1} {l : filter \u03b1} (hf : is_min_filter f l a) (hg : is_min_filter g l a) :\n\tis_min_filter (\u03bb (x : \u03b1), f x \u2293 g x) l a", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : semilattice_inf \u03b2] {f g : \u03b1 \u2192 \u03b2} {a : \u03b1} {l : filter \u03b1}, is_min_filter f l a \u2192 is_min_filter g l a \u2192 is_min_filter (\u03bb (x : \u03b1), f x \u2293 g x) l a", "decl_nm": "is_min_filter.inf"}
{"formal_statement": "theorem range_id {\u03b1 : Type u} :\n\tset.range id = set.univ", "decl_tp": "\u2200 {\u03b1 : Type u}, set.range id = set.univ", "decl_nm": "set.range_id"}
{"formal_statement": "theorem comap_subtype_inf_right {G : Type*} [group G] {H K : subgroup G} :\n\tsubgroup.comap K.subtype (H \u2293 K) = subgroup.comap K.subtype H", "decl_tp": "\u2200 {G : Type u_1} [_inst_1 : group G] {H K : subgroup G}, subgroup.comap K.subtype (H \u2293 K) = subgroup.comap K.subtype H", "decl_nm": "subgroup.comap_subtype_inf_right"}
{"formal_statement": "theorem has_strict_deriv_at_exp (x : \u2102) :\n\thas_strict_deriv_at complex.exp (complex.exp x) x", "decl_tp": "\u2200 (x : \u2102), has_strict_deriv_at complex.exp (complex.exp x) x", "decl_nm": "complex.has_strict_deriv_at_exp"}
{"formal_statement": "theorem lie_smul {R : Type u} {L : Type v} {M : Type w} [comm_ring R] [lie_ring L]\n\t[lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M]\n\t[lie_module R L M] (t : R) (x : L) (m : M) :\n\t\u2045x,t \u2022 m\u2046 = t \u2022 \u2045x,m\u2046", "decl_tp": "\u2200 {R : Type u} {L : Type v} {M : Type w} [_inst_1 : comm_ring R] [_inst_2 : lie_ring L] [_inst_3 : lie_algebra R L] [_inst_4 : add_comm_group M] [_inst_5 : module R M] [_inst_6 : lie_ring_module L M] [_inst_7 : lie_module R L M] (t : R) (x : L) (m : M), \u2045x,t \u2022 m\u2046 = t \u2022 \u2045x,m\u2046", "decl_nm": "lie_smul"}
{"formal_statement": "theorem Ioc_disjoint_Ioc_same {\u03b1 : Type v} [preorder \u03b1] {a b c : \u03b1} :\n\tdisjoint (set.Ioc a b) (set.Ioc b c)", "decl_tp": "\u2200 {\u03b1 : Type v} [_inst_1 : preorder \u03b1] {a b c : \u03b1}, disjoint (set.Ioc a b) (set.Ioc b c)", "decl_nm": "set.Ioc_disjoint_Ioc_same"}
{"formal_statement": "theorem all_singleton {\u03b1 : Type*} {P : \u03b1 \u2192 Prop} {x : \u03b1} :\n\tordnode.all P {x} \u2194 P x", "decl_tp": "\u2200 {\u03b1 : Type u_1} {P : \u03b1 \u2192 Prop} {x : \u03b1}, ordnode.all P {x} \u2194 P x", "decl_nm": "ordnode.all_singleton"}
{"formal_statement": "theorem mk_coe {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c] {E : Type*} [normed_group E]\n\t[normed_space \ud835\udd5c E] {H : Type*} [topological_space H] (e : local_equiv H E)\n\t(a : e.source = set.univ) (b : unique_diff_on \ud835\udd5c e.target) (c : auto_param (continuous e.to_fun)\n\t(name.mk_string \"continuity'\" (name.mk_string \"interactive\" (name.mk_string \"tactic\" name.anonymous))))\n\t(d : auto_param (continuous e.inv_fun) (name.mk_string \"continuity'\" (name.mk_string \"interactive\" (name.mk_string \"tactic\" name.anonymous)))) :\n\t\u21d1{to_local_equiv := e, source_eq := a, unique_diff' := b, continuous_to_fun := c, continuous_inv_fun := d} = \u21d1e", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {H : Type u_3} [_inst_4 : topological_space H] (e : local_equiv H E) (a : e.source = set.univ) (b : unique_diff_on \ud835\udd5c e.target) (c : auto_param (continuous e.to_fun) (name.mk_string \"continuity'\" (name.mk_string \"interactive\" (name.mk_string \"tactic\" name.anonymous)))) (d : auto_param (continuous e.inv_fun) (name.mk_string \"continuity'\" (name.mk_string \"interactive\" (name.mk_string \"tactic\" name.anonymous)))), \u21d1{to_local_equiv := e, source_eq := a, unique_diff' := b, continuous_to_fun := c, continuous_inv_fun := d} = \u21d1e", "decl_nm": "model_with_corners.mk_coe"}
{"formal_statement": "theorem has_strict_deriv_at_arccos {x : \u211d} (h\u2081 : x \u2260 -1) (h\u2082 : x \u2260 1) :\n\thas_strict_deriv_at real.arccos (-(1 / real.sqrt (1 - x ^ 2))) x", "decl_tp": "\u2200 {x : \u211d}, x \u2260 -1 \u2192 x \u2260 1 \u2192 has_strict_deriv_at real.arccos (-(1 / real.sqrt (1 - x ^ 2))) x", "decl_nm": "real.has_strict_deriv_at_arccos"}
{"formal_statement": "theorem connected_component_nrel_iff {\u03b1 : Type u} [topological_space \u03b1]\n\t{x y : \u03b1} :\n\t\u27e6x\u27e7 \u2260 \u27e6y\u27e7 \u2194 connected_component x \u2260 connected_component y", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : topological_space \u03b1] {x y : \u03b1}, \u27e6x\u27e7 \u2260 \u27e6y\u27e7 \u2194 connected_component x \u2260 connected_component y", "decl_nm": "connected_component_nrel_iff"}
{"formal_statement": "theorem pullback_cone_of_right_iso_\u03c0_app_none {C : Type u} [category_theory.category C]\n\t{X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z) [category_theory.is_iso g] :\n\t(category_theory.limits.pullback_cone_of_right_iso f g).\u03c0.app option.none = f", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z) [_inst_2 : category_theory.is_iso g], (category_theory.limits.pullback_cone_of_right_iso f g).\u03c0.app option.none = f", "decl_nm": "category_theory.limits.pullback_cone_of_right_iso_\u03c0_app_none"}
{"formal_statement": "theorem left_unique {\u03b1 : Type*} :\n\trelator.left_unique has_mem.mem", "decl_tp": "\u2200 {\u03b1 : Type u_1}, relator.left_unique has_mem.mem", "decl_nm": "option.mem.left_unique"}
{"formal_statement": "theorem point_reflection_midpoint_left {V P : Type*} [semi_normed_group V]\n\t[pseudo_metric_space P] [semi_normed_add_torsor V P] [semi_normed_space \u211d V]\n\t(x y : P) :\n\t\u21d1(affine_isometry_equiv.point_reflection \u211d (midpoint \u211d x y)) x = y", "decl_tp": "\u2200 {V : Type u_2} {P : Type u_8} [_inst_2 : semi_normed_group V] [_inst_12 : pseudo_metric_space P] [_inst_17 : semi_normed_add_torsor V P] [_inst_23 : semi_normed_space \u211d V] (x y : P), \u21d1(affine_isometry_equiv.point_reflection \u211d (midpoint \u211d x y)) x = y", "decl_nm": "affine_isometry_equiv.point_reflection_midpoint_left"}
{"formal_statement": "theorem pow {X M : Type*} [topological_space X] [topological_space M] [monoid M]\n\t[has_continuous_mul M] {f : X \u2192 M} {x : X} (hf : continuous_at f x) :\n\t\u2200 (n : \u2115), continuous_at (\u03bb (x : X), f x ^ n) x", "decl_tp": "\u2200 {X : Type u_3} {M : Type u_4} [_inst_1 : topological_space X] [_inst_2 : topological_space M] [_inst_3 : monoid M] [_inst_4 : has_continuous_mul M] {f : X \u2192 M} {x : X}, continuous_at f x \u2192 \u2200 (n : \u2115), continuous_at (\u03bb (x : X), f x ^ n) x", "decl_nm": "continuous_at.pow"}
{"formal_statement": "theorem single_neg {\u03b1 G : Type*} [add_group G] {a : \u03b1} {b : G} :\n\tfinsupp.single a (-b) = -finsupp.single a b", "decl_tp": "\u2200 {\u03b1 : Type u_1} {G : Type u_9} [_inst_1 : add_group G] {a : \u03b1} {b : G}, finsupp.single a (-b) = -finsupp.single a b", "decl_nm": "finsupp.single_neg"}
{"formal_statement": "theorem eq {V : Type u} [quiver V] [quiver.has_reverse V] (a b : V) :\n\t\u2191a = \u2191b \u2194 nonempty (quiver.path a b)", "decl_tp": "\u2200 {V : Type u} [_inst_1 : quiver V] [_inst_2 : quiver.has_reverse V] (a b : V), \u2191a = \u2191b \u2194 nonempty (quiver.path a b)", "decl_nm": "quiver.weakly_connected_component.eq"}
{"formal_statement": "theorem id_right {\u03b1 \u03b2 : Type*} {f : \u03b1 \u2192 \u03b2} :\n\tfunction.semiconj f id id", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {f : \u03b1 \u2192 \u03b2}, function.semiconj f id id", "decl_nm": "function.semiconj.id_right"}
{"formal_statement": "theorem exists_nonempty_inter_of_measure_univ_lt_tsum_measure {\u03b1 \u03b9 : Type*}\n\t{m : measurable_space \u03b1} (\u03bc : measure_theory.measure \u03b1) {s : \u03b9 \u2192 set \u03b1}\n\t(H : \u21d1\u03bc set.univ < \u2211' (i : \u03b9), \u21d1\u03bc (s i)) :\n\t(\u2200 (i : \u03b9), measurable_set (s i)) \u2192  (\u2203 (i j : \u03b9) (h : i \u2260 j), (s i \u2229 s j).nonempty)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b9 : Type u_5} {m : measurable_space \u03b1} (\u03bc : measure_theory.measure \u03b1) {s : \u03b9 \u2192 set \u03b1}, (\u2200 (i : \u03b9), measurable_set (s i)) \u2192 \u21d1\u03bc set.univ < \u2211' (i : \u03b9), \u21d1\u03bc (s i) \u2192 (\u2203 (i j : \u03b9) (h : i \u2260 j), (s i \u2229 s j).nonempty)", "decl_nm": "measure_theory.exists_nonempty_inter_of_measure_univ_lt_tsum_measure"}
{"formal_statement": "theorem vsub_eq_sub {G : Type*} [add_group G] (g1 g2 : G) :\n\tg1 -\u1d65 g2 = g1 - g2", "decl_tp": "\u2200 {G : Type u_1} [_inst_1 : add_group G] (g1 g2 : G), g1 -\u1d65 g2 = g1 - g2", "decl_nm": "vsub_eq_sub"}
{"formal_statement": "theorem sum_apply {\u03b1 \u03b9 : Type*} {m0 : measurable_space \u03b1} (f : \u03b9 \u2192 measure_theory.measure \u03b1)\n\t{s : set \u03b1} (hs : measurable_set s) :\n\t\u21d1(measure_theory.measure.sum f) s = \u2211' (i : \u03b9), \u21d1(f i) s", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b9 : Type u_5} {m0 : measurable_space \u03b1} (f : \u03b9 \u2192 measure_theory.measure \u03b1) {s : set \u03b1}, measurable_set s \u2192 \u21d1(measure_theory.measure.sum f) s = \u2211' (i : \u03b9), \u21d1(f i) s", "decl_nm": "measure_theory.measure.sum_apply"}
{"formal_statement": "theorem coe_fn_inv {\u03b1 \u03b3 : Type*} [measurable_space \u03b1] {\u03bc : measure_theory.measure \u03b1}\n\t[measurable_space \u03b3] [topological_space \u03b3] [borel_space \u03b3] [group \u03b3] [topological_group \u03b3]\n\t(f : \u03b1 \u2192\u2098[\u03bc] \u03b3) :\n\t\u21d1f\u207b\u00b9 =\u1d50[\u03bc] (\u21d1f)\u207b\u00b9", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b3 : Type u_3} [_inst_1 : measurable_space \u03b1] {\u03bc : measure_theory.measure \u03b1} [_inst_3 : measurable_space \u03b3] [_inst_5 : topological_space \u03b3] [_inst_6 : borel_space \u03b3] [_inst_7 : group \u03b3] [_inst_8 : topological_group \u03b3] (f : \u03b1 \u2192\u2098[\u03bc] \u03b3), \u21d1f\u207b\u00b9 =\u1d50[\u03bc] (\u21d1f)\u207b\u00b9", "decl_nm": "measure_theory.ae_eq_fun.coe_fn_inv"}
{"formal_statement": "theorem is_finite_measure_with_density {\u03b1 : Type*} {m : measurable_space \u03b1}\n\t{\u03bc : measure_theory.measure \u03b1} {f : \u03b1 \u2192 ennreal} (hf : \u222b\u207b (a : \u03b1), f a \u2202\u03bc \u2260 \u22a4) :\n\tmeasure_theory.is_finite_measure (\u03bc.with_density f)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {m : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} {f : \u03b1 \u2192 ennreal}, \u222b\u207b (a : \u03b1), f a \u2202\u03bc \u2260 \u22a4 \u2192 measure_theory.is_finite_measure (\u03bc.with_density f)", "decl_nm": "measure_theory.is_finite_measure_with_density"}
{"formal_statement": "theorem \u03c9Sup_le_iff {\u03b1 : Type u} [omega_complete_partial_order \u03b1] (c : omega_complete_partial_order.chain \u03b1)\n\t(x : \u03b1) :\n\tomega_complete_partial_order.\u03c9Sup c \u2264 x \u2194 \u2200 (i : \u2115), \u21d1c i \u2264 x", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : omega_complete_partial_order \u03b1] (c : omega_complete_partial_order.chain \u03b1) (x : \u03b1), omega_complete_partial_order.\u03c9Sup c \u2264 x \u2194 \u2200 (i : \u2115), \u21d1c i \u2264 x", "decl_nm": "omega_complete_partial_order.\u03c9Sup_le_iff"}
{"formal_statement": "theorem le_lim {\u03b1 : Type*} [linear_ordered_field \u03b1] [cau_seq.is_complete \u03b1 has_abs.abs]\n\t{f : cau_seq \u03b1 has_abs.abs} {x : \u03b1} (h : cau_seq.const has_abs.abs x \u2264 f) :\n\tx \u2264 f.lim", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : linear_ordered_field \u03b1] [_inst_2 : cau_seq.is_complete \u03b1 has_abs.abs] {f : cau_seq \u03b1 has_abs.abs} {x : \u03b1}, cau_seq.const has_abs.abs x \u2264 f \u2192 x \u2264 f.lim", "decl_nm": "cau_seq.le_lim"}
{"formal_statement": "theorem sum {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c] {E : Type*} [normed_group E]\n\t[normed_space \ud835\udd5c E] {F : Type*} [normed_group F] [normed_space \ud835\udd5c F] {x : E}\n\t{\u03b9 : Type*} {u : finset \u03b9} {A : \u03b9 \u2192 E \u2192 F} {A' : \u03b9 \u2192 (E \u2192L[\ud835\udd5c] F)} :\n\t(\u2200 (i : \u03b9), i \u2208 u \u2192 has_fderiv_at (A i) (A' i) x) \u2192 has_fderiv_at (\u03bb (y : E), u.sum (\u03bb (i : \u03b9), A i y))\n\t(u.sum (\u03bb (i : \u03b9), A' i)) x", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {F : Type u_3} [_inst_4 : normed_group F] [_inst_5 : normed_space \ud835\udd5c F] {x : E} {\u03b9 : Type u_6} {u : finset \u03b9} {A : \u03b9 \u2192 E \u2192 F} {A' : \u03b9 \u2192 (E \u2192L[\ud835\udd5c] F)}, (\u2200 (i : \u03b9), i \u2208 u \u2192 has_fderiv_at (A i) (A' i) x) \u2192 has_fderiv_at (\u03bb (y : E), u.sum (\u03bb (i : \u03b9), A i y)) (u.sum (\u03bb (i : \u03b9), A' i)) x", "decl_nm": "has_fderiv_at.sum"}
{"formal_statement": "theorem power_limit {a b : ordinal} (a0 : a \u2260 0) (h : b.is_limit) :\n\ta ^ b = b.bsup (\u03bb (c : ordinal) (_x : c < b), a ^ c)", "decl_tp": "\u2200 {a b : ordinal}, a \u2260 0 \u2192 b.is_limit \u2192 a ^ b = b.bsup (\u03bb (c : ordinal) (_x : c < b), a ^ c)", "decl_nm": "ordinal.power_limit"}
{"formal_statement": "theorem is_partition_split_many {\u03b9 : Type*} (I : box_integral.box \u03b9) (s : finset (\u03b9 \u00d7 \u211d)) :\n\t(box_integral.prepartition.split_many I s).is_partition", "decl_tp": "\u2200 {\u03b9 : Type u_1} (I : box_integral.box \u03b9) (s : finset (\u03b9 \u00d7 \u211d)), (box_integral.prepartition.split_many I s).is_partition", "decl_nm": "box_integral.prepartition.is_partition_split_many"}
{"formal_statement": "theorem has_sub_sub_im_k {R : Type*} [comm_ring R] {c\u2081 c\u2082 : R} (a b : quaternion_algebra R c\u2081 c\u2082) :\n\t(a - b).im_k = a.im_k - b.im_k", "decl_tp": "\u2200 {R : Type u_1} [_inst_1 : comm_ring R] {c\u2081 c\u2082 : R} (a b : quaternion_algebra R c\u2081 c\u2082), (a - b).im_k = a.im_k - b.im_k", "decl_nm": "quaternion_algebra.has_sub_sub_im_k"}
{"formal_statement": "theorem condition {C : Type u} [category_theory.category C] {X Y Z : C}\n\t{f : X \u27f6 Z} {g : Y \u27f6 Z} [category_theory.limits.has_pullback f g] :\n\tcategory_theory.limits.pullback.fst \u226b f = category_theory.limits.pullback.snd \u226b g", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] {X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} [_inst_2 : category_theory.limits.has_pullback f g], category_theory.limits.pullback.fst \u226b f = category_theory.limits.pullback.snd \u226b g", "decl_nm": "category_theory.limits.pullback.condition"}
{"formal_statement": "theorem exp_list_sum (l : list \u2102) :\n\tcomplex.exp l.sum = (list.map complex.exp l).prod", "decl_tp": "\u2200 (l : list \u2102), complex.exp l.sum = (list.map complex.exp l).prod", "decl_nm": "complex.exp_list_sum"}
{"formal_statement": "theorem deriv_rpow_const {f : \u211d \u2192 \u211d} {x p : \u211d} (hf : differentiable_at \u211d f x)\n\t(hx : f x \u2260 0 \u2228 1 \u2264 p) :\n\tderiv (\u03bb (x : \u211d), f x ^ p) x = deriv f x * p * f x ^ (p - 1)", "decl_tp": "\u2200 {f : \u211d \u2192 \u211d} {x p : \u211d}, differentiable_at \u211d f x \u2192 f x \u2260 0 \u2228 1 \u2264 p \u2192 deriv (\u03bb (x : \u211d), f x ^ p) x = deriv f x * p * f x ^ (p - 1)", "decl_nm": "deriv_rpow_const"}
{"formal_statement": "theorem mono {\u03b1 : Type u} {p q : \u03b1 \u2192 Prop} {f : filter \u03b1} :\n\t(\u2200\u1da0 (x : \u03b1) in f, p x) \u2192 (\u2200 (x : \u03b1), p x \u2192 q x) \u2192 (\u2200\u1da0 (x : \u03b1) in f, q x)", "decl_tp": "\u2200 {\u03b1 : Type u} {p q : \u03b1 \u2192 Prop} {f : filter \u03b1}, (\u2200\u1da0 (x : \u03b1) in f, p x) \u2192 (\u2200 (x : \u03b1), p x \u2192 q x) \u2192 (\u2200\u1da0 (x : \u03b1) in f, q x)", "decl_nm": "filter.eventually.mono"}
{"formal_statement": "theorem nsmul_one {A : Type y} [add_monoid A] [has_one A] (n : \u2115) :\n\tn \u2022 1 = \u2191n", "decl_tp": "\u2200 {A : Type y} [_inst_3 : add_monoid A] [_inst_5 : has_one A] (n : \u2115), n \u2022 1 = \u2191n", "decl_nm": "nsmul_one"}
{"formal_statement": "theorem lt_one_bit0 {\u03b1 : Type*} [linear_ordered_semiring \u03b1] (a : \u03b1) (h : 1 \u2264 a) :\n\t1 < bit0 a", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : linear_ordered_semiring \u03b1] (a : \u03b1), 1 \u2264 a \u2192 1 < bit0 a", "decl_nm": "norm_num.lt_one_bit0"}
{"formal_statement": "theorem product_val {\u03b1 \u03b2 : Type*} {s : finset \u03b1} {t : finset \u03b2} :\n\t(s.product t).val = s.val.product t.val", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {s : finset \u03b1} {t : finset \u03b2}, (s.product t).val = s.val.product t.val", "decl_nm": "finset.product_val"}
{"formal_statement": "theorem lift_is_locally_constant {X : Type*} [topological_space X] {\u03b1 : Type*}\n\t(f : locally_constant X \u03b1) :\n\tis_locally_constant f.lift", "decl_tp": "\u2200 {X : Type u_1} [_inst_1 : topological_space X] {\u03b1 : Type u_2} (f : locally_constant X \u03b1), is_locally_constant f.lift", "decl_nm": "locally_constant.lift_is_locally_constant"}
{"formal_statement": "theorem gt_mem_nhds {\u03b1 : Type u} [topological_space \u03b1] [partial_order \u03b1]\n\t[t : order_topology \u03b1] {a b : \u03b1} (h : a < b) :\n\t(\u2200\u1da0 (x : \u03b1) in nhds a, x < b)", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : topological_space \u03b1] [_inst_2 : partial_order \u03b1] [t : order_topology \u03b1] {a b : \u03b1}, a < b \u2192 (\u2200\u1da0 (x : \u03b1) in nhds a, x < b)", "decl_nm": "gt_mem_nhds"}
{"formal_statement": "theorem not_dvd_of_pos_of_lt {a b : \u2115} (h1 : 0 < b) (h2 : b < a) :\n\t\u00aca \u2223 b", "decl_tp": "\u2200 {a b : \u2115}, 0 < b \u2192 b < a \u2192 \u00aca \u2223 b", "decl_nm": "nat.not_dvd_of_pos_of_lt"}
{"formal_statement": "theorem eval\u2082_one {R : Type u} {S\u2081 : Type v} {\u03c3 : Type*} [comm_semiring R]\n\t[comm_semiring S\u2081] (f : R \u2192+* S\u2081) (g : \u03c3 \u2192 S\u2081) :\n\tmv_polynomial.eval\u2082 f g 1 = 1", "decl_tp": "\u2200 {R : Type u} {S\u2081 : Type v} {\u03c3 : Type u_1} [_inst_1 : comm_semiring R] [_inst_2 : comm_semiring S\u2081] (f : R \u2192+* S\u2081) (g : \u03c3 \u2192 S\u2081), mv_polynomial.eval\u2082 f g 1 = 1", "decl_nm": "mv_polynomial.eval\u2082_one"}
{"formal_statement": "theorem gcd_mul_right_cancel (m : \u2115+) {n k : \u2115+} :\n\tk.coprime n \u2192 (m * k).gcd n = m.gcd n", "decl_tp": "\u2200 (m : \u2115+) {n k : \u2115+}, k.coprime n \u2192 (m * k).gcd n = m.gcd n", "decl_nm": "pnat.coprime.gcd_mul_right_cancel"}
{"formal_statement": "theorem zip_right'_nil_cons {\u03b1 : Type u} {\u03b2 : Type v} (b : \u03b2) (bs : list \u03b2) :\n\tlist.nil.zip_right' (b :: bs) = ((option.none \u03b1, b) :: list.map (\u03bb (b : \u03b2), (option.none \u03b1, b)) bs, list.nil \u03b1)", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} (b : \u03b2) (bs : list \u03b2), list.nil.zip_right' (b :: bs) = ((option.none \u03b1, b) :: list.map (\u03bb (b : \u03b2), (option.none \u03b1, b)) bs, list.nil \u03b1)", "decl_nm": "list.zip_right'_nil_cons"}
{"formal_statement": "theorem not_exists_of_forall_not {\u03b1 : Sort u_1} {p : \u03b1 \u2192 Prop} :\n\t(\u2200 (x : \u03b1), \u00acp x) \u2192 (\u00ac\u2203 (x : \u03b1), p x)", "decl_tp": "\u2200 {\u03b1 : Sort u_1} {p : \u03b1 \u2192 Prop}, (\u2200 (x : \u03b1), \u00acp x) \u2192 (\u00ac\u2203 (x : \u03b1), p x)", "decl_nm": "not_exists_of_forall_not"}
{"formal_statement": "theorem mk_iso_inv_f {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C]\n\t[category_theory.has_shift C \u2124] {X Y : category_theory.differential_object C}\n\t(f : X.X \u2245 Y.X) (hf : X.d \u226b (category_theory.shift_functor C 1).map f.hom = f.hom \u226b Y.d) :\n\t(category_theory.differential_object.mk_iso f hf).inv.f = f.inv", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] [_inst_2 : category_theory.limits.has_zero_morphisms C] [_inst_3 : category_theory.has_shift C \u2124] {X Y : category_theory.differential_object C} (f : X.X \u2245 Y.X) (hf : X.d \u226b (category_theory.shift_functor C 1).map f.hom = f.hom \u226b Y.d), (category_theory.differential_object.mk_iso f hf).inv.f = f.inv", "decl_nm": "category_theory.differential_object.mk_iso_inv_f"}
{"formal_statement": "theorem orbit_smul_subset {\u03b1 : Type u} {\u03b2 : Type v} [monoid \u03b1] [mul_action \u03b1 \u03b2]\n\t(a : \u03b1) (b : \u03b2) :\n\tmul_action.orbit \u03b1 (a \u2022 b) \u2286 mul_action.orbit \u03b1 b", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : monoid \u03b1] [_inst_2 : mul_action \u03b1 \u03b2] (a : \u03b1) (b : \u03b2), mul_action.orbit \u03b1 (a \u2022 b) \u2286 mul_action.orbit \u03b1 b", "decl_nm": "mul_action.orbit_smul_subset"}
{"formal_statement": "theorem exists_continuous_zero_one_of_closed {X : Type*} [topological_space X]\n\t[normal_space X] {s t : set X} (hs : is_closed s) (ht : is_closed t) (hd : disjoint s t) :\n\t(\u2203 (f : C(X, \u211d)), set.eq_on \u21d1f 0 s \u2227 set.eq_on \u21d1f 1 t \u2227 \u2200 (x : X), \u21d1f x \u2208 set.Icc 0 1)", "decl_tp": "\u2200 {X : Type u_1} [_inst_1 : topological_space X] [_inst_2 : normal_space X] {s t : set X}, is_closed s \u2192 is_closed t \u2192 disjoint s t \u2192 (\u2203 (f : C(X, \u211d)), set.eq_on \u21d1f 0 s \u2227 set.eq_on \u21d1f 1 t \u2227 \u2200 (x : X), \u21d1f x \u2208 set.Icc 0 1)", "decl_nm": "exists_continuous_zero_one_of_closed"}
{"formal_statement": "theorem of_injective_to_hom {L : first_order.language} {M N : Type*} [L.Structure M]\n\t[L.Structure N] [L.is_algebraic] {f : L.hom M N} (hf : function.injective \u21d1f) :\n\t(first_order.language.embedding.of_injective hf).to_hom = f", "decl_tp": "\u2200 {L : first_order.language} {M : Type u_3} {N : Type u_4} [_inst_1 : L.Structure M] [_inst_2 : L.Structure N] [_inst_5 : L.is_algebraic] {f : L.hom M N} (hf : function.injective \u21d1f), (first_order.language.embedding.of_injective hf).to_hom = f", "decl_nm": "first_order.language.embedding.of_injective_to_hom"}
{"formal_statement": "theorem zpowers_hom_apply {G : Type w} [group G] (x : G) (n : multiplicative \u2124) :\n\t\u21d1(\u21d1(zpowers_hom G) x) n = x ^ \u21d1multiplicative.to_add n", "decl_tp": "\u2200 {G : Type w} [_inst_1 : group G] (x : G) (n : multiplicative \u2124), \u21d1(\u21d1(zpowers_hom G) x) n = x ^ \u21d1multiplicative.to_add n", "decl_nm": "zpowers_hom_apply"}
{"formal_statement": "theorem continuous_within_at_symm {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c]\n\t{E : Type*} [normed_group E] [normed_space \ud835\udd5c E] {H : Type*} [topological_space H]\n\t(I : model_with_corners \ud835\udd5c E H) {s : set E} {x : E} :\n\tcontinuous_within_at \u21d1(I.symm) s x", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {H : Type u_3} [_inst_4 : topological_space H] (I : model_with_corners \ud835\udd5c E H) {s : set E} {x : E}, continuous_within_at \u21d1(I.symm) s x", "decl_nm": "model_with_corners.continuous_within_at_symm"}
{"formal_statement": "theorem tan_add_int_mul_pi (x : \u2102) (n : \u2124) :\n\tcomplex.tan (x + \u2191n * \u2191real.pi) = complex.tan x", "decl_tp": "\u2200 (x : \u2102) (n : \u2124), complex.tan (x + \u2191n * \u2191real.pi) = complex.tan x", "decl_nm": "complex.tan_add_int_mul_pi"}
{"formal_statement": "theorem neg_to_germ {\u03b1 \u03b3 : Type*} [measurable_space \u03b1] {\u03bc : measure_theory.measure \u03b1}\n\t[measurable_space \u03b3] [topological_space \u03b3] [borel_space \u03b3] [add_group \u03b3]\n\t[topological_add_group \u03b3] (f : \u03b1 \u2192\u2098[\u03bc] \u03b3) :\n\t(-f).to_germ = -f.to_germ", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b3 : Type u_3} [_inst_1 : measurable_space \u03b1] {\u03bc : measure_theory.measure \u03b1} [_inst_3 : measurable_space \u03b3] [_inst_5 : topological_space \u03b3] [_inst_6 : borel_space \u03b3] [_inst_7 : add_group \u03b3] [_inst_8 : topological_add_group \u03b3] (f : \u03b1 \u2192\u2098[\u03bc] \u03b3), (-f).to_germ = -f.to_germ", "decl_nm": "measure_theory.ae_eq_fun.neg_to_germ"}
{"formal_statement": "theorem rotate'_length {\u03b1 : Type u} (l : list \u03b1) :\n\tl.rotate' l.length = l", "decl_tp": "\u2200 {\u03b1 : Type u} (l : list \u03b1), l.rotate' l.length = l", "decl_nm": "list.rotate'_length"}
{"formal_statement": "theorem finite_dimensional {K : Type*} [field K] {L : Type*} [field L]\n\t[algebra K L] {x : L} (hx : is_integral K x) :\n\tfinite_dimensional K \u21a5K\u27eex\u27ef", "decl_tp": "\u2200 {K : Type u_3} [_inst_4 : field K] {L : Type u_4} [_inst_6 : field L] [_inst_7 : algebra K L] {x : L}, is_integral K x \u2192 finite_dimensional K \u21a5K\u27eex\u27ef", "decl_nm": "intermediate_field.adjoin.finite_dimensional"}
{"formal_statement": "theorem sum_antidiagonal_succ' {N : Type*} [add_comm_monoid N] {n : \u2115}\n\t{f : \u2115 \u00d7 \u2115 \u2192 N} :\n\t(finset.nat.antidiagonal (n + 1)).sum (\u03bb (p : \u2115 \u00d7 \u2115), f p) = f (n + 1, 0) + (finset.nat.antidiagonal n).sum (\u03bb (p : \u2115 \u00d7 \u2115), f (p.fst, p.snd + 1))", "decl_tp": "\u2200 {N : Type u_2} [_inst_2 : add_comm_monoid N] {n : \u2115} {f : \u2115 \u00d7 \u2115 \u2192 N}, (finset.nat.antidiagonal (n + 1)).sum (\u03bb (p : \u2115 \u00d7 \u2115), f p) = f (n + 1, 0) + (finset.nat.antidiagonal n).sum (\u03bb (p : \u2115 \u00d7 \u2115), f (p.fst, p.snd + 1))", "decl_nm": "finset.nat.sum_antidiagonal_succ'"}
{"formal_statement": "theorem norm {\u03b1 E : Type*} [semi_normed_group E] [topological_space \u03b1]\n\t{f : \u03b1 \u2192 E} {s : set \u03b1} {a : \u03b1} (h : continuous_within_at f s a) :\n\tcontinuous_within_at (\u03bb (x : \u03b1), \u2225f x\u2225) s a", "decl_tp": "\u2200 {\u03b1 : Type u_1} {E : Type u_3} [_inst_1 : semi_normed_group E] [_inst_3 : topological_space \u03b1] {f : \u03b1 \u2192 E} {s : set \u03b1} {a : \u03b1}, continuous_within_at f s a \u2192 continuous_within_at (\u03bb (x : \u03b1), \u2225f x\u2225) s a", "decl_nm": "continuous_within_at.norm"}
{"formal_statement": "theorem coe_ideal_le_coe_ideal' {R : Type*} [comm_ring R] (S : submonoid R)\n\t{P : Type*} [comm_ring P] [algebra R P] [is_localization S P] (h : S \u2264 non_zero_divisors R) :\n\t\u2200 {I J : ideal R}, \u2191I \u2264 \u2191J \u2194 I \u2264 J", "decl_tp": "\u2200 {R : Type u_1} [_inst_1 : comm_ring R] (S : submonoid R) {P : Type u_2} [_inst_2 : comm_ring P] [_inst_3 : algebra R P] [_inst_4 : is_localization S P], S \u2264 non_zero_divisors R \u2192 \u2200 {I J : ideal R}, \u2191I \u2264 \u2191J \u2194 I \u2264 J", "decl_nm": "fractional_ideal.coe_ideal_le_coe_ideal'"}
{"formal_statement": "theorem functions_ext' {I : Type*} [decidable_eq I] {Z : I \u2192 Type*} [\u03a0 (i : I), add_comm_monoid (Z i)]\n\t[fintype I] (M : Type*) [add_comm_monoid M] (g h : (\u03a0 (i : I), Z i) \u2192+ M) :\n\t(\u2200 (i : I), g.comp (add_monoid_hom.single Z i) = h.comp (add_monoid_hom.single Z i)) \u2192 g = h", "decl_tp": "\u2200 {I : Type u_1} [_inst_1 : decidable_eq I] {Z : I \u2192 Type u_2} [_inst_2 : \u03a0 (i : I), add_comm_monoid (Z i)] [_inst_3 : fintype I] (M : Type u_3) [_inst_4 : add_comm_monoid M] (g h : (\u03a0 (i : I), Z i) \u2192+ M), (\u2200 (i : I), g.comp (add_monoid_hom.single Z i) = h.comp (add_monoid_hom.single Z i)) \u2192 g = h", "decl_nm": "add_monoid_hom.functions_ext'"}
{"formal_statement": "theorem log_eq_zero_iff {b n : \u2115} :\n\tnat.log b n = 0 \u2194 n < b \u2228 b \u2264 1", "decl_tp": "\u2200 {b n : \u2115}, nat.log b n = 0 \u2194 n < b \u2228 b \u2264 1", "decl_nm": "nat.log_eq_zero_iff"}
{"formal_statement": "theorem powers_fg {M : Type*} [monoid M] (r : M) :\n\t(submonoid.powers r).fg", "decl_tp": "\u2200 {M : Type u_1} [_inst_1 : monoid M] (r : M), (submonoid.powers r).fg", "decl_nm": "submonoid.powers_fg"}
{"formal_statement": "theorem inv_lt_inv {\u03b1 : Type*} [linear_ordered_field \u03b1] {a b : \u03b1} (ha : 0 < a)\n\t(hb : 0 < b) :\n\t(a\u207b\u00b9 < b\u207b\u00b9 \u2194 b < a)", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : linear_ordered_field \u03b1] {a b : \u03b1}, 0 < a \u2192 0 < b \u2192 (a\u207b\u00b9 < b\u207b\u00b9 \u2194 b < a)", "decl_nm": "inv_lt_inv"}
{"formal_statement": "theorem continuous_curry {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} [topological_space \u03b1]\n\t[topological_space \u03b2] [topological_space \u03b3] {g : \u03b1 \u00d7 \u03b2 \u2192 \u03b3} (a : \u03b1) (h : continuous g) :\n\tcontinuous (function.curry g a)", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} [_inst_1 : topological_space \u03b1] [_inst_2 : topological_space \u03b2] [_inst_3 : topological_space \u03b3] {g : \u03b1 \u00d7 \u03b2 \u2192 \u03b3} (a : \u03b1), continuous g \u2192 continuous (function.curry g a)", "decl_nm": "continuous_curry"}
{"formal_statement": "theorem imp_intro {\u03b1 \u03b2 : Prop} (h : \u03b1) (_x : \u03b2) :\n\t\u03b1", "decl_tp": "\u2200 {\u03b1 \u03b2 : Prop}, \u03b1 \u2192 \u03b2 \u2192 \u03b1", "decl_nm": "imp_intro"}
{"formal_statement": "theorem symm_image_eq_source_inter_preimage {\u03b1 \u03b2 : Type*} (e : local_equiv \u03b1 \u03b2)\n\t{s : set \u03b2} (h : s \u2286 e.target) :\n\t\u21d1(e.symm) '' s = e.source \u2229 \u21d1e \u207b\u00b9' s", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} (e : local_equiv \u03b1 \u03b2) {s : set \u03b2}, s \u2286 e.target \u2192 \u21d1(e.symm) '' s = e.source \u2229 \u21d1e \u207b\u00b9' s", "decl_nm": "local_equiv.symm_image_eq_source_inter_preimage"}
{"formal_statement": "theorem re {\u03b1 \ud835\udd5c : Type*} [is_R_or_C \ud835\udd5c] [measurable_space \u03b1] {f : \u03b1 \u2192 \ud835\udd5c}\n\t(hf : measurable f) :\n\tmeasurable (\u03bb (x : \u03b1), \u21d1is_R_or_C.re (f x))", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\ud835\udd5c : Type u_2} [_inst_1 : is_R_or_C \ud835\udd5c] [_inst_2 : measurable_space \u03b1] {f : \u03b1 \u2192 \ud835\udd5c}, measurable f \u2192 measurable (\u03bb (x : \u03b1), \u21d1is_R_or_C.re (f x))", "decl_nm": "measurable.re"}
{"formal_statement": "theorem coe_one (\u03b1 : Type u) :\n\t\u21911 = 1", "decl_tp": "\u2200 (\u03b1 : Type u), \u21911 = 1", "decl_nm": "free_ring.coe_one"}
{"formal_statement": "theorem surjective {\ud835\udd5c V V\u2082 P P\u2082 : Type*} [normed_field \ud835\udd5c] [semi_normed_group V]\n\t[semi_normed_group V\u2082] [semi_normed_space \ud835\udd5c V] [semi_normed_space \ud835\udd5c V\u2082]\n\t[pseudo_metric_space P] [pseudo_metric_space P\u2082] [semi_normed_add_torsor V P]\n\t[semi_normed_add_torsor V\u2082 P\u2082] (e : P \u2243\u1d43\u2071[\ud835\udd5c] P\u2082) :\n\tfunction.surjective \u21d1e", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} {V : Type u_2} {V\u2082 : Type u_4} {P : Type u_8} {P\u2082 : Type u_9} [_inst_1 : normed_field \ud835\udd5c] [_inst_2 : semi_normed_group V] [_inst_4 : semi_normed_group V\u2082] [_inst_7 : semi_normed_space \ud835\udd5c V] [_inst_9 : semi_normed_space \ud835\udd5c V\u2082] [_inst_12 : pseudo_metric_space P] [_inst_14 : pseudo_metric_space P\u2082] [_inst_17 : semi_normed_add_torsor V P] [_inst_19 : semi_normed_add_torsor V\u2082 P\u2082] (e : P \u2243\u1d43\u2071[\ud835\udd5c] P\u2082), function.surjective \u21d1e", "decl_nm": "affine_isometry_equiv.surjective"}
{"formal_statement": "theorem kronecker_map_add_right {\u03b1 \u03b2 \u03b3 l m n : Type*0} {p : Type*1} [has_add \u03b2]\n\t[has_add \u03b3] (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) :\n\t(\u2200 (a : \u03b1) (b\u2081 b\u2082 : \u03b2), f a (b\u2081 + b\u2082) = f a b\u2081 + f a b\u2082) \u2192 \u2200 (A : matrix l m \u03b1)\n\t(B\u2081 B\u2082 : matrix n p \u03b2), matrix.kronecker_map f A (B\u2081 + B\u2082) = matrix.kronecker_map f A B\u2081 + matrix.kronecker_map f A B\u2082", "decl_tp": "\u2200 {\u03b1 : Type u_2} {\u03b2 : Type u_4} {\u03b3 : Type u_6} {l : Type u_8} {m : Type u_9} {n : Type u_10} {p : Type u_11} [_inst_1 : has_add \u03b2] [_inst_2 : has_add \u03b3] (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3), (\u2200 (a : \u03b1) (b\u2081 b\u2082 : \u03b2), f a (b\u2081 + b\u2082) = f a b\u2081 + f a b\u2082) \u2192 \u2200 (A : matrix l m \u03b1) (B\u2081 B\u2082 : matrix n p \u03b2), matrix.kronecker_map f A (B\u2081 + B\u2082) = matrix.kronecker_map f A B\u2081 + matrix.kronecker_map f A B\u2082", "decl_nm": "matrix.kronecker_map_add_right"}
{"formal_statement": "theorem sdiff_compl {\u03b1 : Type u} {x y : \u03b1} [boolean_algebra \u03b1] :\n\tx \\ y\u1d9c = x \u2293 y", "decl_tp": "\u2200 {\u03b1 : Type u} {x y : \u03b1} [_inst_1 : boolean_algebra \u03b1], x \\ y\u1d9c = x \u2293 y", "decl_nm": "sdiff_compl"}
{"formal_statement": "theorem first_wins_symm' (G : pgame) [G.impartial] :\n\tG.first_wins \u2194 0 < G", "decl_tp": "\u2200 (G : pgame) [_inst_1 : G.impartial], G.first_wins \u2194 0 < G", "decl_nm": "pgame.impartial.first_wins_symm'"}
{"formal_statement": "theorem dual {\u03b1 : Type u} [preorder \u03b1] {s : set \u03b1} (h : bdd_below s) :\n\tbdd_above (\u21d1order_dual.of_dual \u207b\u00b9' s)", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : preorder \u03b1] {s : set \u03b1}, bdd_below s \u2192 bdd_above (\u21d1order_dual.of_dual \u207b\u00b9' s)", "decl_nm": "bdd_below.dual"}
{"formal_statement": "theorem indicator_neg {\u03b1 G : Type*} [add_group G] (s : set \u03b1) (f : \u03b1 \u2192 G) :\n\ts.indicator (\u03bb (a : \u03b1), -f a) = \u03bb (a : \u03b1), -s.indicator f a", "decl_tp": "\u2200 {\u03b1 : Type u_1} {G : Type u_6} [_inst_1 : add_group G] (s : set \u03b1) (f : \u03b1 \u2192 G), s.indicator (\u03bb (a : \u03b1), -f a) = \u03bb (a : \u03b1), -s.indicator f a", "decl_nm": "set.indicator_neg"}
{"formal_statement": "theorem one_apply {R : Type u} {A : Type v} [monoid R] [non_unital_non_assoc_semiring A]\n\t[distrib_mul_action R A] (a : A) :\n\t\u21d11 a = a", "decl_tp": "\u2200 {R : Type u} {A : Type v} [_inst_1 : monoid R] [_inst_2 : non_unital_non_assoc_semiring A] [_inst_3 : distrib_mul_action R A] (a : A), \u21d11 a = a", "decl_nm": "non_unital_alg_hom.one_apply"}
{"formal_statement": "theorem integrable_on_iff {G \u03b1 E : Type*} [group G] [mul_action G \u03b1] [measurable_space \u03b1]\n\t[normed_group E] {s t : set \u03b1} {\u03bc : measure_theory.measure \u03b1} [measurable_space G]\n\t[has_measurable_smul G \u03b1] [measure_theory.smul_invariant_measure G \u03b1 \u03bc]\n\t[encodable G] [measurable_space E] (hs : measure_theory.is_fundamental_domain G s \u03bc)\n\t(ht : measure_theory.is_fundamental_domain G t \u03bc) :\n\t\u2200 {f : \u03b1 \u2192 E}, (\u2200 (g : G) (x : \u03b1), f (g \u2022 x) = f x) \u2192 (measure_theory.integrable_on f s \u03bc \u2194 measure_theory.integrable_on f t \u03bc)", "decl_tp": "\u2200 {G : Type u_1} {\u03b1 : Type u_2} {E : Type u_3} [_inst_1 : group G] [_inst_2 : mul_action G \u03b1] [_inst_3 : measurable_space \u03b1] [_inst_4 : normed_group E] {s t : set \u03b1} {\u03bc : measure_theory.measure \u03b1} [_inst_5 : measurable_space G] [_inst_6 : has_measurable_smul G \u03b1] [_inst_7 : measure_theory.smul_invariant_measure G \u03b1 \u03bc] [_inst_8 : encodable G] [_inst_9 : measurable_space E], measure_theory.is_fundamental_domain G s \u03bc \u2192 measure_theory.is_fundamental_domain G t \u03bc \u2192 \u2200 {f : \u03b1 \u2192 E}, (\u2200 (g : G) (x : \u03b1), f (g \u2022 x) = f x) \u2192 (measure_theory.integrable_on f s \u03bc \u2194 measure_theory.integrable_on f t \u03bc)", "decl_nm": "measure_theory.is_fundamental_domain.integrable_on_iff"}
{"formal_statement": "theorem eval_from_of_pow {\u03b1 : Type u} {\u03c3 : Type v} (M : DFA \u03b1 \u03c3) {x y : list \u03b1}\n\t{s : \u03c3} (hx : M.eval_from s x = s) (hy : y \u2208 {x}.star) :\n\tM.eval_from s y = s", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03c3 : Type v} (M : DFA \u03b1 \u03c3) {x y : list \u03b1} {s : \u03c3}, M.eval_from s x = s \u2192 y \u2208 {x}.star \u2192 M.eval_from s y = s", "decl_nm": "DFA.eval_from_of_pow"}
{"formal_statement": "theorem measurable_of_tendsto_nnreal {\u03b1 : Type*} [measurable_space \u03b1] {f : \u2115 \u2192 \u03b1 \u2192 nnreal}\n\t{g : \u03b1 \u2192 nnreal} (lim : filter.tendsto f filter.at_top (nhds g)) :\n\t(\u2200 (i : \u2115), measurable (f i)) \u2192  measurable g", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : measurable_space \u03b1] {f : \u2115 \u2192 \u03b1 \u2192 nnreal} {g : \u03b1 \u2192 nnreal}, (\u2200 (i : \u2115), measurable (f i)) \u2192 filter.tendsto f filter.at_top (nhds g) \u2192 measurable g", "decl_nm": "measurable_of_tendsto_nnreal"}
{"formal_statement": "theorem mem_coe_ideal_of_mem {R : Type*} [comm_ring R] (S : submonoid R)\n\t{P : Type*} [comm_ring P] [algebra R P] {x : R} {I : ideal R} (hx : x \u2208 I) :\n\t\u21d1(algebra_map R P) x \u2208 \u2191I", "decl_tp": "\u2200 {R : Type u_1} [_inst_1 : comm_ring R] (S : submonoid R) {P : Type u_2} [_inst_2 : comm_ring P] [_inst_3 : algebra R P] {x : R} {I : ideal R}, x \u2208 I \u2192 \u21d1(algebra_map R P) x \u2208 \u2191I", "decl_nm": "fractional_ideal.mem_coe_ideal_of_mem"}
{"formal_statement": "theorem log {\u03b1 : Type*} [topological_space \u03b1] {f : \u03b1 \u2192 \u211d} (hf : continuous f) :\n\t(\u2200 (x : \u03b1), f x \u2260 0) \u2192 continuous (\u03bb (x : \u03b1), real.log (f x))", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : topological_space \u03b1] {f : \u03b1 \u2192 \u211d}, continuous f \u2192 (\u2200 (x : \u03b1), f x \u2260 0) \u2192 continuous (\u03bb (x : \u03b1), real.log (f x))", "decl_nm": "continuous.log"}
{"formal_statement": "theorem prod_comp {R : Type*} [comm_semiring R] (s : multiset (polynomial R))\n\t(p : polynomial R) :\n\ts.prod.comp p = (multiset.map (\u03bb (q : polynomial R), q.comp p) s).prod", "decl_tp": "\u2200 {R : Type u_1} [_inst_2 : comm_semiring R] (s : multiset (polynomial R)) (p : polynomial R), s.prod.comp p = (multiset.map (\u03bb (q : polynomial R), q.comp p) s).prod", "decl_nm": "polynomial.prod_comp"}
{"formal_statement": "theorem iso_mk_inv_right {C : Type u\u2081} [category_theory.category C] {D : Type u\u2082}\n\t[category_theory.category D] {S : D} {T : C \u2964 D} {f f' : category_theory.structured_arrow S T}\n\t(g : f.right \u2245 f'.right) (w : f.hom \u226b T.map g.hom = f'.hom) :\n\t(category_theory.structured_arrow.iso_mk g w).inv.right = g.inv", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {D : Type u\u2082} [_inst_2 : category_theory.category D] {S : D} {T : C \u2964 D} {f f' : category_theory.structured_arrow S T} (g : f.right \u2245 f'.right) (w : f.hom \u226b T.map g.hom = f'.hom), (category_theory.structured_arrow.iso_mk g w).inv.right = g.inv", "decl_nm": "category_theory.structured_arrow.iso_mk_inv_right"}
{"formal_statement": "theorem coe_zero {R R\u2082 M M\u2082 : Type*2} [semiring R] [semiring R\u2082] [add_comm_monoid M]\n\t[add_comm_monoid M\u2082] [module R M] [module R\u2082 M\u2082] [subsingleton M] [subsingleton M\u2082]\n\t{\u03c3\u2081\u2082 : R \u2192+* R\u2082} {\u03c3\u2082\u2081 : R\u2082 \u2192+* R} [ring_hom_inv_pair \u03c3\u2081\u2082 \u03c3\u2082\u2081] [ring_hom_inv_pair \u03c3\u2082\u2081 \u03c3\u2081\u2082] :\n\t\u21d10 = 0", "decl_tp": "\u2200 {R : Type u_1} {R\u2082 : Type u_3} {M : Type u_9} {M\u2082 : Type u_12} [_inst_1 : semiring R] [_inst_2 : semiring R\u2082] [_inst_5 : add_comm_monoid M] [_inst_6 : add_comm_monoid M\u2082] [_inst_9 : module R M] [_inst_10 : module R\u2082 M\u2082] [_inst_11 : subsingleton M] [_inst_12 : subsingleton M\u2082] {\u03c3\u2081\u2082 : R \u2192+* R\u2082} {\u03c3\u2082\u2081 : R\u2082 \u2192+* R} [_inst_13 : ring_hom_inv_pair \u03c3\u2081\u2082 \u03c3\u2082\u2081] [_inst_14 : ring_hom_inv_pair \u03c3\u2082\u2081 \u03c3\u2081\u2082], \u21d10 = 0", "decl_nm": "linear_equiv.coe_zero"}
{"formal_statement": "theorem map_homotopy_category_obj {\u03b9 : Type*} {V : Type u} [category_theory.category V]\n\t[category_theory.preadditive V] {W : Type*} [category_theory.category W]\n\t[category_theory.preadditive W] (c : complex_shape \u03b9) (F : V \u2964 W) [F.additive]\n\t(C : homotopy_category V c) :\n\t(category_theory.functor.map_homotopy_category c F).obj C = (homotopy_category.quotient W c).obj ((F.map_homological_complex c).obj C.as)", "decl_tp": "\u2200 {\u03b9 : Type u_1} {V : Type u} [_inst_1 : category_theory.category V] [_inst_2 : category_theory.preadditive V] {W : Type u_2} [_inst_3 : category_theory.category W] [_inst_4 : category_theory.preadditive W] (c : complex_shape \u03b9) (F : V \u2964 W) [_inst_5 : F.additive] (C : homotopy_category V c), (category_theory.functor.map_homotopy_category c F).obj C = (homotopy_category.quotient W c).obj ((F.map_homological_complex c).obj C.as)", "decl_nm": "category_theory.functor.map_homotopy_category_obj"}
{"formal_statement": "theorem sum_smul_index {\u03b1 M R : Type*1} [semiring R] [add_comm_monoid M]\n\t{g : \u03b1 \u2192\u2080 R} {b : R} {h : \u03b1 \u2192 R \u2192 M} :\n\t(\u2200 (i : \u03b1), h i 0 = 0) \u2192 (b \u2022 g).sum h = g.sum (\u03bb (i : \u03b1) (a : R), h i (b * a))", "decl_tp": "\u2200 {\u03b1 : Type u_1} {M : Type u_5} {R : Type u_11} [_inst_1 : semiring R] [_inst_2 : add_comm_monoid M] {g : \u03b1 \u2192\u2080 R} {b : R} {h : \u03b1 \u2192 R \u2192 M}, (\u2200 (i : \u03b1), h i 0 = 0) \u2192 (b \u2022 g).sum h = g.sum (\u03bb (i : \u03b1) (a : R), h i (b * a))", "decl_nm": "finsupp.sum_smul_index"}
{"formal_statement": "theorem deriv_within_const_smul {\ud835\udd5c : Type u} [nondiscrete_normed_field \ud835\udd5c]\n\t{F : Type v} [normed_group F] [normed_space \ud835\udd5c F] {f : \ud835\udd5c \u2192 F} {x : \ud835\udd5c} {s : set \ud835\udd5c}\n\t{R : Type*} [semiring R] [module R F] [topological_space R] [smul_comm_class \ud835\udd5c R F]\n\t[has_continuous_smul R F] (hxs : unique_diff_within_at \ud835\udd5c s x) (hf : differentiable_within_at \ud835\udd5c f s x) :\n\t\u2200 (c : R),  deriv_within (\u03bb (y : \ud835\udd5c), c \u2022 f y) s x = c \u2022 deriv_within f s x", "decl_tp": "\u2200 {\ud835\udd5c : Type u} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {F : Type v} [_inst_2 : normed_group F] [_inst_3 : normed_space \ud835\udd5c F] {f : \ud835\udd5c \u2192 F} {x : \ud835\udd5c} {s : set \ud835\udd5c} {R : Type u_1} [_inst_6 : semiring R] [_inst_7 : module R F] [_inst_8 : topological_space R] [_inst_9 : smul_comm_class \ud835\udd5c R F] [_inst_10 : has_continuous_smul R F], unique_diff_within_at \ud835\udd5c s x \u2192 \u2200 (c : R), differentiable_within_at \ud835\udd5c f s x \u2192 deriv_within (\u03bb (y : \ud835\udd5c), c \u2022 f y) s x = c \u2022 deriv_within f s x", "decl_nm": "deriv_within_const_smul"}
{"formal_statement": "theorem dist_eq {\u03b1 : Type u} {\u03b2 : Type v} [pseudo_metric_space \u03b1] [pseudo_metric_space \u03b2]\n\t{f : \u03b1 \u2192 \u03b2} (hf : isometry f) :\n\t\u2200 (x y : \u03b1), has_dist.dist (f x) (f y) = has_dist.dist x y", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : pseudo_metric_space \u03b1] [_inst_2 : pseudo_metric_space \u03b2] {f : \u03b1 \u2192 \u03b2}, isometry f \u2192 \u2200 (x y : \u03b1), has_dist.dist (f x) (f y) = has_dist.dist x y", "decl_nm": "isometry.dist_eq"}
{"formal_statement": "theorem mul_factorial_pred {n : \u2115} (hn : 0 < n) :\n\tn * (n - 1).factorial = n.factorial", "decl_tp": "\u2200 {n : \u2115}, 0 < n \u2192 n * (n - 1).factorial = n.factorial", "decl_nm": "nat.mul_factorial_pred"}
{"formal_statement": "theorem sub_apply {V\u2081 V\u2082 : Type*} [semi_normed_group V\u2081] [semi_normed_group V\u2082]\n\t(f g : normed_group_hom V\u2081 V\u2082) (v : V\u2081) :\n\t\u21d1(f - g) v = \u21d1f v - \u21d1g v", "decl_tp": "\u2200 {V\u2081 : Type u_2} {V\u2082 : Type u_3} [_inst_2 : semi_normed_group V\u2081] [_inst_3 : semi_normed_group V\u2082] (f g : normed_group_hom V\u2081 V\u2082) (v : V\u2081), \u21d1(f - g) v = \u21d1f v - \u21d1g v", "decl_nm": "normed_group_hom.sub_apply"}
{"formal_statement": "theorem open_embedding_coe {X : Type*} [topological_space X] :\n\topen_embedding coe", "decl_tp": "\u2200 {X : Type u_1} [_inst_1 : topological_space X], open_embedding coe", "decl_nm": "alexandroff.open_embedding_coe"}
{"formal_statement": "theorem comap_comap {K : Type u} {L : Type v} {M : Type w} [field K] [field L]\n\t[field M] (s : subfield M) (g : L \u2192+* M) (f : K \u2192+* L) :\n\tsubfield.comap f (subfield.comap g s) = subfield.comap (g.comp f) s", "decl_tp": "\u2200 {K : Type u} {L : Type v} {M : Type w} [_inst_1 : field K] [_inst_2 : field L] [_inst_3 : field M] (s : subfield M) (g : L \u2192+* M) (f : K \u2192+* L), subfield.comap f (subfield.comap g s) = subfield.comap (g.comp f) s", "decl_nm": "subfield.comap_comap"}
{"formal_statement": "theorem mul_right {\u03b1 \u03b2 : Type*} [semiring \u03b1] [topological_space \u03b1] [topological_ring \u03b1]\n\t{f : \u03b2 \u2192 \u03b1} (a : \u03b1) (hf : summable f) :\n\tsummable (\u03bb (b : \u03b2), f b * a)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : semiring \u03b1] [_inst_2 : topological_space \u03b1] [_inst_3 : topological_ring \u03b1] {f : \u03b2 \u2192 \u03b1} (a : \u03b1), summable f \u2192 summable (\u03bb (b : \u03b2), f b * a)", "decl_nm": "summable.mul_right"}
{"formal_statement": "theorem seq_apply {\u03b1 \u03b2 \u03b3 : Type*} [measurable_space \u03b1] (f : measure_theory.simple_func \u03b1 (\u03b2 \u2192 \u03b3))\n\t(g : measure_theory.simple_func \u03b1 \u03b2) (a : \u03b1) :\n\t\u21d1(f.seq g) a = \u21d1f a (\u21d1g a)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {\u03b3 : Type u_3} [_inst_1 : measurable_space \u03b1] (f : measure_theory.simple_func \u03b1 (\u03b2 \u2192 \u03b3)) (g : measure_theory.simple_func \u03b1 \u03b2) (a : \u03b1), \u21d1(f.seq g) a = \u21d1f a (\u21d1g a)", "decl_nm": "measure_theory.simple_func.seq_apply"}
{"formal_statement": "theorem tendsto_pow_at_top_nhds_within_0_of_lt_1 {\ud835\udd5c : Type*} [linear_ordered_field \ud835\udd5c]\n\t[archimedean \ud835\udd5c] [topological_space \ud835\udd5c] [order_topology \ud835\udd5c] {r : \ud835\udd5c} (h\u2081 : 0 < r)\n\t(h\u2082 : r < 1) :\n\tfilter.tendsto (\u03bb (n : \u2115), r ^ n) filter.at_top (nhds_within 0 (set.Ioi 0))", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : linear_ordered_field \ud835\udd5c] [_inst_2 : archimedean \ud835\udd5c] [_inst_3 : topological_space \ud835\udd5c] [_inst_4 : order_topology \ud835\udd5c] {r : \ud835\udd5c}, 0 < r \u2192 r < 1 \u2192 filter.tendsto (\u03bb (n : \u2115), r ^ n) filter.at_top (nhds_within 0 (set.Ioi 0))", "decl_nm": "tendsto_pow_at_top_nhds_within_0_of_lt_1"}
{"formal_statement": "theorem mem_circle_iff_abs {z : \u2102} :\n\tz \u2208 circle \u2194 complex.abs z = 1", "decl_tp": "\u2200 {z : \u2102}, z \u2208 circle \u2194 complex.abs z = 1", "decl_nm": "mem_circle_iff_abs"}
{"formal_statement": "theorem bijective_iff_exists_unique {\u03b1 : Sort u_1} {\u03b2 : Sort u_2} (f : \u03b1 \u2192 \u03b2) :\n\tfunction.bijective f \u2194 \u2200 (b : \u03b2), \u2203! (a : \u03b1), f a = b", "decl_tp": "\u2200 {\u03b1 : Sort u_1} {\u03b2 : Sort u_2} (f : \u03b1 \u2192 \u03b2), function.bijective f \u2194 \u2200 (b : \u03b2), \u2203! (a : \u03b1), f a = b", "decl_nm": "function.bijective_iff_exists_unique"}
{"formal_statement": "theorem sub_f_apply {\u03b9 : Type*} {V : Type u} [category_theory.category V]\n\t[category_theory.preadditive V] {c : complex_shape \u03b9} {C D : homological_complex V c}\n\t(f g : C \u27f6 D) (i : \u03b9) :\n\t(f - g).f i = f.f i - g.f i", "decl_tp": "\u2200 {\u03b9 : Type u_1} {V : Type u} [_inst_1 : category_theory.category V] [_inst_2 : category_theory.preadditive V] {c : complex_shape \u03b9} {C D : homological_complex V c} (f g : C \u27f6 D) (i : \u03b9), (f - g).f i = f.f i - g.f i", "decl_nm": "homological_complex.sub_f_apply"}
{"formal_statement": "theorem xgcd_val {R : Type u} [euclidean_domain R] [decidable_eq R] (x y : R) :\n\teuclidean_domain.xgcd x y = (euclidean_domain.gcd_a x y, euclidean_domain.gcd_b x y)", "decl_tp": "\u2200 {R : Type u} [_inst_1 : euclidean_domain R] [_inst_2 : decidable_eq R] (x y : R), euclidean_domain.xgcd x y = (euclidean_domain.gcd_a x y, euclidean_domain.gcd_b x y)", "decl_nm": "euclidean_domain.xgcd_val"}
{"formal_statement": "theorem eval\u2082_denom_ne_zero {K : Type u} [hfield : field K] {L : Type*}\n\t[field L] {f : K \u2192+* L} {a : L} {x : ratfunc K} (h : ratfunc.eval f a x \u2260 0) :\n\tpolynomial.eval\u2082 f a x.denom \u2260 0", "decl_tp": "\u2200 {K : Type u} [hfield : field K] {L : Type u_1} [_inst_1 : field L] {f : K \u2192+* L} {a : L} {x : ratfunc K}, ratfunc.eval f a x \u2260 0 \u2192 polynomial.eval\u2082 f a x.denom \u2260 0", "decl_nm": "ratfunc.eval\u2082_denom_ne_zero"}
{"formal_statement": "theorem add_comm {\u03b1 : Type*} {s t : finset \u03b1} [decidable_eq \u03b1] [add_comm_semigroup \u03b1] :\n\ts + t = t + s", "decl_tp": "\u2200 {\u03b1 : Type u_1} {s t : finset \u03b1} [_inst_1 : decidable_eq \u03b1] [_inst_2 : add_comm_semigroup \u03b1], s + t = t + s", "decl_nm": "finset.add_comm"}
{"formal_statement": "theorem coe_mul {\u03b1 : Type u} [has_mul \u03b1] (a b : \u03b1) :\n\t\u2191(a * b) = \u2191a * \u2191b", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : has_mul \u03b1] (a b : \u03b1), \u2191(a * b) = \u2191a * \u2191b", "decl_nm": "with_one.coe_mul"}
{"formal_statement": "theorem injective_iff_ker_bot {\u03b1 \u03b2 : Type*} (f : \u03b1 \u2192 \u03b2) :\n\tfunction.injective f \u2194 setoid.ker f = \u22a5", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} (f : \u03b1 \u2192 \u03b2), function.injective f \u2194 setoid.ker f = \u22a5", "decl_nm": "setoid.injective_iff_ker_bot"}
{"formal_statement": "theorem monotone_image {\u03b1 \u03b2 : Type*} {f : \u03b1 \u2192 \u03b2} :\n\tmonotone (set.image f)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {f : \u03b1 \u2192 \u03b2}, monotone (set.image f)", "decl_nm": "set.monotone_image"}
{"formal_statement": "theorem Sup_le_Sup_of_subset_insert_bot {\u03b1 : Type*} [complete_lattice \u03b1]\n\t{s t : set \u03b1} (h : s \u2286 has_insert.insert \u22a5 t) :\n\thas_Sup.Sup s \u2264 has_Sup.Sup t", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : complete_lattice \u03b1] {s t : set \u03b1}, s \u2286 has_insert.insert \u22a5 t \u2192 has_Sup.Sup s \u2264 has_Sup.Sup t", "decl_nm": "Sup_le_Sup_of_subset_insert_bot"}
{"formal_statement": "theorem lift_comm {C : Type u\u2081} [category_theory.category C] {X Y : C}\n\t(F : category_theory.over Y \u2964 category_theory.over X) (h : \u2200 (f : category_theory.mono_over Y), category_theory.mono (F.obj ((category_theory.mono_over.forget Y).obj f)).hom) :\n\tcategory_theory.mono_over.lift F h \u22d9 category_theory.mono_over.forget X = category_theory.mono_over.forget Y \u22d9 F", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {X Y : C} (F : category_theory.over Y \u2964 category_theory.over X) (h : \u2200 (f : category_theory.mono_over Y), category_theory.mono (F.obj ((category_theory.mono_over.forget Y).obj f)).hom), category_theory.mono_over.lift F h \u22d9 category_theory.mono_over.forget X = category_theory.mono_over.forget Y \u22d9 F", "decl_nm": "category_theory.mono_over.lift_comm"}
{"formal_statement": "theorem ne_of_adj {V : Type u} (G : simple_graph V) {a b : V} (h : G.adj a b) :\n\ta \u2260 b", "decl_tp": "\u2200 {V : Type u} (G : simple_graph V) {a b : V}, G.adj a b \u2192 a \u2260 b", "decl_nm": "simple_graph.ne_of_adj"}
{"formal_statement": "theorem mem_neighbor_set {V : Type u} (G : simple_graph V) (v w : V) :\n\tw \u2208 G.neighbor_set v \u2194 G.adj v w", "decl_tp": "\u2200 {V : Type u} (G : simple_graph V) (v w : V), w \u2208 G.neighbor_set v \u2194 G.adj v w", "decl_nm": "simple_graph.mem_neighbor_set"}
{"formal_statement": "theorem ext {\u03b9 : Type u} {\u03b2 : \u03b9 \u2192 Type v} [\u03a0 (i : \u03b9), has_zero (\u03b2 i)] {f g : \u03a0\u2080 (i : \u03b9), \u03b2 i} :\n\t(\u2200 (i : \u03b9), \u21d1f i = \u21d1g i) \u2192 f = g", "decl_tp": "\u2200 {\u03b9 : Type u} {\u03b2 : \u03b9 \u2192 Type v} [_inst_1 : \u03a0 (i : \u03b9), has_zero (\u03b2 i)] {f g : \u03a0\u2080 (i : \u03b9), \u03b2 i}, (\u2200 (i : \u03b9), \u21d1f i = \u21d1g i) \u2192 f = g", "decl_nm": "dfinsupp.ext"}
{"formal_statement": "theorem sum_elim_inr {\u03b1 \u03b2 \u03b3 : Type*} [has_zero \u03b3] (f : \u03b1 \u2192\u2080 \u03b3) (g : \u03b2 \u2192\u2080 \u03b3)\n\t(x : \u03b2) :\n\t\u21d1(f.sum_elim g) (sum.inr x) = \u21d1g x", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {\u03b3 : Type u_3} [_inst_1 : has_zero \u03b3] (f : \u03b1 \u2192\u2080 \u03b3) (g : \u03b2 \u2192\u2080 \u03b3) (x : \u03b2), \u21d1(f.sum_elim g) (sum.inr x) = \u21d1g x", "decl_nm": "finsupp.sum_elim_inr"}
{"formal_statement": "theorem add {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c] {E : Type*} [normed_group E]\n\t[normed_space \ud835\udd5c E] {F : Type*} [normed_group F] [normed_space \ud835\udd5c F] {f g : E \u2192 F}\n\t{x : E} {s : set E} (hf : differentiable_within_at \ud835\udd5c f s x) (hg : differentiable_within_at \ud835\udd5c g s x) :\n\tdifferentiable_within_at \ud835\udd5c (\u03bb (y : E), f y + g y) s x", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {F : Type u_3} [_inst_4 : normed_group F] [_inst_5 : normed_space \ud835\udd5c F] {f g : E \u2192 F} {x : E} {s : set E}, differentiable_within_at \ud835\udd5c f s x \u2192 differentiable_within_at \ud835\udd5c g s x \u2192 differentiable_within_at \ud835\udd5c (\u03bb (y : E), f y + g y) s x", "decl_nm": "differentiable_within_at.add"}
{"formal_statement": "theorem head_cons {\u03b1 : Type u} {m : \u2115} (x : \u03b1) (u : fin m \u2192 \u03b1) :\n\tmatrix.vec_head (matrix.vec_cons x u) = x", "decl_tp": "\u2200 {\u03b1 : Type u} {m : \u2115} (x : \u03b1) (u : fin m \u2192 \u03b1), matrix.vec_head (matrix.vec_cons x u) = x", "decl_nm": "matrix.head_cons"}
{"formal_statement": "theorem tendsto_comp {\u03b1 \u03b2 \u03b9 : Type*} [uniform_space \u03b2] {F : \u03b9 \u2192 \u03b1 \u2192 \u03b2}\n\t{f : \u03b1 \u2192 \u03b2} {x : \u03b1} {p : filter \u03b9} {g : \u03b9 \u2192 \u03b1} [topological_space \u03b1] (h : tendsto_uniformly F f p)\n\t(hf : continuous_at f x) (hg : filter.tendsto g p (nhds x)) :\n\tfilter.tendsto (\u03bb (n : \u03b9), F n (g n)) p (nhds (f x))", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {\u03b9 : Type u_4} [_inst_1 : uniform_space \u03b2] {F : \u03b9 \u2192 \u03b1 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2} {x : \u03b1} {p : filter \u03b9} {g : \u03b9 \u2192 \u03b1} [_inst_2 : topological_space \u03b1], tendsto_uniformly F f p \u2192 continuous_at f x \u2192 filter.tendsto g p (nhds x) \u2192 filter.tendsto (\u03bb (n : \u03b9), F n (g n)) p (nhds (f x))", "decl_nm": "tendsto_uniformly.tendsto_comp"}
{"formal_statement": "theorem mem_restrict {\u03b1 \u03b2 : Type*} {f : \u03b1 \u2192. \u03b2} {s : set \u03b1} (h : s \u2286 f.dom)\n\t(a : \u03b1) (b : \u03b2) :\n\tb \u2208 f.restrict h a \u2194 a \u2208 s \u2227 b \u2208 f a", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {f : \u03b1 \u2192. \u03b2} {s : set \u03b1} (h : s \u2286 f.dom) (a : \u03b1) (b : \u03b2), b \u2208 f.restrict h a \u2194 a \u2208 s \u2227 b \u2208 f a", "decl_nm": "pfun.mem_restrict"}
{"formal_statement": "theorem bernoulli_one :\n\tbernoulli 1 = (-1) / 2", "decl_tp": "bernoulli 1 = (-1) / 2", "decl_nm": "bernoulli_one"}
{"formal_statement": "theorem update_preimage_pi {\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} {s : set \u03b9} {t : \u03a0 (i : \u03b9), set (\u03b1 i)}\n\t{i : \u03b9} [decidable_eq \u03b9] {f : \u03a0 (i : \u03b9), \u03b1 i} (hi : i \u2208 s) (hj : j \u2208 s) :\n\t(\u2200 (j : \u03b9),  j \u2260 i \u2192 f j \u2208 t j) \u2192 function.update f i \u207b\u00b9' s.pi t = t i", "decl_tp": "\u2200 {\u03b9 : Type u_1} {\u03b1 : \u03b9 \u2192 Type u_2} {s : set \u03b9} {t : \u03a0 (i : \u03b9), set (\u03b1 i)} {i : \u03b9} [_inst_1 : decidable_eq \u03b9] {f : \u03a0 (i : \u03b9), \u03b1 i}, i \u2208 s \u2192 (\u2200 (j : \u03b9), j \u2208 s \u2192 j \u2260 i \u2192 f j \u2208 t j) \u2192 function.update f i \u207b\u00b9' s.pi t = t i", "decl_nm": "set.update_preimage_pi"}
{"formal_statement": "theorem covering_iff_covers_id {C : Type u} [category_theory.category C]\n\t{X : C} (J : category_theory.grothendieck_topology C) (S : category_theory.sieve X) :\n\tS \u2208 \u21d1J X \u2194 J.covers S (\ud835\udfd9 X)", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] {X : C} (J : category_theory.grothendieck_topology C) (S : category_theory.sieve X), S \u2208 \u21d1J X \u2194 J.covers S (\ud835\udfd9 X)", "decl_nm": "category_theory.grothendieck_topology.covering_iff_covers_id"}
{"formal_statement": "theorem mem_closed_iff_closure_le {\u03b1 : Type*} [partial_order \u03b1] (c : closure_operator \u03b1)\n\t(x : \u03b1) :\n\tx \u2208 c.closed \u2194 \u21d1c x \u2264 x", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : partial_order \u03b1] (c : closure_operator \u03b1) (x : \u03b1), x \u2208 c.closed \u2194 \u21d1c x \u2264 x", "decl_nm": "closure_operator.mem_closed_iff_closure_le"}
{"formal_statement": "theorem affine_independent_equiv {k V P : Type*} [ring k] [add_comm_group V]\n\t[module k V] [add_torsor V P] {\u03b9 \u03b9' : Type*} (e : \u03b9 \u2243 \u03b9') {p : \u03b9' \u2192 P} :\n\taffine_independent k (p \u2218 \u21d1e) \u2194 affine_independent k p", "decl_tp": "\u2200 {k : Type u_1} {V : Type u_2} {P : Type u_3} [_inst_1 : ring k] [_inst_2 : add_comm_group V] [_inst_3 : module k V] [_inst_4 : add_torsor V P] {\u03b9 : Type u_4} {\u03b9' : Type u_5} (e : \u03b9 \u2243 \u03b9') {p : \u03b9' \u2192 P}, affine_independent k (p \u2218 \u21d1e) \u2194 affine_independent k p", "decl_nm": "affine_independent_equiv"}
{"formal_statement": "theorem \u03c0_desc {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C]\n\t{X Y : C} (f : X \u27f6 Y) [category_theory.limits.has_cokernel f] {W : C}\n\t(k : Y \u27f6 W) (h : f \u226b k = 0) :\n\tcategory_theory.limits.cokernel.\u03c0 f \u226b category_theory.limits.cokernel.desc f k h = k", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] [_inst_2 : category_theory.limits.has_zero_morphisms C] {X Y : C} (f : X \u27f6 Y) [_inst_3 : category_theory.limits.has_cokernel f] {W : C} (k : Y \u27f6 W) (h : f \u226b k = 0), category_theory.limits.cokernel.\u03c0 f \u226b category_theory.limits.cokernel.desc f k h = k", "decl_nm": "category_theory.limits.cokernel.\u03c0_desc"}
{"formal_statement": "theorem le_ndinter {\u03b1 : Type*} [decidable_eq \u03b1] {s t u : multiset \u03b1} :\n\ts \u2264 t.ndinter u \u2194 s \u2264 t \u2227 s \u2286 u", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : decidable_eq \u03b1] {s t u : multiset \u03b1}, s \u2264 t.ndinter u \u2194 s \u2264 t \u2227 s \u2286 u", "decl_nm": "multiset.le_ndinter"}
{"formal_statement": "theorem to_fun_eq_coe {L : first_order.language} {M N : Type*} [L.Structure M]\n\t[L.Structure N] {f : L.hom M N} :\n\tf.to_fun = \u21d1f", "decl_tp": "\u2200 {L : first_order.language} {M : Type u_3} {N : Type u_4} [_inst_1 : L.Structure M] [_inst_2 : L.Structure N] {f : L.hom M N}, f.to_fun = \u21d1f", "decl_nm": "first_order.language.hom.to_fun_eq_coe"}
{"formal_statement": "theorem filter_map_cons_none {\u03b1 : Type u} {\u03b2 : Type v} {f : \u03b1 \u2192 option \u03b2}\n\t(a : \u03b1) (l : list \u03b1) (h : f a = option.none) :\n\tlist.filter_map f (a :: l) = list.filter_map f l", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {f : \u03b1 \u2192 option \u03b2} (a : \u03b1) (l : list \u03b1), f a = option.none \u2192 list.filter_map f (a :: l) = list.filter_map f l", "decl_nm": "list.filter_map_cons_none"}
{"formal_statement": "theorem sigma_map_apply {\u03b1 \u03b1' : Type*} {\u03b2 : \u03b1 \u2192 Type*} {\u03b2' : \u03b1' \u2192 Type*}\n\t(f : \u03b1 \u21aa \u03b1') (g : \u03a0 (a : \u03b1), \u03b2 a \u21aa \u03b2' (\u21d1f a)) (x : \u03a3 (a : \u03b1), \u03b2 a) :\n\t\u21d1(f.sigma_map g) x = sigma.map \u21d1f (\u03bb (a : \u03b1), \u21d1(g a)) x", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b1' : Type u_2} {\u03b2 : \u03b1 \u2192 Type u_3} {\u03b2' : \u03b1' \u2192 Type u_4} (f : \u03b1 \u21aa \u03b1') (g : \u03a0 (a : \u03b1), \u03b2 a \u21aa \u03b2' (\u21d1f a)) (x : \u03a3 (a : \u03b1), \u03b2 a), \u21d1(f.sigma_map g) x = sigma.map \u21d1f (\u03bb (a : \u03b1), \u21d1(g a)) x", "decl_nm": "function.embedding.sigma_map_apply"}
{"formal_statement": "theorem decode_unit_zero :\n\tencodable.decode punit 0 = option.some punit.star", "decl_tp": "encodable.decode punit 0 = option.some punit.star", "decl_nm": "encodable.decode_unit_zero"}
{"formal_statement": "theorem log {E : Type*} [normed_group E] [normed_space \u211d E] {f : E \u2192 \u211d}\n\t{x : E} {s : set E} {n : with_top \u2115} (hf : times_cont_diff_within_at \u211d n f s x)\n\t(hx : f x \u2260 0) :\n\ttimes_cont_diff_within_at \u211d n (\u03bb (x : E), real.log (f x)) s x", "decl_tp": "\u2200 {E : Type u_1} [_inst_1 : normed_group E] [_inst_2 : normed_space \u211d E] {f : E \u2192 \u211d} {x : E} {s : set E} {n : with_top \u2115}, times_cont_diff_within_at \u211d n f s x \u2192 f x \u2260 0 \u2192 times_cont_diff_within_at \u211d n (\u03bb (x : E), real.log (f x)) s x", "decl_nm": "times_cont_diff_within_at.log"}
{"formal_statement": "theorem induction_on_pi {\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Sort u_2} [s : \u03a0 (i : \u03b9), setoid (\u03b1 i)]\n\t{p : (\u03a0 (i : \u03b9), quotient (s i)) \u2192 Prop} (f : \u03a0 (i : \u03b9), quotient (s i)) :\n\t(\u2200 (a : \u03a0 (i : \u03b9), \u03b1 i), p (\u03bb (i : \u03b9), \u27e6a i\u27e7)) \u2192 p f", "decl_tp": "\u2200 {\u03b9 : Type u_1} {\u03b1 : \u03b9 \u2192 Sort u_2} [s : \u03a0 (i : \u03b9), setoid (\u03b1 i)] {p : (\u03a0 (i : \u03b9), quotient (s i)) \u2192 Prop} (f : \u03a0 (i : \u03b9), quotient (s i)), (\u2200 (a : \u03a0 (i : \u03b9), \u03b1 i), p (\u03bb (i : \u03b9), \u27e6a i\u27e7)) \u2192 p f", "decl_nm": "quotient.induction_on_pi"}
{"formal_statement": "theorem continuous_stone_cech_extend {\u03b1 : Type u} [topological_space \u03b1]\n\t{\u03b3 : Type u} [topological_space \u03b3] [t2_space \u03b3] [compact_space \u03b3] {f : \u03b1 \u2192 \u03b3}\n\t(hf : continuous f) :\n\tcontinuous (stone_cech_extend hf)", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : topological_space \u03b1] {\u03b3 : Type u} [_inst_2 : topological_space \u03b3] [_inst_3 : t2_space \u03b3] [_inst_4 : compact_space \u03b3] {f : \u03b1 \u2192 \u03b3} (hf : continuous f), continuous (stone_cech_extend hf)", "decl_nm": "continuous_stone_cech_extend"}
{"formal_statement": "theorem unique_up_to_iso_hom {C : Type u\u2081} [category_theory.category C]\n\t{I I' : C} (hI : category_theory.limits.is_initial I) (hI' : category_theory.limits.is_initial I') :\n\t(hI.unique_up_to_iso hI').hom = hI.to I'", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {I I' : C} (hI : category_theory.limits.is_initial I) (hI' : category_theory.limits.is_initial I'), (hI.unique_up_to_iso hI').hom = hI.to I'", "decl_nm": "category_theory.limits.is_initial.unique_up_to_iso_hom"}
{"formal_statement": "theorem trans_tendsto {\u03b1 E' F' : Type*} [normed_group E'] [normed_group F']\n\t{f' : \u03b1 \u2192 E'} {g' : \u03b1 \u2192 F'} {l : filter \u03b1} (hfg : asymptotics.is_o f' g' l)\n\t(hg : filter.tendsto g' l (nhds 0)) :\n\tfilter.tendsto f' l (nhds 0)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {E' : Type u_6} {F' : Type u_7} [_inst_4 : normed_group E'] [_inst_5 : normed_group F'] {f' : \u03b1 \u2192 E'} {g' : \u03b1 \u2192 F'} {l : filter \u03b1}, asymptotics.is_o f' g' l \u2192 filter.tendsto g' l (nhds 0) \u2192 filter.tendsto f' l (nhds 0)", "decl_nm": "asymptotics.is_o.trans_tendsto"}
{"formal_statement": "theorem disjoint_sup_right {\u03b1 : Type u} [distrib_lattice \u03b1] [order_bot \u03b1]\n\t{a b c : \u03b1} :\n\tdisjoint a (b \u2294 c) \u2194 disjoint a b \u2227 disjoint a c", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : distrib_lattice \u03b1] [_inst_2 : order_bot \u03b1] {a b c : \u03b1}, disjoint a (b \u2294 c) \u2194 disjoint a b \u2227 disjoint a c", "decl_nm": "disjoint_sup_right"}
{"formal_statement": "theorem map_const {\u03b1 \u03b2 \u03b3 : Type*} [measurable_space \u03b1] (g : \u03b2 \u2192 \u03b3) (b : \u03b2) :\n\tmeasure_theory.simple_func.map g (measure_theory.simple_func.const \u03b1 b) = measure_theory.simple_func.const \u03b1 (g b)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {\u03b3 : Type u_3} [_inst_1 : measurable_space \u03b1] (g : \u03b2 \u2192 \u03b3) (b : \u03b2), measure_theory.simple_func.map g (measure_theory.simple_func.const \u03b1 b) = measure_theory.simple_func.const \u03b1 (g b)", "decl_nm": "measure_theory.simple_func.map_const"}
{"formal_statement": "theorem has_fderiv_within_at {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c] {E : Type*}\n\t[normed_group E] [normed_space \ud835\udd5c E] {F : Type*} [normed_group F] [normed_space \ud835\udd5c F]\n\t(e : E \u2192L[\ud835\udd5c] F) {x : E} {s : set E} :\n\thas_fderiv_within_at \u21d1e e s x", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {F : Type u_3} [_inst_4 : normed_group F] [_inst_5 : normed_space \ud835\udd5c F] (e : E \u2192L[\ud835\udd5c] F) {x : E} {s : set E}, has_fderiv_within_at \u21d1e e s x", "decl_nm": "continuous_linear_map.has_fderiv_within_at"}
{"formal_statement": "theorem refl_apply (R : Type*) [has_mul R] [has_add R] (x : R) :\n\t\u21d1(ring_equiv.refl R) x = x", "decl_tp": "\u2200 (R : Type u_1) [_inst_1 : has_mul R] [_inst_2 : has_add R] (x : R), \u21d1(ring_equiv.refl R) x = x", "decl_nm": "ring_equiv.refl_apply"}
{"formal_statement": "theorem add_add_one_ne (n m : \u2115) :\n\tn + (m + 1) \u2260 n", "decl_tp": "\u2200 (n m : \u2115), n + (m + 1) \u2260 n", "decl_nm": "tactic.unify_equations.add_add_one_ne"}
{"formal_statement": "theorem tsum_sigma' {\u03b1 \u03b2 : Type*} [add_comm_monoid \u03b1] [topological_space \u03b1]\n\t[t2_space \u03b1] [has_continuous_add \u03b1] [regular_space \u03b1] {\u03b3 : \u03b2 \u2192 Type*}\n\t{f : (\u03a3 (b : \u03b2), \u03b3 b) \u2192 \u03b1} (h\u2082 : summable f) :\n\t(\u2200 (b : \u03b2), summable (\u03bb (c : \u03b3 b), f \u27e8b, c\u27e9)) \u2192  \u2211' (p : \u03a3 (b : \u03b2), \u03b3 b), f p = \u2211' (b : \u03b2)\n\t(c : \u03b3 b), f \u27e8b, c\u27e9", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : add_comm_monoid \u03b1] [_inst_2 : topological_space \u03b1] [_inst_3 : t2_space \u03b1] [_inst_4 : has_continuous_add \u03b1] [_inst_5 : regular_space \u03b1] {\u03b3 : \u03b2 \u2192 Type u_3} {f : (\u03a3 (b : \u03b2), \u03b3 b) \u2192 \u03b1}, (\u2200 (b : \u03b2), summable (\u03bb (c : \u03b3 b), f \u27e8b, c\u27e9)) \u2192 summable f \u2192 \u2211' (p : \u03a3 (b : \u03b2), \u03b3 b), f p = \u2211' (b : \u03b2) (c : \u03b3 b), f \u27e8b, c\u27e9", "decl_nm": "tsum_sigma'"}
{"formal_statement": "theorem one_le_mul_right {\u03b1 : Type*} {a b : \u03b1} [preorder \u03b1] [mul_one_class \u03b1]\n\t[covariant_class \u03b1 \u03b1 has_mul.mul has_le.le] (ha : 1 \u2264 a) (hb : 1 \u2264 b) :\n\t1 \u2264 a * b", "decl_tp": "\u2200 {\u03b1 : Type u_1} {a b : \u03b1} [_inst_1 : preorder \u03b1] [_inst_2 : mul_one_class \u03b1] [_inst_3 : covariant_class \u03b1 \u03b1 has_mul.mul has_le.le], 1 \u2264 a \u2192 1 \u2264 b \u2192 1 \u2264 a * b", "decl_nm": "one_le_mul_right"}
{"formal_statement": "theorem tendsto_finset_image_at_top_at_top {\u03b2 \u03b3 : Type*} {i : \u03b2 \u2192 \u03b3} {j : \u03b3 \u2192 \u03b2}\n\t(h : function.left_inverse j i) :\n\tfilter.tendsto (finset.image j) filter.at_top filter.at_top", "decl_tp": "\u2200 {\u03b2 : Type u_4} {\u03b3 : Type u_5} {i : \u03b2 \u2192 \u03b3} {j : \u03b3 \u2192 \u03b2}, function.left_inverse j i \u2192 filter.tendsto (finset.image j) filter.at_top filter.at_top", "decl_nm": "filter.tendsto_finset_image_at_top_at_top"}
{"formal_statement": "theorem le_of_eq_of_le {\u03b1 : Type*} [ordered_semiring \u03b1] {a b : \u03b1} (ha : a = 0)\n\t(hb : b \u2264 0) :\n\ta + b \u2264 0", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : ordered_semiring \u03b1] {a b : \u03b1}, a = 0 \u2192 b \u2264 0 \u2192 a + b \u2264 0", "decl_nm": "linarith.le_of_eq_of_le"}
{"formal_statement": "theorem snorm'_const_of_is_probability_measure {\u03b1 F : Type*} {m0 : measurable_space \u03b1}\n\t{q : \u211d} {\u03bc : measure_theory.measure \u03b1} [normed_group F] (c : F) (hq_pos : 0 < q) :\n\t\u2200 [measure_theory.is_probability_measure \u03bc], measure_theory.snorm' (\u03bb (x : \u03b1), c) q \u03bc = \u2191\u2225c\u2225\u208a", "decl_tp": "\u2200 {\u03b1 : Type u_1} {F : Type u_3} {m0 : measurable_space \u03b1} {q : \u211d} {\u03bc : measure_theory.measure \u03b1} [_inst_3 : normed_group F] (c : F), 0 < q \u2192 \u2200 [_inst_5 : measure_theory.is_probability_measure \u03bc], measure_theory.snorm' (\u03bb (x : \u03b1), c) q \u03bc = \u2191\u2225c\u2225\u208a", "decl_nm": "measure_theory.snorm'_const_of_is_probability_measure"}
{"formal_statement": "theorem le_div_iff\u2080 {\u03b1 : Type*} {a b c : \u03b1} [linear_ordered_comm_group_with_zero \u03b1]\n\t(hc : c \u2260 0) :\n\t(a \u2264 b / c \u2194 a * c \u2264 b)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {a b c : \u03b1} [_inst_1 : linear_ordered_comm_group_with_zero \u03b1], c \u2260 0 \u2192 (a \u2264 b / c \u2194 a * c \u2264 b)", "decl_nm": "le_div_iff\u2080"}
{"formal_statement": "theorem point_map {C : Type u} [category_theory.category C] (_x _x_1 : category_theory.comma (\ud835\udfed (category_theory.simplicial_object C))\n\t(category_theory.simplicial_object.const C)) (f : _x \u27f6 _x_1) :\n\tcategory_theory.simplicial_object.augmented.point.map f = f.right", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] (_x _x_1 : category_theory.comma (\ud835\udfed (category_theory.simplicial_object C)) (category_theory.simplicial_object.const C)) (f : _x \u27f6 _x_1), category_theory.simplicial_object.augmented.point.map f = f.right", "decl_nm": "category_theory.simplicial_object.augmented.point_map"}
{"formal_statement": "theorem filter_inter_filter_neg_eq {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [decidable_pred p]\n\t[decidable_eq \u03b1] [decidable_pred (\u03bb (a : \u03b1), \u00acp a)] (s : finset \u03b1) :\n\tfinset.filter p s \u2229 finset.filter (\u03bb (a : \u03b1), \u00acp a) s = \u2205", "decl_tp": "\u2200 {\u03b1 : Type u_1} (p : \u03b1 \u2192 Prop) [_inst_1 : decidable_pred p] [_inst_3 : decidable_eq \u03b1] [_inst_4 : decidable_pred (\u03bb (a : \u03b1), \u00acp a)] (s : finset \u03b1), finset.filter p s \u2229 finset.filter (\u03bb (a : \u03b1), \u00acp a) s = \u2205", "decl_nm": "finset.filter_inter_filter_neg_eq"}
{"formal_statement": "theorem coe_to_add_monoid_hom {V\u2081 V\u2082 : Type*} [semi_normed_group V\u2081] [semi_normed_group V\u2082]\n\t(f : normed_group_hom V\u2081 V\u2082) :\n\t\u21d1(f.to_add_monoid_hom) = \u21d1f", "decl_tp": "\u2200 {V\u2081 : Type u_2} {V\u2082 : Type u_3} [_inst_2 : semi_normed_group V\u2081] [_inst_3 : semi_normed_group V\u2082] (f : normed_group_hom V\u2081 V\u2082), \u21d1(f.to_add_monoid_hom) = \u21d1f", "decl_nm": "normed_group_hom.coe_to_add_monoid_hom"}
{"formal_statement": "theorem abs_add_three {\u03b1 : Type u} [linear_ordered_add_comm_group \u03b1] (a b c : \u03b1) :\n\t|a + b + c| \u2264 |a| + |b| + |c|", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : linear_ordered_add_comm_group \u03b1] (a b c : \u03b1), |a + b + c| \u2264 |a| + |b| + |c|", "decl_nm": "abs_add_three"}
{"formal_statement": "theorem add_assoc {G : Type u} [add_semigroup G] (a b c : G) :\n\ta + b + c = a + (b + c)", "decl_tp": "\u2200 {G : Type u} [_inst_1 : add_semigroup G] (a b c : G), a + b + c = a + (b + c)", "decl_nm": "add_assoc"}
{"formal_statement": "theorem separable_gcd_right {F : Type*} [field F] {g : polynomial F} (f : polynomial F)\n\t(hg : g.separable) :\n\t(euclidean_domain.gcd f g).separable", "decl_tp": "\u2200 {F : Type u_1} [_inst_3 : field F] {g : polynomial F} (f : polynomial F), g.separable \u2192 (euclidean_domain.gcd f g).separable", "decl_nm": "polynomial.separable_gcd_right"}
{"formal_statement": "theorem dest_corec {P : pfunctor} {\u03b1 : Type u} (g : \u03b1 \u2192 P.obj \u03b1) (x : \u03b1) :\n\t(pfunctor.M.corec g x).dest = pfunctor.M.corec g <$> g x", "decl_tp": "\u2200 {P : pfunctor} {\u03b1 : Type u} (g : \u03b1 \u2192 P.obj \u03b1) (x : \u03b1), (pfunctor.M.corec g x).dest = pfunctor.M.corec g <$> g x", "decl_nm": "pfunctor.M.dest_corec"}
{"formal_statement": "theorem compl_mem_cofinite {\u03b1 : Type*} {s : set \u03b1} (hs : s.finite) :\n\ts\u1d9c \u2208 filter.cofinite", "decl_tp": "\u2200 {\u03b1 : Type u_1} {s : set \u03b1}, s.finite \u2192 s\u1d9c \u2208 filter.cofinite", "decl_nm": "set.finite.compl_mem_cofinite"}
{"formal_statement": "theorem lift_is_succ {o : ordinal} :\n\t(\u2203 (a : ordinal), o.lift = a.succ) \u2194 \u2203 (a : ordinal), o = a.succ", "decl_tp": "\u2200 {o : ordinal}, (\u2203 (a : ordinal), o.lift = a.succ) \u2194 \u2203 (a : ordinal), o = a.succ", "decl_nm": "ordinal.lift_is_succ"}
{"formal_statement": "theorem inv_inv {G : Type*} [measurable_space G] [group G] [topological_space G]\n\t[topological_group G] [borel_space G] (\u03bc : measure_theory.measure G) :\n\t\u03bc.inv.inv = \u03bc", "decl_tp": "\u2200 {G : Type u_1} [_inst_1 : measurable_space G] [_inst_2 : group G] [_inst_3 : topological_space G] [_inst_4 : topological_group G] [_inst_5 : borel_space G] (\u03bc : measure_theory.measure G), \u03bc.inv.inv = \u03bc", "decl_nm": "measure_theory.measure.inv_inv"}
{"formal_statement": "theorem nat_degree_X_le {R : Type u} [semiring R] :\n\tpolynomial.X.nat_degree \u2264 1", "decl_tp": "\u2200 {R : Type u} [_inst_1 : semiring R], polynomial.X.nat_degree \u2264 1", "decl_nm": "polynomial.nat_degree_X_le"}
{"formal_statement": "theorem mem_of_closed {\u03b1 : Type u} [topological_space \u03b1] {a : \u03b1} {s : set \u03b1}\n\t(hs : is_closed s) :\n\t(\u2203\u1da0 (x : \u03b1) in nhds a, x \u2208 s) \u2192  a \u2208 s", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : topological_space \u03b1] {a : \u03b1} {s : set \u03b1}, (\u2203\u1da0 (x : \u03b1) in nhds a, x \u2208 s) \u2192 is_closed s \u2192 a \u2208 s", "decl_nm": "filter.frequently.mem_of_closed"}
{"formal_statement": "theorem map_normalizer_eq_of_bijective {G : Type*} [group G] {N : Type*}\n\t[group N] (H : subgroup G) {f : G \u2192* N} (hf : function.bijective \u21d1f) :\n\tsubgroup.map f H.normalizer = (subgroup.map f H).normalizer", "decl_tp": "\u2200 {G : Type u_1} [_inst_1 : group G] {N : Type u_3} [_inst_3 : group N] (H : subgroup G) {f : G \u2192* N}, function.bijective \u21d1f \u2192 subgroup.map f H.normalizer = (subgroup.map f H).normalizer", "decl_nm": "subgroup.map_normalizer_eq_of_bijective"}
{"formal_statement": "theorem preimage_open_of_open {\u03b1 \u03b2 : Type*} [topological_space \u03b1] [topological_space \u03b2]\n\t{f : \u03b1 \u2192 \u03b2} {s : set \u03b1} {t : set \u03b2} (hf : continuous_on f s) (hs : is_open s)\n\t(ht : is_open t) :\n\tis_open (s \u2229 f \u207b\u00b9' t)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : topological_space \u03b1] [_inst_2 : topological_space \u03b2] {f : \u03b1 \u2192 \u03b2} {s : set \u03b1} {t : set \u03b2}, continuous_on f s \u2192 is_open s \u2192 is_open t \u2192 is_open (s \u2229 f \u207b\u00b9' t)", "decl_nm": "continuous_on.preimage_open_of_open"}
{"formal_statement": "theorem tendsto_nhds_within_of_tendsto_nhds {\u03b1 \u03b2 : Type*} [topological_space \u03b1]\n\t{f : \u03b1 \u2192 \u03b2} {a : \u03b1} {s : set \u03b1} {l : filter \u03b2} (h : filter.tendsto f (nhds a) l) :\n\tfilter.tendsto f (nhds_within a s) l", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : topological_space \u03b1] {f : \u03b1 \u2192 \u03b2} {a : \u03b1} {s : set \u03b1} {l : filter \u03b2}, filter.tendsto f (nhds a) l \u2192 filter.tendsto f (nhds_within a s) l", "decl_nm": "tendsto_nhds_within_of_tendsto_nhds"}
{"formal_statement": "theorem tsub_le_tsub_left {\u03b1 : Type*} [partial_order \u03b1] [add_comm_monoid \u03b1]\n\t[has_sub \u03b1] [has_ordered_sub \u03b1] {a b : \u03b1} [covariant_class \u03b1 \u03b1 has_add.add has_le.le]\n\t(h : a \u2264 b) :\n\t\u2200 (c : \u03b1), c - b \u2264 c - a", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : partial_order \u03b1] [_inst_2 : add_comm_monoid \u03b1] [_inst_3 : has_sub \u03b1] [_inst_4 : has_ordered_sub \u03b1] {a b : \u03b1} [_inst_5 : covariant_class \u03b1 \u03b1 has_add.add has_le.le], a \u2264 b \u2192 \u2200 (c : \u03b1), c - b \u2264 c - a", "decl_nm": "tsub_le_tsub_left"}
{"formal_statement": "theorem log_lt_log_iff {x y : \u211d} (hx : 0 < x) (hy : 0 < y) :\n\t(real.log x < real.log y \u2194 x < y)", "decl_tp": "\u2200 {x y : \u211d}, 0 < x \u2192 0 < y \u2192 (real.log x < real.log y \u2194 x < y)", "decl_nm": "real.log_lt_log_iff"}
{"formal_statement": "theorem index_top {G : Type*} [group G] :\n\t\u22a4.index = 1", "decl_tp": "\u2200 {G : Type u_1} [_inst_1 : group G], \u22a4.index = 1", "decl_nm": "subgroup.index_top"}
{"formal_statement": "theorem of_set_symm {\u03b1 : Type*} (s : set \u03b1) :\n\t(local_equiv.of_set s).symm = local_equiv.of_set s", "decl_tp": "\u2200 {\u03b1 : Type u_1} (s : set \u03b1), (local_equiv.of_set s).symm = local_equiv.of_set s", "decl_nm": "local_equiv.of_set_symm"}
{"formal_statement": "theorem coe_smul {\u03b1 : Type*} [topological_space \u03b1] {R : Type*} [semiring R]\n\t[topological_space R] {M : Type*} [topological_space M] [add_comm_monoid M]\n\t[module R M] [has_continuous_smul R M] (c : R) (f : C(\u03b1, M)) :\n\t\u21d1(c \u2022 f) = c \u2022 \u21d1f", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : topological_space \u03b1] {R : Type u_2} [_inst_2 : semiring R] [_inst_3 : topological_space R] {M : Type u_3} [_inst_4 : topological_space M] [_inst_5 : add_comm_monoid M] [_inst_8 : module R M] [_inst_9 : has_continuous_smul R M] (c : R) (f : C(\u03b1, M)), \u21d1(c \u2022 f) = c \u2022 \u21d1f", "decl_nm": "continuous_map.coe_smul"}
{"formal_statement": "theorem trans {\u03b1 : Type*} {m : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1}\n\t{p q q' : set \u03b1 \u2192 Prop} (H : \u03bc.inner_regular p q) (H' : \u03bc.inner_regular q q') :\n\t\u03bc.inner_regular p q'", "decl_tp": "\u2200 {\u03b1 : Type u_1} {m : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} {p q q' : set \u03b1 \u2192 Prop}, \u03bc.inner_regular p q \u2192 \u03bc.inner_regular q q' \u2192 \u03bc.inner_regular p q'", "decl_nm": "measure_theory.measure.inner_regular.trans"}
{"formal_statement": "theorem aeval_eq_bind\u2081 {\u03c3 \u03c4 R : Type*} [comm_semiring R] (f : \u03c3 \u2192 mv_polynomial \u03c4 R) :\n\tmv_polynomial.aeval f = mv_polynomial.bind\u2081 f", "decl_tp": "\u2200 {\u03c3 : Type u_1} {\u03c4 : Type u_2} {R : Type u_3} [_inst_1 : comm_semiring R] (f : \u03c3 \u2192 mv_polynomial \u03c4 R), mv_polynomial.aeval f = mv_polynomial.bind\u2081 f", "decl_nm": "mv_polynomial.aeval_eq_bind\u2081"}
{"formal_statement": "theorem odd_of_mod_four_eq_one {n : \u2115} :\n\tn % 4 = 1 \u2192 n % 2 = 1", "decl_tp": "\u2200 {n : \u2115}, n % 4 = 1 \u2192 n % 2 = 1", "decl_nm": "nat.odd_of_mod_four_eq_one"}
{"formal_statement": "theorem norm_zero {\u03b1 E : Type*} {m0 : measurable_space \u03b1} {p : ennreal}\n\t{\u03bc : measure_theory.measure \u03b1} [measurable_space E] [normed_group E] [borel_space E]\n\t[topological_space.second_countable_topology E] :\n\t\u22250\u2225 = 0", "decl_tp": "\u2200 {\u03b1 : Type u_1} {E : Type u_2} {m0 : measurable_space \u03b1} {p : ennreal} {\u03bc : measure_theory.measure \u03b1} [_inst_1 : measurable_space E] [_inst_2 : normed_group E] [_inst_5 : borel_space E] [_inst_6 : topological_space.second_countable_topology E], \u22250\u2225 = 0", "decl_nm": "measure_theory.Lp.norm_zero"}
{"formal_statement": "theorem div_to_nat (n d : num) :\n\t\u2191(n / d) = \u2191n / \u2191d", "decl_tp": "\u2200 (n d : num), \u2191(n / d) = \u2191n / \u2191d", "decl_nm": "num.div_to_nat"}
{"formal_statement": "theorem frontier_Iic {\u03b1 : Type u} [topological_space \u03b1] [linear_order \u03b1]\n\t[order_topology \u03b1] [densely_ordered \u03b1] [no_top_order \u03b1] {a : \u03b1} :\n\tfrontier (set.Iic a) = {a}", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : topological_space \u03b1] [_inst_2 : linear_order \u03b1] [_inst_3 : order_topology \u03b1] [_inst_4 : densely_ordered \u03b1] [_inst_5 : no_top_order \u03b1] {a : \u03b1}, frontier (set.Iic a) = {a}", "decl_nm": "frontier_Iic"}
{"formal_statement": "theorem coe_lm\u209b\u2097_apply {R R\u2083 S\u2083 : Type*} [semiring R] [semiring R\u2083] [semiring S\u2083]\n\t[topological_space S\u2083] {M : Type*} [topological_space M] [add_comm_monoid M]\n\t[module R M] {M\u2083 : Type*} [topological_space M\u2083] [add_comm_monoid M\u2083]\n\t[module R\u2083 M\u2083] [module S\u2083 M\u2083] [smul_comm_class R\u2083 S\u2083 M\u2083] [has_continuous_smul S\u2083 M\u2083]\n\t(\u03c3\u2081\u2083 : R \u2192+* R\u2083) [has_continuous_add M\u2083] (\u1fb0 : M \u2192SL[\u03c3\u2081\u2083] M\u2083) :\n\t\u21d1(continuous_linear_map.coe_lm\u209b\u2097 \u03c3\u2081\u2083) \u1fb0 = \u2191\u1fb0", "decl_tp": "\u2200 {R : Type u_1} {R\u2083 : Type u_3} {S\u2083 : Type u_5} [_inst_1 : semiring R] [_inst_3 : semiring R\u2083] [_inst_5 : semiring S\u2083] [_inst_7 : topological_space S\u2083] {M : Type u_6} [_inst_8 : topological_space M] [_inst_9 : add_comm_monoid M] [_inst_10 : module R M] {M\u2083 : Type u_8} [_inst_14 : topological_space M\u2083] [_inst_15 : add_comm_monoid M\u2083] [_inst_16 : module R\u2083 M\u2083] [_inst_23 : module S\u2083 M\u2083] [_inst_24 : smul_comm_class R\u2083 S\u2083 M\u2083] [_inst_25 : has_continuous_smul S\u2083 M\u2083] (\u03c3\u2081\u2083 : R \u2192+* R\u2083) [_inst_34 : has_continuous_add M\u2083] (\u1fb0 : M \u2192SL[\u03c3\u2081\u2083] M\u2083), \u21d1(continuous_linear_map.coe_lm\u209b\u2097 \u03c3\u2081\u2083) \u1fb0 = \u2191\u1fb0", "decl_nm": "continuous_linear_map.coe_lm\u209b\u2097_apply"}
{"formal_statement": "theorem on_injective {\u03b1 \u03b9 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {f : \u03b9 \u2192 \u03b1} {s : set \u03b1}\n\t(hs : s.pairwise r) (hf : function.injective f) :\n\t(\u2200 (x : \u03b9), f x \u2208 s) \u2192 pairwise (r on f)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b9 : Type u_2} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {f : \u03b9 \u2192 \u03b1} {s : set \u03b1}, s.pairwise r \u2192 function.injective f \u2192 (\u2200 (x : \u03b9), f x \u2208 s) \u2192 pairwise (r on f)", "decl_nm": "set.pairwise.on_injective"}
{"formal_statement": "theorem indicator_ae_eq_restrict {\u03b1 \u03b2 : Type*} [measurable_space \u03b1] {\u03bc : measure_theory.measure \u03b1}\n\t{s : set \u03b1} {f : \u03b1 \u2192 \u03b2} [has_zero \u03b2] (hs : measurable_set s) :\n\ts.indicator f =\u1d50[\u03bc.restrict s] f", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : measurable_space \u03b1] {\u03bc : measure_theory.measure \u03b1} {s : set \u03b1} {f : \u03b1 \u2192 \u03b2} [_inst_2 : has_zero \u03b2], measurable_set s \u2192 s.indicator f =\u1d50[\u03bc.restrict s] f", "decl_nm": "indicator_ae_eq_restrict"}
{"formal_statement": "theorem mem_insert {\u03b1 : Type u} {\u03b2 : \u03b1 \u2192 Type v} [decidable_eq \u03b1] {a a' : \u03b1}\n\t{b' : \u03b2 a'} {s : finmap \u03b2} :\n\ta \u2208 finmap.insert a' b' s \u2194 a = a' \u2228 a \u2208 s", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : \u03b1 \u2192 Type v} [_inst_1 : decidable_eq \u03b1] {a a' : \u03b1} {b' : \u03b2 a'} {s : finmap \u03b2}, a \u2208 finmap.insert a' b' s \u2194 a = a' \u2228 a \u2208 s", "decl_nm": "finmap.mem_insert"}
{"formal_statement": "theorem dual_dual {\u03b1 : Type*} (t : ordnode \u03b1) :\n\tt.dual.dual = t", "decl_tp": "\u2200 {\u03b1 : Type u_1} (t : ordnode \u03b1), t.dual.dual = t", "decl_nm": "ordnode.dual_dual"}
{"formal_statement": "theorem gt {\u03b1 : Type u} [has_lt \u03b1] {x y : \u03b1} (h : x < y) :\n\ty > x", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : has_lt \u03b1] {x y : \u03b1}, x < y \u2192 y > x", "decl_nm": "has_lt.lt.gt"}
{"formal_statement": "theorem nndist_triangle_right {\u03b1 : Type u} [pseudo_metric_space \u03b1] (x y z : \u03b1) :\n\thas_nndist.nndist x y \u2264 has_nndist.nndist x z + has_nndist.nndist y z", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : pseudo_metric_space \u03b1] (x y z : \u03b1), has_nndist.nndist x y \u2264 has_nndist.nndist x z + has_nndist.nndist y z", "decl_nm": "nndist_triangle_right"}
{"formal_statement": "theorem card_pi_finset {\u03b1 : Type*} [decidable_eq \u03b1] [fintype \u03b1] {\u03b4 : \u03b1 \u2192 Type*}\n\t(t : \u03a0 (a : \u03b1), finset (\u03b4 a)) :\n\t(fintype.pi_finset t).card = finset.univ.prod (\u03bb (a : \u03b1), (t a).card)", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : decidable_eq \u03b1] [_inst_2 : fintype \u03b1] {\u03b4 : \u03b1 \u2192 Type u_2} (t : \u03a0 (a : \u03b1), finset (\u03b4 a)), (fintype.pi_finset t).card = finset.univ.prod (\u03bb (a : \u03b1), (t a).card)", "decl_nm": "fintype.card_pi_finset"}
{"formal_statement": "theorem bij_on_empty {\u03b1 : Type u} {\u03b2 : Type v} (f : \u03b1 \u2192 \u03b2) :\n\tset.bij_on f \u2205 \u2205", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} (f : \u03b1 \u2192 \u03b2), set.bij_on f \u2205 \u2205", "decl_nm": "set.bij_on_empty"}
{"formal_statement": "theorem comp_continuous_on_iff {\u03b1 \u03b2 \u03b3 : Type*} [topological_space \u03b1] [topological_space \u03b2]\n\t[topological_space \u03b3] (h : \u03b1 \u2243\u209c \u03b2) (f : \u03b3 \u2192 \u03b1) (s : set \u03b3) :\n\tcontinuous_on (\u21d1h \u2218 f) s \u2194 continuous_on f s", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {\u03b3 : Type u_3} [_inst_1 : topological_space \u03b1] [_inst_2 : topological_space \u03b2] [_inst_3 : topological_space \u03b3] (h : \u03b1 \u2243\u209c \u03b2) (f : \u03b3 \u2192 \u03b1) (s : set \u03b3), continuous_on (\u21d1h \u2218 f) s \u2194 continuous_on f s", "decl_nm": "homeomorph.comp_continuous_on_iff"}
{"formal_statement": "theorem unique_diff_on_Ici (a : \u211d) :\n\tunique_diff_on \u211d (set.Ici a)", "decl_tp": "\u2200 (a : \u211d), unique_diff_on \u211d (set.Ici a)", "decl_nm": "unique_diff_on_Ici"}
{"formal_statement": "theorem Sup_sUnion {\u03b1 : Type*} [complete_lattice \u03b1] {s : set (set \u03b1)} :\n\thas_Sup.Sup (\u22c3\u2080 s) = \u2a06 (t : set \u03b1) (H : t \u2208 s), has_Sup.Sup t", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : complete_lattice \u03b1] {s : set (set \u03b1)}, has_Sup.Sup (\u22c3\u2080 s) = \u2a06 (t : set \u03b1) (H : t \u2208 s), has_Sup.Sup t", "decl_nm": "Sup_sUnion"}
{"formal_statement": "theorem of_duplicate_cons {\u03b1 : Type*} {l : list \u03b1} {x y : \u03b1} (h : list.duplicate x (y :: l))\n\t(hx : x \u2260 y) :\n\tlist.duplicate x l", "decl_tp": "\u2200 {\u03b1 : Type u_1} {l : list \u03b1} {x y : \u03b1}, list.duplicate x (y :: l) \u2192 x \u2260 y \u2192 list.duplicate x l", "decl_nm": "list.duplicate.of_duplicate_cons"}
{"formal_statement": "theorem principal_seg_coe {\u03b1 : Type*} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [is_well_order \u03b1 r] :\n\t\u21d1(ordinal.typein.principal_seg r) = ordinal.typein r", "decl_tp": "\u2200 {\u03b1 : Type u_1} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [_inst_1 : is_well_order \u03b1 r], \u21d1(ordinal.typein.principal_seg r) = ordinal.typein r", "decl_nm": "ordinal.typein.principal_seg_coe"}
{"formal_statement": "theorem pure_bind {\u03b1 \u03b2 : Type u} (f : \u03b1 \u2192 free_abelian_group \u03b2) (x : \u03b1) :\n\thas_pure.pure x >>= f = f x", "decl_tp": "\u2200 {\u03b1 \u03b2 : Type u} (f : \u03b1 \u2192 free_abelian_group \u03b2) (x : \u03b1), has_pure.pure x >>= f = f x", "decl_nm": "free_abelian_group.pure_bind"}
{"formal_statement": "theorem is_smul_regular {R : Type*} [has_mul R] {c : R} (h : is_left_regular c) :\n\tis_smul_regular R c", "decl_tp": "\u2200 {R : Type u_1} [_inst_1 : has_mul R] {c : R}, is_left_regular c \u2192 is_smul_regular R c", "decl_nm": "is_left_regular.is_smul_regular"}
{"formal_statement": "theorem general_commutator_containment {G : Type*} [group G] (H\u2081 H\u2082 : subgroup G)\n\t{p q : G} (hp : p \u2208 H\u2081) (hq : q \u2208 H\u2082) :\n\tp * q * p\u207b\u00b9 * q\u207b\u00b9 \u2208 \u2045H\u2081,H\u2082\u2046", "decl_tp": "\u2200 {G : Type u_1} [_inst_1 : group G] (H\u2081 H\u2082 : subgroup G) {p q : G}, p \u2208 H\u2081 \u2192 q \u2208 H\u2082 \u2192 p * q * p\u207b\u00b9 * q\u207b\u00b9 \u2208 \u2045H\u2081,H\u2082\u2046", "decl_nm": "general_commutator_containment"}
{"formal_statement": "theorem symm_diff_sdiff_right {\u03b1 : Type*} [generalized_boolean_algebra \u03b1]\n\t(a b : \u03b1) :\n\ta \u0394 b \\ b = a \\ b", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : generalized_boolean_algebra \u03b1] (a b : \u03b1), a \u0394 b \\ b = a \\ b", "decl_nm": "symm_diff_sdiff_right"}
{"formal_statement": "theorem lie_span_eq {R : Type u} {L : Type v} {M : Type w} [comm_ring R]\n\t[lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M]\n\t[lie_module R L M] (N : lie_submodule R L M) :\n\tlie_submodule.lie_span R L \u2191N = N", "decl_tp": "\u2200 {R : Type u} {L : Type v} {M : Type w} [_inst_1 : comm_ring R] [_inst_2 : lie_ring L] [_inst_3 : lie_algebra R L] [_inst_4 : add_comm_group M] [_inst_5 : module R M] [_inst_6 : lie_ring_module L M] [_inst_7 : lie_module R L M] (N : lie_submodule R L M), lie_submodule.lie_span R L \u2191N = N", "decl_nm": "lie_submodule.lie_span_eq"}
{"formal_statement": "theorem restrict_congr_set {\u03b1 : Type*} {m0 : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1}\n\t{s t : set \u03b1} (h : s =\u1d50[\u03bc] t) :\n\t\u03bc.restrict s = \u03bc.restrict t", "decl_tp": "\u2200 {\u03b1 : Type u_1} {m0 : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} {s t : set \u03b1}, s =\u1d50[\u03bc] t \u2192 \u03bc.restrict s = \u03bc.restrict t", "decl_nm": "measure_theory.measure.restrict_congr_set"}
{"formal_statement": "theorem one_le_pos {\u03b1 : Type u} [lattice \u03b1] [comm_group \u03b1] (a : \u03b1) :\n\t1 \u2264 a\u207a", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : lattice \u03b1] [_inst_2 : comm_group \u03b1] (a : \u03b1), 1 \u2264 a\u207a", "decl_nm": "lattice_ordered_comm_group.one_le_pos"}
{"formal_statement": "theorem pw_filter_sublist {\u03b1 : Type*} {R : \u03b1 \u2192 \u03b1 \u2192 Prop} [decidable_rel R]\n\t(l : list \u03b1) :\n\tlist.pw_filter R l <+ l", "decl_tp": "\u2200 {\u03b1 : Type u_1} {R : \u03b1 \u2192 \u03b1 \u2192 Prop} [_inst_1 : decidable_rel R] (l : list \u03b1), list.pw_filter R l <+ l", "decl_nm": "list.pw_filter_sublist"}
{"formal_statement": "theorem fac {C : Type u} [category_theory.category C] [category_theory.non_preadditive_abelian C]\n\t{P Q : C} (f : P \u27f6 Q) :\n\tcategory_theory.non_preadditive_abelian.factor_thru_image f \u226b category_theory.non_preadditive_abelian.image.\u03b9 f = f", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] [_inst_2 : category_theory.non_preadditive_abelian C] {P Q : C} (f : P \u27f6 Q), category_theory.non_preadditive_abelian.factor_thru_image f \u226b category_theory.non_preadditive_abelian.image.\u03b9 f = f", "decl_nm": "category_theory.non_preadditive_abelian.image.fac"}
{"formal_statement": "theorem coe_mul {R : Type u} [non_assoc_semiring R] (s : subsemiring R)\n\t(x y : \u21a5s) :\n\t\u2191(x * y) = \u2191x * \u2191y", "decl_tp": "\u2200 {R : Type u} [_inst_1 : non_assoc_semiring R] (s : subsemiring R) (x y : \u21a5s), \u2191(x * y) = \u2191x * \u2191y", "decl_nm": "subsemiring.coe_mul"}
{"formal_statement": "theorem whiskering_obj_obj_map (C : Type u) [category_theory.category C]\n\t(D : Type*) [category_theory.category D] (H : C \u2964 D) (F : simplex_category\u1d52\u1d56 \u2964 C)\n\t(_x _x_1 : simplex_category\u1d52\u1d56) (f : _x \u27f6 _x_1) :\n\t(((category_theory.simplicial_object.whiskering C D).obj H).obj F).map f = H.map (F.map f)", "decl_tp": "\u2200 (C : Type u) [_inst_1 : category_theory.category C] (D : Type u_1) [_inst_2 : category_theory.category D] (H : C \u2964 D) (F : simplex_category\u1d52\u1d56 \u2964 C) (_x _x_1 : simplex_category\u1d52\u1d56) (f : _x \u27f6 _x_1), (((category_theory.simplicial_object.whiskering C D).obj H).obj F).map f = H.map (F.map f)", "decl_nm": "category_theory.simplicial_object.whiskering_obj_obj_map"}
{"formal_statement": "theorem of_succ {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c] {E : Type*} [normed_group E]\n\t[normed_space \ud835\udd5c E] {H : Type*} [topological_space H] {I : model_with_corners \ud835\udd5c E H}\n\t{M : Type*} [topological_space M] [charted_space H M] {E' : Type*} [normed_group E']\n\t[normed_space \ud835\udd5c E'] {H' : Type*} [topological_space H'] {I' : model_with_corners \ud835\udd5c E' H'}\n\t{M' : Type*} [topological_space M'] [charted_space H' M'] {f : M \u2192 M'}\n\t{s : set M} {x : M} {n : \u2115} (h : times_cont_mdiff_within_at I I' \u2191(n.succ) f s x) :\n\ttimes_cont_mdiff_within_at I I' \u2191n f s x", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {H : Type u_3} [_inst_4 : topological_space H] {I : model_with_corners \ud835\udd5c E H} {M : Type u_4} [_inst_5 : topological_space M] [_inst_6 : charted_space H M] {E' : Type u_5} [_inst_7 : normed_group E'] [_inst_8 : normed_space \ud835\udd5c E'] {H' : Type u_6} [_inst_9 : topological_space H'] {I' : model_with_corners \ud835\udd5c E' H'} {M' : Type u_7} [_inst_10 : topological_space M'] [_inst_11 : charted_space H' M'] {f : M \u2192 M'} {s : set M} {x : M} {n : \u2115}, times_cont_mdiff_within_at I I' \u2191(n.succ) f s x \u2192 times_cont_mdiff_within_at I I' \u2191n f s x", "decl_nm": "times_cont_mdiff_within_at.of_succ"}
{"formal_statement": "theorem norm_subtypeL {\ud835\udd5c E : Type*} [normed_group E] [nondiscrete_normed_field \ud835\udd5c]\n\t[normed_space \ud835\udd5c E] (K : submodule \ud835\udd5c E) [nontrivial \u21a5K] :\n\t\u2225K.subtypeL\u2225 = 1", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} {E : Type u_4} [_inst_1 : normed_group E] [_inst_5 : nondiscrete_normed_field \ud835\udd5c] [_inst_8 : normed_space \ud835\udd5c E] (K : submodule \ud835\udd5c E) [_inst_10 : nontrivial \u21a5K], \u2225K.subtypeL\u2225 = 1", "decl_nm": "submodule.norm_subtypeL"}
{"formal_statement": "theorem fst {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c] {E : Type*} [normed_group E]\n\t[normed_space \ud835\udd5c E] {F : Type*} [normed_group F] [normed_space \ud835\udd5c F] {G : Type*}\n\t[normed_group G] [normed_space \ud835\udd5c G] {x : E} {f\u2082 : E \u2192 F \u00d7 G} (h : differentiable_at \ud835\udd5c f\u2082 x) :\n\tdifferentiable_at \ud835\udd5c (\u03bb (x : E), (f\u2082 x).fst) x", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {F : Type u_3} [_inst_4 : normed_group F] [_inst_5 : normed_space \ud835\udd5c F] {G : Type u_4} [_inst_6 : normed_group G] [_inst_7 : normed_space \ud835\udd5c G] {x : E} {f\u2082 : E \u2192 F \u00d7 G}, differentiable_at \ud835\udd5c f\u2082 x \u2192 differentiable_at \ud835\udd5c (\u03bb (x : E), (f\u2082 x).fst) x", "decl_nm": "differentiable_at.fst"}
{"formal_statement": "theorem sum_fiberwise_le_sum_of_sum_fiber_nonneg {\u03b9 N : Type*} [ordered_add_comm_monoid N]\n\t{s : finset \u03b9} {\u03b9' : Type*} [decidable_eq \u03b9'] {t : finset \u03b9'} {g : \u03b9 \u2192 \u03b9'}\n\t{f : \u03b9 \u2192 N} :\n\t(\u2200 (y : \u03b9'), y \u2209 t \u2192 0 \u2264 (finset.filter (\u03bb (x : \u03b9), g x = y) s).sum (\u03bb (x : \u03b9), f x)) \u2192 t.sum (\u03bb (y : \u03b9'), (finset.filter (\u03bb (x : \u03b9), g x = y) s).sum (\u03bb (x : \u03b9), f x)) \u2264 s.sum (\u03bb (x : \u03b9), f x)", "decl_tp": "\u2200 {\u03b9 : Type u_1} {N : Type u_5} [_inst_2 : ordered_add_comm_monoid N] {s : finset \u03b9} {\u03b9' : Type u_9} [_inst_3 : decidable_eq \u03b9'] {t : finset \u03b9'} {g : \u03b9 \u2192 \u03b9'} {f : \u03b9 \u2192 N}, (\u2200 (y : \u03b9'), y \u2209 t \u2192 0 \u2264 (finset.filter (\u03bb (x : \u03b9), g x = y) s).sum (\u03bb (x : \u03b9), f x)) \u2192 t.sum (\u03bb (y : \u03b9'), (finset.filter (\u03bb (x : \u03b9), g x = y) s).sum (\u03bb (x : \u03b9), f x)) \u2264 s.sum (\u03bb (x : \u03b9), f x)", "decl_nm": "finset.sum_fiberwise_le_sum_of_sum_fiber_nonneg"}
{"formal_statement": "theorem gcd_mul_right (i j k : \u2124) :\n\t(i * j).gcd (k * j) = i.gcd k * j.nat_abs", "decl_tp": "\u2200 (i j k : \u2124), (i * j).gcd (k * j) = i.gcd k * j.nat_abs", "decl_nm": "int.gcd_mul_right"}
{"formal_statement": "theorem ereal_to_real {\u03b1 : Type*} [measurable_space \u03b1] {f : \u03b1 \u2192 ereal}\n\t(hf : measurable f) :\n\tmeasurable (\u03bb (x : \u03b1), (f x).to_real)", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : measurable_space \u03b1] {f : \u03b1 \u2192 ereal}, measurable f \u2192 measurable (\u03bb (x : \u03b1), (f x).to_real)", "decl_nm": "measurable.ereal_to_real"}
{"formal_statement": "theorem exists_mem_finset_dvd {\u03b1 \u03b2 : Type*} [comm_monoid_with_zero \u03b1] {p : \u03b1}\n\t(hp : prime p) :\n\t\u2200 {s : finset \u03b2} {f : \u03b2 \u2192 \u03b1}, p \u2223 s.prod f \u2192 (\u2203 (i : \u03b2) (H : i \u2208 s), p \u2223 f i)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : comm_monoid_with_zero \u03b1] {p : \u03b1}, prime p \u2192 \u2200 {s : finset \u03b2} {f : \u03b2 \u2192 \u03b1}, p \u2223 s.prod f \u2192 (\u2203 (i : \u03b2) (H : i \u2208 s), p \u2223 f i)", "decl_nm": "prime.exists_mem_finset_dvd"}
{"formal_statement": "theorem integral_nonpos {\u03b1 : Type*} {m : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1}\n\t{f : \u03b1 \u2192 \u211d} (hf : f \u2264 0) :\n\t\u222b (a : \u03b1), f a \u2202\u03bc \u2264 0", "decl_tp": "\u2200 {\u03b1 : Type u_1} {m : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} {f : \u03b1 \u2192 \u211d}, f \u2264 0 \u2192 \u222b (a : \u03b1), f a \u2202\u03bc \u2264 0", "decl_nm": "measure_theory.integral_nonpos"}
{"formal_statement": "theorem conj_apply {G : Type*} [group G] (g h : G) :\n\t\u21d1(\u21d1mul_aut.conj g) h = g * h * g\u207b\u00b9", "decl_tp": "\u2200 {G : Type u_3} [_inst_2 : group G] (g h : G), \u21d1(\u21d1mul_aut.conj g) h = g * h * g\u207b\u00b9", "decl_nm": "mul_aut.conj_apply"}
{"formal_statement": "theorem nonempty_product {\u03b1 \u03b2 : Type*} {s : finset \u03b1} {t : finset \u03b2} :\n\t(s.product t).nonempty \u2194 s.nonempty \u2227 t.nonempty", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {s : finset \u03b1} {t : finset \u03b2}, (s.product t).nonempty \u2194 s.nonempty \u2227 t.nonempty", "decl_nm": "finset.nonempty_product"}
{"formal_statement": "theorem sub {\u03b1 : Type u} {\u03b2 : Type v} [topological_space \u03b1] [ordered_add_comm_group \u03b2]\n\t{f g : \u03b1 \u2192 \u03b2} {a : \u03b1} {s : set \u03b1} (hf : is_local_min_on f s a) (hg : is_local_max_on g s a) :\n\tis_local_min_on (\u03bb (x : \u03b1), f x - g x) s a", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : topological_space \u03b1] [_inst_2 : ordered_add_comm_group \u03b2] {f g : \u03b1 \u2192 \u03b2} {a : \u03b1} {s : set \u03b1}, is_local_min_on f s a \u2192 is_local_max_on g s a \u2192 is_local_min_on (\u03bb (x : \u03b1), f x - g x) s a", "decl_nm": "is_local_min_on.sub"}
{"formal_statement": "theorem congr_left {x y z : pSet} (\u1fb0 : x.equiv y) :\n\t(x \u2286 z \u2194 y \u2286 z)", "decl_tp": "\u2200 {x y z : pSet}, x.equiv y \u2192 (x \u2286 z \u2194 y \u2286 z)", "decl_nm": "pSet.subset.congr_left"}
{"formal_statement": "theorem lift_\u03c0_app {C : Type u} [category_theory.category C] {J : Type u\u2081}\n\t[category_theory.category J] {K : Type u\u2082} [category_theory.category K]\n\t(H : J \u2964 K \u2964 C) [category_theory.limits.has_limit H] (c : category_theory.limits.cone H)\n\t(j : J) (k : K) :\n\t(category_theory.limits.limit.lift H c).app k \u226b (category_theory.limits.limit.\u03c0 H j).app k = (c.\u03c0.app j).app k", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] {J : Type u\u2081} [_inst_3 : category_theory.category J] {K : Type u\u2082} [_inst_4 : category_theory.category K] (H : J \u2964 K \u2964 C) [_inst_5 : category_theory.limits.has_limit H] (c : category_theory.limits.cone H) (j : J) (k : K), (category_theory.limits.limit.lift H c).app k \u226b (category_theory.limits.limit.\u03c0 H j).app k = (c.\u03c0.app j).app k", "decl_nm": "category_theory.limits.limit.lift_\u03c0_app"}
{"formal_statement": "theorem continuous_iff_continuous_at {\u03b1 \u03b2 : Type*} [topological_space \u03b1]\n\t[topological_space \u03b2] {f : \u03b1 \u2192 \u03b2} :\n\tcontinuous f \u2194 \u2200 (x : \u03b1), continuous_at f x", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : topological_space \u03b1] [_inst_2 : topological_space \u03b2] {f : \u03b1 \u2192 \u03b2}, continuous f \u2194 \u2200 (x : \u03b1), continuous_at f x", "decl_nm": "continuous_iff_continuous_at"}
{"formal_statement": "theorem continuous {R R\u2082 E E\u2082 : Type*} [semiring R] [semiring R\u2082] {\u03c3\u2081\u2082 : R \u2192+* R\u2082}\n\t{\u03c3\u2082\u2081 : R\u2082 \u2192+* R} [ring_hom_inv_pair \u03c3\u2081\u2082 \u03c3\u2082\u2081] [ring_hom_inv_pair \u03c3\u2082\u2081 \u03c3\u2081\u2082]\n\t[semi_normed_group E] [semi_normed_group E\u2082] [module R E] [module R\u2082 E\u2082]\n\t(e : E \u2243\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082) :\n\tcontinuous \u21d1e", "decl_tp": "\u2200 {R : Type u_1} {R\u2082 : Type u_2} {E : Type u_5} {E\u2082 : Type u_6} [_inst_1 : semiring R] [_inst_2 : semiring R\u2082] {\u03c3\u2081\u2082 : R \u2192+* R\u2082} {\u03c3\u2082\u2081 : R\u2082 \u2192+* R} [_inst_5 : ring_hom_inv_pair \u03c3\u2081\u2082 \u03c3\u2082\u2081] [_inst_6 : ring_hom_inv_pair \u03c3\u2082\u2081 \u03c3\u2081\u2082] [_inst_25 : semi_normed_group E] [_inst_26 : semi_normed_group E\u2082] [_inst_29 : module R E] [_inst_30 : module R\u2082 E\u2082] (e : E \u2243\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082), continuous \u21d1e", "decl_nm": "linear_isometry_equiv.continuous"}
{"formal_statement": "theorem coe_fin_range (n : \u2115) :\n\t\u2191(finset.fin_range n) = set.univ", "decl_tp": "\u2200 (n : \u2115), \u2191(finset.fin_range n) = set.univ", "decl_nm": "finset.coe_fin_range"}
{"formal_statement": "theorem rank_prod' (R : Type u) (M : Type v) [ring R] [strong_rank_condition R]\n\t[add_comm_group M] [module R M] [module.free R M] (N : Type v) [add_comm_group N]\n\t[module R N] [module.free R N] :\n\tmodule.rank R (M \u00d7 N) = module.rank R M + module.rank R N", "decl_tp": "\u2200 (R : Type u) (M : Type v) [_inst_1 : ring R] [_inst_2 : strong_rank_condition R] [_inst_3 : add_comm_group M] [_inst_4 : module R M] [_inst_5 : module.free R M] (N : Type v) [_inst_9 : add_comm_group N] [_inst_10 : module R N] [_inst_11 : module.free R N], module.rank R (M \u00d7 N) = module.rank R M + module.rank R N", "decl_nm": "module.free.rank_prod'"}
{"formal_statement": "theorem mem_carrier {M : Type*} [add_zero_class M] {s : add_submonoid M}\n\t{x : M} :\n\tx \u2208 s.carrier \u2194 x \u2208 s", "decl_tp": "\u2200 {M : Type u_1} [_inst_1 : add_zero_class M] {s : add_submonoid M} {x : M}, x \u2208 s.carrier \u2194 x \u2208 s", "decl_nm": "add_submonoid.mem_carrier"}
{"formal_statement": "theorem differentiable_rpow_const {p : \u211d} (hp : 1 \u2264 p) :\n\tdifferentiable \u211d (\u03bb (x : \u211d), x ^ p)", "decl_tp": "\u2200 {p : \u211d}, 1 \u2264 p \u2192 differentiable \u211d (\u03bb (x : \u211d), x ^ p)", "decl_nm": "real.differentiable_rpow_const"}
{"formal_statement": "theorem exists_not_mem_finset {\u03b1 : Type*} [infinite \u03b1] (s : finset \u03b1) :\n\t\u2203 (x : \u03b1), x \u2209 s", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : infinite \u03b1] (s : finset \u03b1), \u2203 (x : \u03b1), x \u2209 s", "decl_nm": "infinite.exists_not_mem_finset"}
{"formal_statement": "theorem has_deriv_at_mul_const {\ud835\udd5c : Type u} [nondiscrete_normed_field \ud835\udd5c]\n\t{x : \ud835\udd5c} (c : \ud835\udd5c) :\n\thas_deriv_at (\u03bb (x : \ud835\udd5c), x * c) c x", "decl_tp": "\u2200 {\ud835\udd5c : Type u} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {x : \ud835\udd5c} (c : \ud835\udd5c), has_deriv_at (\u03bb (x : \ud835\udd5c), x * c) c x", "decl_nm": "has_deriv_at_mul_const"}
{"formal_statement": "theorem top_adj {V : Type u} (v w : V) :\n\t\u22a4.adj v w \u2194 v \u2260 w", "decl_tp": "\u2200 {V : Type u} (v w : V), \u22a4.adj v w \u2194 v \u2260 w", "decl_nm": "simple_graph.top_adj"}
{"formal_statement": "theorem cancel_counit_right {C : Type u\u2081} [category_theory.category C]\n\t{D : Type u\u2082} [category_theory.category D] (e : C \u224c D) {X Y : D} (f f' : X \u27f6 e.functor.obj (e.inverse.obj Y)) :\n\tf \u226b e.counit.app Y = f' \u226b e.counit.app Y \u2194 f = f'", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {D : Type u\u2082} [_inst_2 : category_theory.category D] (e : C \u224c D) {X Y : D} (f f' : X \u27f6 e.functor.obj (e.inverse.obj Y)), f \u226b e.counit.app Y = f' \u226b e.counit.app Y \u2194 f = f'", "decl_nm": "category_theory.equivalence.cancel_counit_right"}
{"formal_statement": "theorem choice_eq {\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} [\u03a0 (i : \u03b9), setoid (\u03b1 i)]\n\t(f : \u03a0 (i : \u03b9), \u03b1 i) :\n\tquotient.choice (\u03bb (i : \u03b9), \u27e6f i\u27e7) = \u27e6f\u27e7", "decl_tp": "\u2200 {\u03b9 : Type u_1} {\u03b1 : \u03b9 \u2192 Type u_2} [_inst_1 : \u03a0 (i : \u03b9), setoid (\u03b1 i)] (f : \u03a0 (i : \u03b9), \u03b1 i), quotient.choice (\u03bb (i : \u03b9), \u27e6f i\u27e7) = \u27e6f\u27e7", "decl_nm": "quotient.choice_eq"}
{"formal_statement": "theorem arg_equiv_apply_coe (z : \u21a5circle) :\n\t\u2191(\u21d1circle.arg_equiv z) = \u2191z.arg", "decl_tp": "\u2200 (z : \u21a5circle), \u2191(\u21d1circle.arg_equiv z) = \u2191z.arg", "decl_nm": "circle.arg_equiv_apply_coe"}
{"formal_statement": "theorem plus_def {\u03b1 : Type u} (P Q : regular_expression \u03b1) :\n\tP.plus Q = P + Q", "decl_tp": "\u2200 {\u03b1 : Type u} (P Q : regular_expression \u03b1), P.plus Q = P + Q", "decl_nm": "regular_expression.plus_def"}
{"formal_statement": "theorem tendsto_nhds_within_mono_right {\u03b1 \u03b2 : Type*} [topological_space \u03b1]\n\t{f : \u03b2 \u2192 \u03b1} {l : filter \u03b2} {a : \u03b1} {s t : set \u03b1} (hst : s \u2286 t) (h : filter.tendsto f l (nhds_within a s)) :\n\tfilter.tendsto f l (nhds_within a t)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : topological_space \u03b1] {f : \u03b2 \u2192 \u03b1} {l : filter \u03b2} {a : \u03b1} {s t : set \u03b1}, s \u2286 t \u2192 filter.tendsto f l (nhds_within a s) \u2192 filter.tendsto f l (nhds_within a t)", "decl_nm": "tendsto_nhds_within_mono_right"}
{"formal_statement": "theorem inits_cons {\u03b1 : Type*} (a : \u03b1) (l : list \u03b1) :\n\t(a :: l).inits = list.nil :: list.map (\u03bb (t : list \u03b1), a :: t) l.inits", "decl_tp": "\u2200 {\u03b1 : Type u_1} (a : \u03b1) (l : list \u03b1), (a :: l).inits = list.nil :: list.map (\u03bb (t : list \u03b1), a :: t) l.inits", "decl_nm": "list.inits_cons"}
{"formal_statement": "theorem supr_congr_Prop {\u03b1 : Type*} [has_Sup \u03b1] {p q : Prop} {f\u2081 : p \u2192 \u03b1}\n\t{f\u2082 : q \u2192 \u03b1} (pq : p \u2194 q) :\n\t(\u2200 (x : q), f\u2081 _ = f\u2082 x) \u2192 supr f\u2081 = supr f\u2082", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_2 : has_Sup \u03b1] {p q : Prop} {f\u2081 : p \u2192 \u03b1} {f\u2082 : q \u2192 \u03b1} (pq : p \u2194 q), (\u2200 (x : q), f\u2081 _ = f\u2082 x) \u2192 supr f\u2081 = supr f\u2082", "decl_nm": "supr_congr_Prop"}
{"formal_statement": "theorem continuous_completion {\u03b1 \u03b2 : Type*} [uniform_space \u03b1] [add_group \u03b1]\n\t[uniform_add_group \u03b1] [uniform_space \u03b2] [add_group \u03b2] [uniform_add_group \u03b2]\n\t(f : \u03b1 \u2192+ \u03b2) (hf : continuous \u21d1f) :\n\tcontinuous \u21d1(f.completion hf)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : uniform_space \u03b1] [_inst_2 : add_group \u03b1] [_inst_3 : uniform_add_group \u03b1] [_inst_4 : uniform_space \u03b2] [_inst_5 : add_group \u03b2] [_inst_6 : uniform_add_group \u03b2] (f : \u03b1 \u2192+ \u03b2) (hf : continuous \u21d1f), continuous \u21d1(f.completion hf)", "decl_nm": "add_monoid_hom.continuous_completion"}
{"formal_statement": "theorem mem_pure' {\u03b1 : Type*} {a b : \u03b1} :\n\ta \u2208 semiquot.pure b \u2194 a = b", "decl_tp": "\u2200 {\u03b1 : Type u_1} {a b : \u03b1}, a \u2208 semiquot.pure b \u2194 a = b", "decl_nm": "semiquot.mem_pure'"}
{"formal_statement": "theorem is_o_pi {\u03b1 F' : Type*} [normed_group F'] {g' : \u03b1 \u2192 F'} {l : filter \u03b1}\n\t{\u03b9 : Type*} [fintype \u03b9] {E' : \u03b9 \u2192 Type*} [\u03a0 (i : \u03b9), normed_group (E' i)]\n\t{f : \u03b1 \u2192 \u03a0 (i : \u03b9), E' i} :\n\tasymptotics.is_o f g' l \u2194 \u2200 (i : \u03b9), asymptotics.is_o (\u03bb (x : \u03b1), f x i) g' l", "decl_tp": "\u2200 {\u03b1 : Type u_1} {F' : Type u_7} [_inst_5 : normed_group F'] {g' : \u03b1 \u2192 F'} {l : filter \u03b1} {\u03b9 : Type u_2} [_inst_11 : fintype \u03b9] {E' : \u03b9 \u2192 Type u_3} [_inst_12 : \u03a0 (i : \u03b9), normed_group (E' i)] {f : \u03b1 \u2192 \u03a0 (i : \u03b9), E' i}, asymptotics.is_o f g' l \u2194 \u2200 (i : \u03b9), asymptotics.is_o (\u03bb (x : \u03b1), f x i) g' l", "decl_nm": "asymptotics.is_o_pi"}